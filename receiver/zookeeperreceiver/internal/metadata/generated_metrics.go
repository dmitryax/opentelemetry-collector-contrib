// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"

	"github.com/open-telemetry/opentelemetry-collector-contrib/pkg/pdatautil"
)

// AttributeDirection specifies the a value direction attribute.
type AttributeDirection int

const (
	_ AttributeDirection = iota
	AttributeDirectionReceived
	AttributeDirectionSent
)

// String returns the string representation of the AttributeDirection.
func (av AttributeDirection) String() string {
	switch av {
	case AttributeDirectionReceived:
		return "received"
	case AttributeDirectionSent:
		return "sent"
	}
	return ""
}

// MapAttributeDirection is a helper map of string to AttributeDirection attribute value.
var MapAttributeDirection = map[string]AttributeDirection{
	"received": AttributeDirectionReceived,
	"sent":     AttributeDirectionSent,
}

// AttributeState specifies the a value state attribute.
type AttributeState int

const (
	_ AttributeState = iota
	AttributeStateSynced
	AttributeStateUnsynced
)

// String returns the string representation of the AttributeState.
func (av AttributeState) String() string {
	switch av {
	case AttributeStateSynced:
		return "synced"
	case AttributeStateUnsynced:
		return "unsynced"
	}
	return ""
}

// MapAttributeState is a helper map of string to AttributeState attribute value.
var MapAttributeState = map[string]AttributeState{
	"synced":   AttributeStateSynced,
	"unsynced": AttributeStateUnsynced,
}

type metricZookeeperConnectionActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.connection.active metric with initial data.
func (m *metricZookeeperConnectionActive) init() {
	m.data.SetName("zookeeper.connection.active")
	m.data.SetDescription("Number of active clients connected to a ZooKeeper server.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricZookeeperConnectionActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperConnectionActive) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperConnectionActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperConnectionActive(cfg MetricConfig) metricZookeeperConnectionActive {
	m := metricZookeeperConnectionActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperDataTreeEphemeralNodeCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.data_tree.ephemeral_node.count metric with initial data.
func (m *metricZookeeperDataTreeEphemeralNodeCount) init() {
	m.data.SetName("zookeeper.data_tree.ephemeral_node.count")
	m.data.SetDescription("Number of ephemeral nodes that a ZooKeeper server has in its data tree.")
	m.data.SetUnit("{nodes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricZookeeperDataTreeEphemeralNodeCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperDataTreeEphemeralNodeCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperDataTreeEphemeralNodeCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperDataTreeEphemeralNodeCount(cfg MetricConfig) metricZookeeperDataTreeEphemeralNodeCount {
	m := metricZookeeperDataTreeEphemeralNodeCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperDataTreeSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.data_tree.size metric with initial data.
func (m *metricZookeeperDataTreeSize) init() {
	m.data.SetName("zookeeper.data_tree.size")
	m.data.SetDescription("Size of data in bytes that a ZooKeeper server has in its data tree.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricZookeeperDataTreeSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperDataTreeSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperDataTreeSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperDataTreeSize(cfg MetricConfig) metricZookeeperDataTreeSize {
	m := metricZookeeperDataTreeSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFileDescriptorLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.file_descriptor.limit metric with initial data.
func (m *metricZookeeperFileDescriptorLimit) init() {
	m.data.SetName("zookeeper.file_descriptor.limit")
	m.data.SetDescription("Maximum number of file descriptors that a ZooKeeper server can open.")
	m.data.SetUnit("{file_descriptors}")
	m.data.SetEmptyGauge()
}

func (m *metricZookeeperFileDescriptorLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFileDescriptorLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFileDescriptorLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFileDescriptorLimit(cfg MetricConfig) metricZookeeperFileDescriptorLimit {
	m := metricZookeeperFileDescriptorLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFileDescriptorOpen struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.file_descriptor.open metric with initial data.
func (m *metricZookeeperFileDescriptorOpen) init() {
	m.data.SetName("zookeeper.file_descriptor.open")
	m.data.SetDescription("Number of file descriptors that a ZooKeeper server has open.")
	m.data.SetUnit("{file_descriptors}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricZookeeperFileDescriptorOpen) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFileDescriptorOpen) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFileDescriptorOpen) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFileDescriptorOpen(cfg MetricConfig) metricZookeeperFileDescriptorOpen {
	m := metricZookeeperFileDescriptorOpen{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFollowerCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.follower.count metric with initial data.
func (m *metricZookeeperFollowerCount) init() {
	m.data.SetName("zookeeper.follower.count")
	m.data.SetDescription("The number of followers. Only exposed by the leader.")
	m.data.SetUnit("{followers}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricZookeeperFollowerCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, stateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", stateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFollowerCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFollowerCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFollowerCount(cfg MetricConfig) metricZookeeperFollowerCount {
	m := metricZookeeperFollowerCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperFsyncExceededThresholdCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.fsync.exceeded_threshold.count metric with initial data.
func (m *metricZookeeperFsyncExceededThresholdCount) init() {
	m.data.SetName("zookeeper.fsync.exceeded_threshold.count")
	m.data.SetDescription("Number of times fsync duration has exceeded warning threshold.")
	m.data.SetUnit("{events}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricZookeeperFsyncExceededThresholdCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperFsyncExceededThresholdCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperFsyncExceededThresholdCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperFsyncExceededThresholdCount(cfg MetricConfig) metricZookeeperFsyncExceededThresholdCount {
	m := metricZookeeperFsyncExceededThresholdCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperLatencyAvg struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.latency.avg metric with initial data.
func (m *metricZookeeperLatencyAvg) init() {
	m.data.SetName("zookeeper.latency.avg")
	m.data.SetDescription("Average time in milliseconds for requests to be processed.")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricZookeeperLatencyAvg) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperLatencyAvg) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperLatencyAvg) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperLatencyAvg(cfg MetricConfig) metricZookeeperLatencyAvg {
	m := metricZookeeperLatencyAvg{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperLatencyMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.latency.max metric with initial data.
func (m *metricZookeeperLatencyMax) init() {
	m.data.SetName("zookeeper.latency.max")
	m.data.SetDescription("Maximum time in milliseconds for requests to be processed.")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricZookeeperLatencyMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperLatencyMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperLatencyMax) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperLatencyMax(cfg MetricConfig) metricZookeeperLatencyMax {
	m := metricZookeeperLatencyMax{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperLatencyMin struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.latency.min metric with initial data.
func (m *metricZookeeperLatencyMin) init() {
	m.data.SetName("zookeeper.latency.min")
	m.data.SetDescription("Minimum time in milliseconds for requests to be processed.")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricZookeeperLatencyMin) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperLatencyMin) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperLatencyMin) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperLatencyMin(cfg MetricConfig) metricZookeeperLatencyMin {
	m := metricZookeeperLatencyMin{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperPacketCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.packet.count metric with initial data.
func (m *metricZookeeperPacketCount) init() {
	m.data.SetName("zookeeper.packet.count")
	m.data.SetDescription("The number of ZooKeeper packets received or sent by a server.")
	m.data.SetUnit("{packets}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricZookeeperPacketCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperPacketCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperPacketCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperPacketCount(cfg MetricConfig) metricZookeeperPacketCount {
	m := metricZookeeperPacketCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperRequestActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.request.active metric with initial data.
func (m *metricZookeeperRequestActive) init() {
	m.data.SetName("zookeeper.request.active")
	m.data.SetDescription("Number of currently executing requests.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricZookeeperRequestActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperRequestActive) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperRequestActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperRequestActive(cfg MetricConfig) metricZookeeperRequestActive {
	m := metricZookeeperRequestActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperRuok struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.ruok metric with initial data.
func (m *metricZookeeperRuok) init() {
	m.data.SetName("zookeeper.ruok")
	m.data.SetDescription("Response from zookeeper ruok command")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricZookeeperRuok) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperRuok) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperRuok) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperRuok(cfg MetricConfig) metricZookeeperRuok {
	m := metricZookeeperRuok{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperSyncPending struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.sync.pending metric with initial data.
func (m *metricZookeeperSyncPending) init() {
	m.data.SetName("zookeeper.sync.pending")
	m.data.SetDescription("The number of pending syncs from the followers. Only exposed by the leader.")
	m.data.SetUnit("{syncs}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricZookeeperSyncPending) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperSyncPending) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperSyncPending) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperSyncPending(cfg MetricConfig) metricZookeeperSyncPending {
	m := metricZookeeperSyncPending{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperWatchCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.watch.count metric with initial data.
func (m *metricZookeeperWatchCount) init() {
	m.data.SetName("zookeeper.watch.count")
	m.data.SetDescription("Number of watches placed on Z-Nodes on a ZooKeeper server.")
	m.data.SetUnit("{watches}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricZookeeperWatchCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperWatchCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperWatchCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperWatchCount(cfg MetricConfig) metricZookeeperWatchCount {
	m := metricZookeeperWatchCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricZookeeperZnodeCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills zookeeper.znode.count metric with initial data.
func (m *metricZookeeperZnodeCount) init() {
	m.data.SetName("zookeeper.znode.count")
	m.data.SetDescription("Number of z-nodes that a ZooKeeper server has in its data tree.")
	m.data.SetUnit("{znodes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricZookeeperZnodeCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricZookeeperZnodeCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricZookeeperZnodeCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricZookeeperZnodeCount(cfg MetricConfig) metricZookeeperZnodeCount {
	m := metricZookeeperZnodeCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// missedEmitsToDropRMB is number of missed emits after which resource builder will be dropped from MetricsBuilder.rmbMap.
// Potentially, this value can be made configurable through a MetricsBuilder option.
const missedEmitsToDropRMB = 5

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config    MetricsBuilderConfig                 // config of the metrics builder.
	buildInfo component.BuildInfo                  // contains version information
	startTime pcommon.Timestamp                    // start time that will be applied to all recorded data points.
	rmbMap    map[[16]byte]*ResourceMetricsBuilder // map of resource builders by resource hash.
}

type ResourceMetricsBuilder struct {
	buildInfo                                  component.BuildInfo
	startTime                                  pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                            int               // maximum observed number of metrics per resource.
	resource                                   pcommon.Resource
	missedEmits                                int
	metricZookeeperConnectionActive            metricZookeeperConnectionActive
	metricZookeeperDataTreeEphemeralNodeCount  metricZookeeperDataTreeEphemeralNodeCount
	metricZookeeperDataTreeSize                metricZookeeperDataTreeSize
	metricZookeeperFileDescriptorLimit         metricZookeeperFileDescriptorLimit
	metricZookeeperFileDescriptorOpen          metricZookeeperFileDescriptorOpen
	metricZookeeperFollowerCount               metricZookeeperFollowerCount
	metricZookeeperFsyncExceededThresholdCount metricZookeeperFsyncExceededThresholdCount
	metricZookeeperLatencyAvg                  metricZookeeperLatencyAvg
	metricZookeeperLatencyMax                  metricZookeeperLatencyMax
	metricZookeeperLatencyMin                  metricZookeeperLatencyMin
	metricZookeeperPacketCount                 metricZookeeperPacketCount
	metricZookeeperRequestActive               metricZookeeperRequestActive
	metricZookeeperRuok                        metricZookeeperRuok
	metricZookeeperSyncPending                 metricZookeeperSyncPending
	metricZookeeperWatchCount                  metricZookeeperWatchCount
	metricZookeeperZnodeCount                  metricZookeeperZnodeCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:    mbc,
		startTime: pcommon.NewTimestampFromTime(time.Now()),
		buildInfo: settings.BuildInfo,
		rmbMap:    make(map[[16]byte]*ResourceMetricsBuilder),
	}
	for _, opt := range options {
		opt(mb)
	}
	return mb
}

// resourceMetricsBuilderOption applies changes to provided resource metrics.
type resourceMetricsBuilderOption func(*ResourceMetricsBuilder)

// WithStartTimeOverride sets start time for all the resource metrics data points.
func WithStartTimeOverride(start pcommon.Timestamp) resourceMetricsBuilderOption {
	return func(rmb *ResourceMetricsBuilder) {
		rmb.startTime = start
	}
}

// ResourceMetricsBuilder returns a ResourceMetricsBuilder that can be used to record metrics for a specific resource.
// It requires Resource to be provided which should be built with ResourceBuilder.
func (mb *MetricsBuilder) ResourceMetricsBuilder(res pcommon.Resource, options ...resourceMetricsBuilderOption) *ResourceMetricsBuilder {
	hash := pdatautil.MapHash(res.Attributes())
	if rmb, ok := mb.rmbMap[hash]; ok {
		return rmb
	}
	rmb := &ResourceMetricsBuilder{
		startTime:                       mb.startTime,
		buildInfo:                       mb.buildInfo,
		resource:                        res,
		metricZookeeperConnectionActive: newMetricZookeeperConnectionActive(mb.config.Metrics.ZookeeperConnectionActive),
		metricZookeeperDataTreeEphemeralNodeCount:  newMetricZookeeperDataTreeEphemeralNodeCount(mb.config.Metrics.ZookeeperDataTreeEphemeralNodeCount),
		metricZookeeperDataTreeSize:                newMetricZookeeperDataTreeSize(mb.config.Metrics.ZookeeperDataTreeSize),
		metricZookeeperFileDescriptorLimit:         newMetricZookeeperFileDescriptorLimit(mb.config.Metrics.ZookeeperFileDescriptorLimit),
		metricZookeeperFileDescriptorOpen:          newMetricZookeeperFileDescriptorOpen(mb.config.Metrics.ZookeeperFileDescriptorOpen),
		metricZookeeperFollowerCount:               newMetricZookeeperFollowerCount(mb.config.Metrics.ZookeeperFollowerCount),
		metricZookeeperFsyncExceededThresholdCount: newMetricZookeeperFsyncExceededThresholdCount(mb.config.Metrics.ZookeeperFsyncExceededThresholdCount),
		metricZookeeperLatencyAvg:                  newMetricZookeeperLatencyAvg(mb.config.Metrics.ZookeeperLatencyAvg),
		metricZookeeperLatencyMax:                  newMetricZookeeperLatencyMax(mb.config.Metrics.ZookeeperLatencyMax),
		metricZookeeperLatencyMin:                  newMetricZookeeperLatencyMin(mb.config.Metrics.ZookeeperLatencyMin),
		metricZookeeperPacketCount:                 newMetricZookeeperPacketCount(mb.config.Metrics.ZookeeperPacketCount),
		metricZookeeperRequestActive:               newMetricZookeeperRequestActive(mb.config.Metrics.ZookeeperRequestActive),
		metricZookeeperRuok:                        newMetricZookeeperRuok(mb.config.Metrics.ZookeeperRuok),
		metricZookeeperSyncPending:                 newMetricZookeeperSyncPending(mb.config.Metrics.ZookeeperSyncPending),
		metricZookeeperWatchCount:                  newMetricZookeeperWatchCount(mb.config.Metrics.ZookeeperWatchCount),
		metricZookeeperZnodeCount:                  newMetricZookeeperZnodeCount(mb.config.Metrics.ZookeeperZnodeCount),
	}
	for _, op := range options {
		op(rmb)
	}
	mb.rmbMap[hash] = rmb
	return rmb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (rmb *ResourceMetricsBuilder) updateCapacity(ms pmetric.MetricSlice) {
	if rmb.metricsCapacity < ms.Len() {
		rmb.metricsCapacity = ms.Len()
	}
}

// emit emits all the metrics accumulated by the ResourceMetricsBuilder and updates the internal state to be ready for
// recording another set of metrics. It returns true if any metrics were emitted.
func (rmb *ResourceMetricsBuilder) emit(m pmetric.Metrics) bool {
	sm := pmetric.NewScopeMetrics()
	sm.Metrics().EnsureCapacity(rmb.metricsCapacity)
	rmb.metricZookeeperConnectionActive.emit(sm.Metrics())
	rmb.metricZookeeperDataTreeEphemeralNodeCount.emit(sm.Metrics())
	rmb.metricZookeeperDataTreeSize.emit(sm.Metrics())
	rmb.metricZookeeperFileDescriptorLimit.emit(sm.Metrics())
	rmb.metricZookeeperFileDescriptorOpen.emit(sm.Metrics())
	rmb.metricZookeeperFollowerCount.emit(sm.Metrics())
	rmb.metricZookeeperFsyncExceededThresholdCount.emit(sm.Metrics())
	rmb.metricZookeeperLatencyAvg.emit(sm.Metrics())
	rmb.metricZookeeperLatencyMax.emit(sm.Metrics())
	rmb.metricZookeeperLatencyMin.emit(sm.Metrics())
	rmb.metricZookeeperPacketCount.emit(sm.Metrics())
	rmb.metricZookeeperRequestActive.emit(sm.Metrics())
	rmb.metricZookeeperRuok.emit(sm.Metrics())
	rmb.metricZookeeperSyncPending.emit(sm.Metrics())
	rmb.metricZookeeperWatchCount.emit(sm.Metrics())
	rmb.metricZookeeperZnodeCount.emit(sm.Metrics())
	if sm.Metrics().Len() == 0 {
		return false
	}
	rmb.updateCapacity(sm.Metrics())
	sm.Scope().SetName("otelcol/zookeeperreceiver")
	sm.Scope().SetVersion(rmb.buildInfo.Version)
	rm := m.ResourceMetrics().AppendEmpty()
	rmb.resource.CopyTo(rm.Resource())
	sm.MoveTo(rm.ScopeMetrics().AppendEmpty())
	return true
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit() pmetric.Metrics {
	m := pmetric.NewMetrics()
	for _, rmb := range mb.rmbMap {
		if ok := rmb.emit(m); !ok {
			rmb.missedEmits++
		}
	}
	for k, rmb := range mb.rmbMap {
		if rmb.missedEmits >= missedEmitsToDropRMB {
			delete(mb.rmbMap, k)
		}
	}
	return m
}

// RecordZookeeperConnectionActiveDataPoint adds a data point to zookeeper.connection.active metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperConnectionActiveDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperConnectionActive.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperDataTreeEphemeralNodeCountDataPoint adds a data point to zookeeper.data_tree.ephemeral_node.count metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperDataTreeEphemeralNodeCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperDataTreeEphemeralNodeCount.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperDataTreeSizeDataPoint adds a data point to zookeeper.data_tree.size metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperDataTreeSizeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperDataTreeSize.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperFileDescriptorLimitDataPoint adds a data point to zookeeper.file_descriptor.limit metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperFileDescriptorLimitDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperFileDescriptorLimit.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperFileDescriptorOpenDataPoint adds a data point to zookeeper.file_descriptor.open metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperFileDescriptorOpenDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperFileDescriptorOpen.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperFollowerCountDataPoint adds a data point to zookeeper.follower.count metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperFollowerCountDataPoint(ts pcommon.Timestamp, val int64, stateAttributeValue AttributeState) {
	rmb.metricZookeeperFollowerCount.recordDataPoint(rmb.startTime, ts, val, stateAttributeValue.String())
}

// RecordZookeeperFsyncExceededThresholdCountDataPoint adds a data point to zookeeper.fsync.exceeded_threshold.count metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperFsyncExceededThresholdCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperFsyncExceededThresholdCount.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperLatencyAvgDataPoint adds a data point to zookeeper.latency.avg metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperLatencyAvgDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperLatencyAvg.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperLatencyMaxDataPoint adds a data point to zookeeper.latency.max metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperLatencyMaxDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperLatencyMax.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperLatencyMinDataPoint adds a data point to zookeeper.latency.min metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperLatencyMinDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperLatencyMin.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperPacketCountDataPoint adds a data point to zookeeper.packet.count metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperPacketCountDataPoint(ts pcommon.Timestamp, val int64, directionAttributeValue AttributeDirection) {
	rmb.metricZookeeperPacketCount.recordDataPoint(rmb.startTime, ts, val, directionAttributeValue.String())
}

// RecordZookeeperRequestActiveDataPoint adds a data point to zookeeper.request.active metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperRequestActiveDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperRequestActive.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperRuokDataPoint adds a data point to zookeeper.ruok metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperRuokDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperRuok.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperSyncPendingDataPoint adds a data point to zookeeper.sync.pending metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperSyncPendingDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperSyncPending.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperWatchCountDataPoint adds a data point to zookeeper.watch.count metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperWatchCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperWatchCount.recordDataPoint(rmb.startTime, ts, val)
}

// RecordZookeeperZnodeCountDataPoint adds a data point to zookeeper.znode.count metric.
func (rmb *ResourceMetricsBuilder) RecordZookeeperZnodeCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricZookeeperZnodeCount.recordDataPoint(rmb.startTime, ts, val)
}

// Reset resets the ResourceMetricsBuilder to its initial state. It should be used when external metrics source is
// restarted, and the ResourceMetricsBuilder should update its startTime and reset it's internal state accordingly.
func (rmb *ResourceMetricsBuilder) Reset(options ...resourceMetricsBuilderOption) {
	rmb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(rmb)
	}
}
