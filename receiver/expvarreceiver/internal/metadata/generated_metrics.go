// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"

	"github.com/open-telemetry/opentelemetry-collector-contrib/pkg/pdatautil"
)

type metricProcessRuntimeMemstatsBuckHashSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.buck_hash_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsBuckHashSys) init() {
	m.data.SetName("process.runtime.memstats.buck_hash_sys")
	m.data.SetDescription("Bytes of memory in profiling bucket hash tables.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsBuckHashSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsBuckHashSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsBuckHashSys) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsBuckHashSys(cfg MetricConfig) metricProcessRuntimeMemstatsBuckHashSys {
	m := metricProcessRuntimeMemstatsBuckHashSys{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsFrees struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.frees metric with initial data.
func (m *metricProcessRuntimeMemstatsFrees) init() {
	m.data.SetName("process.runtime.memstats.frees")
	m.data.SetDescription("Cumulative count of heap objects freed.")
	m.data.SetUnit("{objects}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsFrees) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsFrees) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsFrees) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsFrees(cfg MetricConfig) metricProcessRuntimeMemstatsFrees {
	m := metricProcessRuntimeMemstatsFrees{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsGcCPUFraction struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.gc_cpu_fraction metric with initial data.
func (m *metricProcessRuntimeMemstatsGcCPUFraction) init() {
	m.data.SetName("process.runtime.memstats.gc_cpu_fraction")
	m.data.SetDescription("The fraction of this program's available CPU time used by the GC since the program started.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricProcessRuntimeMemstatsGcCPUFraction) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsGcCPUFraction) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsGcCPUFraction) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsGcCPUFraction(cfg MetricConfig) metricProcessRuntimeMemstatsGcCPUFraction {
	m := metricProcessRuntimeMemstatsGcCPUFraction{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsGcSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.gc_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsGcSys) init() {
	m.data.SetName("process.runtime.memstats.gc_sys")
	m.data.SetDescription("Bytes of memory in garbage collection metadata.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsGcSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsGcSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsGcSys) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsGcSys(cfg MetricConfig) metricProcessRuntimeMemstatsGcSys {
	m := metricProcessRuntimeMemstatsGcSys{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapAlloc struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_alloc metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapAlloc) init() {
	m.data.SetName("process.runtime.memstats.heap_alloc")
	m.data.SetDescription("Bytes of allocated heap objects.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapAlloc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapAlloc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapAlloc) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapAlloc(cfg MetricConfig) metricProcessRuntimeMemstatsHeapAlloc {
	m := metricProcessRuntimeMemstatsHeapAlloc{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapIdle struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_idle metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapIdle) init() {
	m.data.SetName("process.runtime.memstats.heap_idle")
	m.data.SetDescription("Bytes in idle (unused) spans.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapIdle) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapIdle) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapIdle) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapIdle(cfg MetricConfig) metricProcessRuntimeMemstatsHeapIdle {
	m := metricProcessRuntimeMemstatsHeapIdle{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapInuse struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_inuse metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapInuse) init() {
	m.data.SetName("process.runtime.memstats.heap_inuse")
	m.data.SetDescription("Bytes in in-use spans.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapInuse) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapInuse) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapInuse) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapInuse(cfg MetricConfig) metricProcessRuntimeMemstatsHeapInuse {
	m := metricProcessRuntimeMemstatsHeapInuse{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapObjects struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_objects metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapObjects) init() {
	m.data.SetName("process.runtime.memstats.heap_objects")
	m.data.SetDescription("Number of allocated heap objects.")
	m.data.SetUnit("{objects}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapObjects) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapObjects) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapObjects) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapObjects(cfg MetricConfig) metricProcessRuntimeMemstatsHeapObjects {
	m := metricProcessRuntimeMemstatsHeapObjects{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapReleased struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_released metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapReleased) init() {
	m.data.SetName("process.runtime.memstats.heap_released")
	m.data.SetDescription("Bytes of physical memory returned to the OS.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapReleased) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapReleased) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapReleased) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapReleased(cfg MetricConfig) metricProcessRuntimeMemstatsHeapReleased {
	m := metricProcessRuntimeMemstatsHeapReleased{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsHeapSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.heap_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsHeapSys) init() {
	m.data.SetName("process.runtime.memstats.heap_sys")
	m.data.SetDescription("Bytes of heap memory obtained by the OS.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsHeapSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsHeapSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsHeapSys) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsHeapSys(cfg MetricConfig) metricProcessRuntimeMemstatsHeapSys {
	m := metricProcessRuntimeMemstatsHeapSys{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsLastPause struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.last_pause metric with initial data.
func (m *metricProcessRuntimeMemstatsLastPause) init() {
	m.data.SetName("process.runtime.memstats.last_pause")
	m.data.SetDescription("The most recent stop-the-world pause time.")
	m.data.SetUnit("ns")
	m.data.SetEmptyGauge()
}

func (m *metricProcessRuntimeMemstatsLastPause) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsLastPause) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsLastPause) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsLastPause(cfg MetricConfig) metricProcessRuntimeMemstatsLastPause {
	m := metricProcessRuntimeMemstatsLastPause{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsLookups struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.lookups metric with initial data.
func (m *metricProcessRuntimeMemstatsLookups) init() {
	m.data.SetName("process.runtime.memstats.lookups")
	m.data.SetDescription("Number of pointer lookups performed by the runtime.")
	m.data.SetUnit("{lookups}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsLookups) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsLookups) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsLookups) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsLookups(cfg MetricConfig) metricProcessRuntimeMemstatsLookups {
	m := metricProcessRuntimeMemstatsLookups{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMallocs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mallocs metric with initial data.
func (m *metricProcessRuntimeMemstatsMallocs) init() {
	m.data.SetName("process.runtime.memstats.mallocs")
	m.data.SetDescription("Cumulative count of heap objects allocated.")
	m.data.SetUnit("{objects}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMallocs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMallocs) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMallocs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMallocs(cfg MetricConfig) metricProcessRuntimeMemstatsMallocs {
	m := metricProcessRuntimeMemstatsMallocs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMcacheInuse struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mcache_inuse metric with initial data.
func (m *metricProcessRuntimeMemstatsMcacheInuse) init() {
	m.data.SetName("process.runtime.memstats.mcache_inuse")
	m.data.SetDescription("Bytes of allocated mcache structures.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMcacheInuse) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMcacheInuse) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMcacheInuse) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMcacheInuse(cfg MetricConfig) metricProcessRuntimeMemstatsMcacheInuse {
	m := metricProcessRuntimeMemstatsMcacheInuse{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMcacheSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mcache_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsMcacheSys) init() {
	m.data.SetName("process.runtime.memstats.mcache_sys")
	m.data.SetDescription("Bytes of memory obtained from the OS for mcache structures.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMcacheSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMcacheSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMcacheSys) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMcacheSys(cfg MetricConfig) metricProcessRuntimeMemstatsMcacheSys {
	m := metricProcessRuntimeMemstatsMcacheSys{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMspanInuse struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mspan_inuse metric with initial data.
func (m *metricProcessRuntimeMemstatsMspanInuse) init() {
	m.data.SetName("process.runtime.memstats.mspan_inuse")
	m.data.SetDescription("Bytes of allocated mspan structures.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMspanInuse) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMspanInuse) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMspanInuse) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMspanInuse(cfg MetricConfig) metricProcessRuntimeMemstatsMspanInuse {
	m := metricProcessRuntimeMemstatsMspanInuse{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsMspanSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.mspan_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsMspanSys) init() {
	m.data.SetName("process.runtime.memstats.mspan_sys")
	m.data.SetDescription("Bytes of memory obtained from the OS for mspan structures.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsMspanSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsMspanSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsMspanSys) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsMspanSys(cfg MetricConfig) metricProcessRuntimeMemstatsMspanSys {
	m := metricProcessRuntimeMemstatsMspanSys{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsNextGc struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.next_gc metric with initial data.
func (m *metricProcessRuntimeMemstatsNextGc) init() {
	m.data.SetName("process.runtime.memstats.next_gc")
	m.data.SetDescription("The target heap size of the next GC cycle.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsNextGc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsNextGc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsNextGc) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsNextGc(cfg MetricConfig) metricProcessRuntimeMemstatsNextGc {
	m := metricProcessRuntimeMemstatsNextGc{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsNumForcedGc struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.num_forced_gc metric with initial data.
func (m *metricProcessRuntimeMemstatsNumForcedGc) init() {
	m.data.SetName("process.runtime.memstats.num_forced_gc")
	m.data.SetDescription("Number of GC cycles that were forced by the application calling the GC function.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsNumForcedGc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsNumForcedGc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsNumForcedGc) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsNumForcedGc(cfg MetricConfig) metricProcessRuntimeMemstatsNumForcedGc {
	m := metricProcessRuntimeMemstatsNumForcedGc{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsNumGc struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.num_gc metric with initial data.
func (m *metricProcessRuntimeMemstatsNumGc) init() {
	m.data.SetName("process.runtime.memstats.num_gc")
	m.data.SetDescription("Number of completed GC cycles.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsNumGc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsNumGc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsNumGc) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsNumGc(cfg MetricConfig) metricProcessRuntimeMemstatsNumGc {
	m := metricProcessRuntimeMemstatsNumGc{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsOtherSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.other_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsOtherSys) init() {
	m.data.SetName("process.runtime.memstats.other_sys")
	m.data.SetDescription("Bytes of memory in miscellaneous off-heap runtime allocations.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsOtherSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsOtherSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsOtherSys) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsOtherSys(cfg MetricConfig) metricProcessRuntimeMemstatsOtherSys {
	m := metricProcessRuntimeMemstatsOtherSys{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsPauseTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.pause_total metric with initial data.
func (m *metricProcessRuntimeMemstatsPauseTotal) init() {
	m.data.SetName("process.runtime.memstats.pause_total")
	m.data.SetDescription("The cumulative nanoseconds in GC stop-the-world pauses since the program started.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsPauseTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsPauseTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsPauseTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsPauseTotal(cfg MetricConfig) metricProcessRuntimeMemstatsPauseTotal {
	m := metricProcessRuntimeMemstatsPauseTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsStackInuse struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.stack_inuse metric with initial data.
func (m *metricProcessRuntimeMemstatsStackInuse) init() {
	m.data.SetName("process.runtime.memstats.stack_inuse")
	m.data.SetDescription("Bytes in stack spans.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsStackInuse) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsStackInuse) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsStackInuse) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsStackInuse(cfg MetricConfig) metricProcessRuntimeMemstatsStackInuse {
	m := metricProcessRuntimeMemstatsStackInuse{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsStackSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.stack_sys metric with initial data.
func (m *metricProcessRuntimeMemstatsStackSys) init() {
	m.data.SetName("process.runtime.memstats.stack_sys")
	m.data.SetDescription("Bytes of stack memory obtained from the OS.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsStackSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsStackSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsStackSys) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsStackSys(cfg MetricConfig) metricProcessRuntimeMemstatsStackSys {
	m := metricProcessRuntimeMemstatsStackSys{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsSys struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.sys metric with initial data.
func (m *metricProcessRuntimeMemstatsSys) init() {
	m.data.SetName("process.runtime.memstats.sys")
	m.data.SetDescription("Total bytes of memory obtained from the OS.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsSys) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsSys) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsSys) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsSys(cfg MetricConfig) metricProcessRuntimeMemstatsSys {
	m := metricProcessRuntimeMemstatsSys{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricProcessRuntimeMemstatsTotalAlloc struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills process.runtime.memstats.total_alloc metric with initial data.
func (m *metricProcessRuntimeMemstatsTotalAlloc) init() {
	m.data.SetName("process.runtime.memstats.total_alloc")
	m.data.SetDescription("Cumulative bytes allocated for heap objects.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricProcessRuntimeMemstatsTotalAlloc) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricProcessRuntimeMemstatsTotalAlloc) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricProcessRuntimeMemstatsTotalAlloc) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricProcessRuntimeMemstatsTotalAlloc(cfg MetricConfig) metricProcessRuntimeMemstatsTotalAlloc {
	m := metricProcessRuntimeMemstatsTotalAlloc{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// missedEmitsToDropRMB is number of missed emits after which resource builder will be dropped from MetricsBuilder.rmbMap.
// Potentially, this value can be made configurable through a MetricsBuilder option.
const missedEmitsToDropRMB = 5

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config    MetricsBuilderConfig                 // config of the metrics builder.
	buildInfo component.BuildInfo                  // contains version information
	startTime pcommon.Timestamp                    // start time that will be applied to all recorded data points.
	rmbMap    map[[16]byte]*ResourceMetricsBuilder // map of resource builders by resource hash.
}

type ResourceMetricsBuilder struct {
	buildInfo                                 component.BuildInfo
	startTime                                 pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                           int               // maximum observed number of metrics per resource.
	resource                                  pcommon.Resource
	missedEmits                               int
	metricProcessRuntimeMemstatsBuckHashSys   metricProcessRuntimeMemstatsBuckHashSys
	metricProcessRuntimeMemstatsFrees         metricProcessRuntimeMemstatsFrees
	metricProcessRuntimeMemstatsGcCPUFraction metricProcessRuntimeMemstatsGcCPUFraction
	metricProcessRuntimeMemstatsGcSys         metricProcessRuntimeMemstatsGcSys
	metricProcessRuntimeMemstatsHeapAlloc     metricProcessRuntimeMemstatsHeapAlloc
	metricProcessRuntimeMemstatsHeapIdle      metricProcessRuntimeMemstatsHeapIdle
	metricProcessRuntimeMemstatsHeapInuse     metricProcessRuntimeMemstatsHeapInuse
	metricProcessRuntimeMemstatsHeapObjects   metricProcessRuntimeMemstatsHeapObjects
	metricProcessRuntimeMemstatsHeapReleased  metricProcessRuntimeMemstatsHeapReleased
	metricProcessRuntimeMemstatsHeapSys       metricProcessRuntimeMemstatsHeapSys
	metricProcessRuntimeMemstatsLastPause     metricProcessRuntimeMemstatsLastPause
	metricProcessRuntimeMemstatsLookups       metricProcessRuntimeMemstatsLookups
	metricProcessRuntimeMemstatsMallocs       metricProcessRuntimeMemstatsMallocs
	metricProcessRuntimeMemstatsMcacheInuse   metricProcessRuntimeMemstatsMcacheInuse
	metricProcessRuntimeMemstatsMcacheSys     metricProcessRuntimeMemstatsMcacheSys
	metricProcessRuntimeMemstatsMspanInuse    metricProcessRuntimeMemstatsMspanInuse
	metricProcessRuntimeMemstatsMspanSys      metricProcessRuntimeMemstatsMspanSys
	metricProcessRuntimeMemstatsNextGc        metricProcessRuntimeMemstatsNextGc
	metricProcessRuntimeMemstatsNumForcedGc   metricProcessRuntimeMemstatsNumForcedGc
	metricProcessRuntimeMemstatsNumGc         metricProcessRuntimeMemstatsNumGc
	metricProcessRuntimeMemstatsOtherSys      metricProcessRuntimeMemstatsOtherSys
	metricProcessRuntimeMemstatsPauseTotal    metricProcessRuntimeMemstatsPauseTotal
	metricProcessRuntimeMemstatsStackInuse    metricProcessRuntimeMemstatsStackInuse
	metricProcessRuntimeMemstatsStackSys      metricProcessRuntimeMemstatsStackSys
	metricProcessRuntimeMemstatsSys           metricProcessRuntimeMemstatsSys
	metricProcessRuntimeMemstatsTotalAlloc    metricProcessRuntimeMemstatsTotalAlloc
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:    mbc,
		startTime: pcommon.NewTimestampFromTime(time.Now()),
		buildInfo: settings.BuildInfo,
		rmbMap:    make(map[[16]byte]*ResourceMetricsBuilder),
	}
	for _, opt := range options {
		opt(mb)
	}
	return mb
}

// resourceMetricsBuilderOption applies changes to provided resource metrics.
type resourceMetricsBuilderOption func(*ResourceMetricsBuilder)

// WithStartTimeOverride sets start time for all the resource metrics data points.
func WithStartTimeOverride(start pcommon.Timestamp) resourceMetricsBuilderOption {
	return func(rmb *ResourceMetricsBuilder) {
		rmb.startTime = start
	}
}

// ResourceMetricsBuilder returns a ResourceMetricsBuilder that can be used to record metrics for a specific resource.
// It requires Resource to be provided which should be built with ResourceBuilder.
func (mb *MetricsBuilder) ResourceMetricsBuilder(res pcommon.Resource, options ...resourceMetricsBuilderOption) *ResourceMetricsBuilder {
	hash := pdatautil.MapHash(res.Attributes())
	if rmb, ok := mb.rmbMap[hash]; ok {
		return rmb
	}
	rmb := &ResourceMetricsBuilder{
		startTime:                               mb.startTime,
		buildInfo:                               mb.buildInfo,
		resource:                                res,
		metricProcessRuntimeMemstatsBuckHashSys: newMetricProcessRuntimeMemstatsBuckHashSys(mb.config.Metrics.ProcessRuntimeMemstatsBuckHashSys),
		metricProcessRuntimeMemstatsFrees:       newMetricProcessRuntimeMemstatsFrees(mb.config.Metrics.ProcessRuntimeMemstatsFrees),
		metricProcessRuntimeMemstatsGcCPUFraction: newMetricProcessRuntimeMemstatsGcCPUFraction(mb.config.Metrics.ProcessRuntimeMemstatsGcCPUFraction),
		metricProcessRuntimeMemstatsGcSys:         newMetricProcessRuntimeMemstatsGcSys(mb.config.Metrics.ProcessRuntimeMemstatsGcSys),
		metricProcessRuntimeMemstatsHeapAlloc:     newMetricProcessRuntimeMemstatsHeapAlloc(mb.config.Metrics.ProcessRuntimeMemstatsHeapAlloc),
		metricProcessRuntimeMemstatsHeapIdle:      newMetricProcessRuntimeMemstatsHeapIdle(mb.config.Metrics.ProcessRuntimeMemstatsHeapIdle),
		metricProcessRuntimeMemstatsHeapInuse:     newMetricProcessRuntimeMemstatsHeapInuse(mb.config.Metrics.ProcessRuntimeMemstatsHeapInuse),
		metricProcessRuntimeMemstatsHeapObjects:   newMetricProcessRuntimeMemstatsHeapObjects(mb.config.Metrics.ProcessRuntimeMemstatsHeapObjects),
		metricProcessRuntimeMemstatsHeapReleased:  newMetricProcessRuntimeMemstatsHeapReleased(mb.config.Metrics.ProcessRuntimeMemstatsHeapReleased),
		metricProcessRuntimeMemstatsHeapSys:       newMetricProcessRuntimeMemstatsHeapSys(mb.config.Metrics.ProcessRuntimeMemstatsHeapSys),
		metricProcessRuntimeMemstatsLastPause:     newMetricProcessRuntimeMemstatsLastPause(mb.config.Metrics.ProcessRuntimeMemstatsLastPause),
		metricProcessRuntimeMemstatsLookups:       newMetricProcessRuntimeMemstatsLookups(mb.config.Metrics.ProcessRuntimeMemstatsLookups),
		metricProcessRuntimeMemstatsMallocs:       newMetricProcessRuntimeMemstatsMallocs(mb.config.Metrics.ProcessRuntimeMemstatsMallocs),
		metricProcessRuntimeMemstatsMcacheInuse:   newMetricProcessRuntimeMemstatsMcacheInuse(mb.config.Metrics.ProcessRuntimeMemstatsMcacheInuse),
		metricProcessRuntimeMemstatsMcacheSys:     newMetricProcessRuntimeMemstatsMcacheSys(mb.config.Metrics.ProcessRuntimeMemstatsMcacheSys),
		metricProcessRuntimeMemstatsMspanInuse:    newMetricProcessRuntimeMemstatsMspanInuse(mb.config.Metrics.ProcessRuntimeMemstatsMspanInuse),
		metricProcessRuntimeMemstatsMspanSys:      newMetricProcessRuntimeMemstatsMspanSys(mb.config.Metrics.ProcessRuntimeMemstatsMspanSys),
		metricProcessRuntimeMemstatsNextGc:        newMetricProcessRuntimeMemstatsNextGc(mb.config.Metrics.ProcessRuntimeMemstatsNextGc),
		metricProcessRuntimeMemstatsNumForcedGc:   newMetricProcessRuntimeMemstatsNumForcedGc(mb.config.Metrics.ProcessRuntimeMemstatsNumForcedGc),
		metricProcessRuntimeMemstatsNumGc:         newMetricProcessRuntimeMemstatsNumGc(mb.config.Metrics.ProcessRuntimeMemstatsNumGc),
		metricProcessRuntimeMemstatsOtherSys:      newMetricProcessRuntimeMemstatsOtherSys(mb.config.Metrics.ProcessRuntimeMemstatsOtherSys),
		metricProcessRuntimeMemstatsPauseTotal:    newMetricProcessRuntimeMemstatsPauseTotal(mb.config.Metrics.ProcessRuntimeMemstatsPauseTotal),
		metricProcessRuntimeMemstatsStackInuse:    newMetricProcessRuntimeMemstatsStackInuse(mb.config.Metrics.ProcessRuntimeMemstatsStackInuse),
		metricProcessRuntimeMemstatsStackSys:      newMetricProcessRuntimeMemstatsStackSys(mb.config.Metrics.ProcessRuntimeMemstatsStackSys),
		metricProcessRuntimeMemstatsSys:           newMetricProcessRuntimeMemstatsSys(mb.config.Metrics.ProcessRuntimeMemstatsSys),
		metricProcessRuntimeMemstatsTotalAlloc:    newMetricProcessRuntimeMemstatsTotalAlloc(mb.config.Metrics.ProcessRuntimeMemstatsTotalAlloc),
	}
	for _, op := range options {
		op(rmb)
	}
	mb.rmbMap[hash] = rmb
	return rmb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (rmb *ResourceMetricsBuilder) updateCapacity(ms pmetric.MetricSlice) {
	if rmb.metricsCapacity < ms.Len() {
		rmb.metricsCapacity = ms.Len()
	}
}

// emit emits all the metrics accumulated by the ResourceMetricsBuilder and updates the internal state to be ready for
// recording another set of metrics. It returns true if any metrics were emitted.
func (rmb *ResourceMetricsBuilder) emit(m pmetric.Metrics) bool {
	sm := pmetric.NewScopeMetrics()
	sm.Metrics().EnsureCapacity(rmb.metricsCapacity)
	rmb.metricProcessRuntimeMemstatsBuckHashSys.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsFrees.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsGcCPUFraction.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsGcSys.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsHeapAlloc.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsHeapIdle.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsHeapInuse.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsHeapObjects.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsHeapReleased.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsHeapSys.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsLastPause.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsLookups.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsMallocs.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsMcacheInuse.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsMcacheSys.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsMspanInuse.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsMspanSys.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsNextGc.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsNumForcedGc.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsNumGc.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsOtherSys.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsPauseTotal.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsStackInuse.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsStackSys.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsSys.emit(sm.Metrics())
	rmb.metricProcessRuntimeMemstatsTotalAlloc.emit(sm.Metrics())
	if sm.Metrics().Len() == 0 {
		return false
	}
	rmb.updateCapacity(sm.Metrics())
	sm.Scope().SetName("otelcol/expvarreceiver")
	sm.Scope().SetVersion(rmb.buildInfo.Version)
	rm := m.ResourceMetrics().AppendEmpty()
	rmb.resource.CopyTo(rm.Resource())
	sm.MoveTo(rm.ScopeMetrics().AppendEmpty())
	return true
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit() pmetric.Metrics {
	m := pmetric.NewMetrics()
	for _, rmb := range mb.rmbMap {
		if ok := rmb.emit(m); !ok {
			rmb.missedEmits++
		}
	}
	for k, rmb := range mb.rmbMap {
		if rmb.missedEmits >= missedEmitsToDropRMB {
			delete(mb.rmbMap, k)
		}
	}
	return m
}

// RecordProcessRuntimeMemstatsBuckHashSysDataPoint adds a data point to process.runtime.memstats.buck_hash_sys metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsBuckHashSysDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsBuckHashSys.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsFreesDataPoint adds a data point to process.runtime.memstats.frees metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsFreesDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsFrees.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsGcCPUFractionDataPoint adds a data point to process.runtime.memstats.gc_cpu_fraction metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsGcCPUFractionDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricProcessRuntimeMemstatsGcCPUFraction.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsGcSysDataPoint adds a data point to process.runtime.memstats.gc_sys metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsGcSysDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsGcSys.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapAllocDataPoint adds a data point to process.runtime.memstats.heap_alloc metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsHeapAllocDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsHeapAlloc.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapIdleDataPoint adds a data point to process.runtime.memstats.heap_idle metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsHeapIdleDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsHeapIdle.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapInuseDataPoint adds a data point to process.runtime.memstats.heap_inuse metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsHeapInuseDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsHeapInuse.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapObjectsDataPoint adds a data point to process.runtime.memstats.heap_objects metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsHeapObjectsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsHeapObjects.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapReleasedDataPoint adds a data point to process.runtime.memstats.heap_released metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsHeapReleasedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsHeapReleased.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsHeapSysDataPoint adds a data point to process.runtime.memstats.heap_sys metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsHeapSysDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsHeapSys.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsLastPauseDataPoint adds a data point to process.runtime.memstats.last_pause metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsLastPauseDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsLastPause.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsLookupsDataPoint adds a data point to process.runtime.memstats.lookups metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsLookupsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsLookups.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMallocsDataPoint adds a data point to process.runtime.memstats.mallocs metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsMallocsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsMallocs.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMcacheInuseDataPoint adds a data point to process.runtime.memstats.mcache_inuse metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsMcacheInuseDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsMcacheInuse.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMcacheSysDataPoint adds a data point to process.runtime.memstats.mcache_sys metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsMcacheSysDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsMcacheSys.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMspanInuseDataPoint adds a data point to process.runtime.memstats.mspan_inuse metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsMspanInuseDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsMspanInuse.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsMspanSysDataPoint adds a data point to process.runtime.memstats.mspan_sys metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsMspanSysDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsMspanSys.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsNextGcDataPoint adds a data point to process.runtime.memstats.next_gc metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsNextGcDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsNextGc.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsNumForcedGcDataPoint adds a data point to process.runtime.memstats.num_forced_gc metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsNumForcedGcDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsNumForcedGc.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsNumGcDataPoint adds a data point to process.runtime.memstats.num_gc metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsNumGcDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsNumGc.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsOtherSysDataPoint adds a data point to process.runtime.memstats.other_sys metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsOtherSysDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsOtherSys.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsPauseTotalDataPoint adds a data point to process.runtime.memstats.pause_total metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsPauseTotalDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsPauseTotal.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsStackInuseDataPoint adds a data point to process.runtime.memstats.stack_inuse metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsStackInuseDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsStackInuse.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsStackSysDataPoint adds a data point to process.runtime.memstats.stack_sys metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsStackSysDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsStackSys.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsSysDataPoint adds a data point to process.runtime.memstats.sys metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsSysDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsSys.recordDataPoint(rmb.startTime, ts, val)
}

// RecordProcessRuntimeMemstatsTotalAllocDataPoint adds a data point to process.runtime.memstats.total_alloc metric.
func (rmb *ResourceMetricsBuilder) RecordProcessRuntimeMemstatsTotalAllocDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricProcessRuntimeMemstatsTotalAlloc.recordDataPoint(rmb.startTime, ts, val)
}

// Reset resets the ResourceMetricsBuilder to its initial state. It should be used when external metrics source is
// restarted, and the ResourceMetricsBuilder should update its startTime and reset it's internal state accordingly.
func (rmb *ResourceMetricsBuilder) Reset(options ...resourceMetricsBuilderOption) {
	rmb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(rmb)
	}
}
