// Copyright The OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"go.opentelemetry.io/collector/config"
	"go.opentelemetry.io/collector/model/pdata"
)

// Type is the component type name.
const Type config.Type = "cpu"

// DataPoint represents a data structure for pdata.DataPoint creation
type DataPoint struct {
	StartTimestamp pdata.Timestamp
	Timestamp      pdata.Timestamp
	AttributeCpu   string
	AttributeState string
	// We probably can have number type (int64 vs float64) defined in metadata, and keep only one field for Number value
	IntVal    *int64
	DoubleVal *float64
	// To be generated for SummaryDataPoint and ExponentialHistogramDataPoint data types
	// ValueCount int64
	// ValueSum float64
	// ...
	Exemplars pdata.ExemplarSlice
	Flags     pdata.MetricDataPointFlags
}

// MetricTemplate represents a template for pdata.Metric creation based on metadata and user configuration
type MetricTemplate interface {
	EnsureDataPointsCapacity(int)
	AddDatapoint(DataPoint)
	AppendToMetricSlice(pdata.MetricSlice)
}

type metricTemplate struct {
	mb             metricBuilder
	metric         pdata.Metric
	startTimestamp pdata.Timestamp
	timestamp      pdata.Timestamp
}

func (mt metricTemplate) EnsureDataPointsCapacity(cap int) {
	if !mt.mb.Enabled() {
		return
	}
	mt.metric.Sum().DataPoints().EnsureCapacity(cap)
	// For other types:
	// mt.metric.Gauge().DataPoints().EnsureCapacity(cap)
	// mt.metric.Histogram().DataPoints().EnsureCapacity(cap)
	// mt.metric.Summary().DataPoints().EnsureCapacity(cap)
}

// AddDatapoint
func (mt metricTemplate) AddDatapoint(data DataPoint) {
	if !mt.mb.Enabled() {
		return
	}

	dp := mt.metric.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(data.StartTimestamp)
	dp.SetTimestamp(data.Timestamp)
	if data.AttributeCpu != "" {
		dp.Attributes().UpsertString(L.Cpu, data.AttributeCpu)
	}
	if data.AttributeState != "" {
		dp.Attributes().UpsertString(L.State, data.AttributeState)
	}
	if data.IntVal != nil {
		dp.SetIntVal(*data.IntVal)
	}
	if data.DoubleVal != nil {
		dp.SetDoubleVal(*data.DoubleVal)
	}
	data.Exemplars.CopyTo(dp.Exemplars())
	dp.SetFlags(data.Flags)
}

func (mt metricTemplate) AppendToMetricSlice(metrics pdata.MetricSlice) {
	if !mt.mb.Enabled() {
		return
	}
	mt.metric.CopyTo(metrics.AppendEmpty())
}

var _ MetricTemplate = (*metricTemplate)(nil)

// MetricBuilder is an interface to generate metric.
type MetricBuilder interface {
	Name() string
	Enabled() bool
	Description() string
	Unit() string
	DataType() pdata.MetricDataType
	IsMonotonic() bool
	Temporality() pdata.MetricAggregationTemporality
	InitMetricTemplate() MetricTemplate
}

type metricBuilder struct {
	name        string
	enabled     bool
	description string
	unit        string
	dataType    pdata.MetricDataType
	isMonotonic bool
	temporality pdata.MetricAggregationTemporality

	config MetricConfig
}

// Name returns the metric name.
func (mb metricBuilder) Name() string {
	return mb.name
}

// Enabled identifies whether the metrics should be collected or not
func (mb metricBuilder) Enabled() bool {
	if mb.config.Enabled != nil {
		return *mb.config.Enabled
	}
	return mb.enabled
}

// Description identifies whether the metrics should be collected or not
func (mb metricBuilder) Description() string {
	return mb.description
}

// Unit
func (mb metricBuilder) Unit() string {
	return mb.unit
}

// DataType
func (mb metricBuilder) DataType() pdata.MetricDataType {
	return mb.dataType
}

// IsMonotonic
func (mb metricBuilder) IsMonotonic() bool {
	return mb.isMonotonic
}

// Temporality
func (mb metricBuilder) Temporality() pdata.MetricAggregationTemporality {
	return mb.temporality
}

// InitMetricTemplate generates a metric template
func (mb metricBuilder) InitMetricTemplate() MetricTemplate {
	mt := metricTemplate{mb: mb}
	if mb.Enabled() {
		metric := pdata.NewMetric()
		metric.SetName(mb.Name())
		metric.SetDescription(mb.Description())
		metric.SetUnit(mb.Unit())
		metric.SetDataType(mb.DataType())
		metric.Sum().SetIsMonotonic(mb.IsMonotonic())
		metric.Sum().SetAggregationTemporality(mb.Temporality())
		mt.metric = metric
	}

	return mt
}

var _ MetricBuilder = (*metricBuilder)(nil)

type MetricsBuilder struct {
	SystemCPUTime MetricBuilder
}

// ByName returns a map of all the metric builders by metric name.
func (mb *MetricsBuilder) ByName() map[string]MetricBuilder {
	return map[string]MetricBuilder{
		"system.cpu.time": mb.SystemCPUTime,
	}
}

// NewMetricsBuilder returns helpers for building metrics based on defined metadata
func NewMetricsBuilder(mc MetricsConfig) MetricsBuilder {
	return MetricsBuilder{
		metricBuilder{
			name:        "system.cpu.time",
			enabled:     true,
			description: "Total CPU seconds broken down by different states.",
			unit:        "s",
			dataType:    pdata.MetricDataTypeSum,
			isMonotonic: true,
			temporality: pdata.MetricAggregationTemporalityCumulative,
			config:      mc.SystemCPUTime,
		},
	}
}

// Labels contains the possible metric labels that can be used.
var Labels = struct {
	// Cpu (CPU number starting at 0.)
	Cpu string
	// State (Breakdown of CPU usage by type.)
	State string
}{
	"cpu",
	"state",
}

// L contains the possible metric labels that can be used. L is an alias for
// Labels.
var L = Labels

// LabelState are the possible values that the label "state" can have.
var LabelState = struct {
	Idle      string
	Interrupt string
	Nice      string
	Softirq   string
	Steal     string
	System    string
	User      string
	Wait      string
}{
	"idle",
	"interrupt",
	"nice",
	"softirq",
	"steal",
	"system",
	"user",
	"wait",
}
