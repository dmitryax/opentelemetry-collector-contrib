// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"

	"github.com/open-telemetry/opentelemetry-collector-contrib/pkg/pdatautil"
)

// AttributeDirection specifies the a value direction attribute.
type AttributeDirection int

const (
	_ AttributeDirection = iota
	AttributeDirectionReceive
	AttributeDirectionTransmit
)

// String returns the string representation of the AttributeDirection.
func (av AttributeDirection) String() string {
	switch av {
	case AttributeDirectionReceive:
		return "receive"
	case AttributeDirectionTransmit:
		return "transmit"
	}
	return ""
}

// MapAttributeDirection is a helper map of string to AttributeDirection attribute value.
var MapAttributeDirection = map[string]AttributeDirection{
	"receive":  AttributeDirectionReceive,
	"transmit": AttributeDirectionTransmit,
}

type metricContainerCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.cpu.time metric with initial data.
func (m *metricContainerCPUTime) init() {
	m.data.SetName("container.cpu.time")
	m.data.SetDescription("Container CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricContainerCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerCPUTime(cfg MetricConfig) metricContainerCPUTime {
	m := metricContainerCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.cpu.utilization metric with initial data.
func (m *metricContainerCPUUtilization) init() {
	m.data.SetName("container.cpu.utilization")
	m.data.SetDescription("Container CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerCPUUtilization(cfg MetricConfig) metricContainerCPUUtilization {
	m := metricContainerCPUUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.available metric with initial data.
func (m *metricContainerFilesystemAvailable) init() {
	m.data.SetName("container.filesystem.available")
	m.data.SetDescription("Container filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemAvailable(cfg MetricConfig) metricContainerFilesystemAvailable {
	m := metricContainerFilesystemAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.capacity metric with initial data.
func (m *metricContainerFilesystemCapacity) init() {
	m.data.SetName("container.filesystem.capacity")
	m.data.SetDescription("Container filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemCapacity(cfg MetricConfig) metricContainerFilesystemCapacity {
	m := metricContainerFilesystemCapacity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.filesystem.usage metric with initial data.
func (m *metricContainerFilesystemUsage) init() {
	m.data.SetName("container.filesystem.usage")
	m.data.SetDescription("Container filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerFilesystemUsage(cfg MetricConfig) metricContainerFilesystemUsage {
	m := metricContainerFilesystemUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.available metric with initial data.
func (m *metricContainerMemoryAvailable) init() {
	m.data.SetName("container.memory.available")
	m.data.SetDescription("Container memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryAvailable(cfg MetricConfig) metricContainerMemoryAvailable {
	m := metricContainerMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.major_page_faults metric with initial data.
func (m *metricContainerMemoryMajorPageFaults) init() {
	m.data.SetName("container.memory.major_page_faults")
	m.data.SetDescription("Container memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryMajorPageFaults(cfg MetricConfig) metricContainerMemoryMajorPageFaults {
	m := metricContainerMemoryMajorPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.page_faults metric with initial data.
func (m *metricContainerMemoryPageFaults) init() {
	m.data.SetName("container.memory.page_faults")
	m.data.SetDescription("Container memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryPageFaults(cfg MetricConfig) metricContainerMemoryPageFaults {
	m := metricContainerMemoryPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.rss metric with initial data.
func (m *metricContainerMemoryRss) init() {
	m.data.SetName("container.memory.rss")
	m.data.SetDescription("Container memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryRss(cfg MetricConfig) metricContainerMemoryRss {
	m := metricContainerMemoryRss{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.usage metric with initial data.
func (m *metricContainerMemoryUsage) init() {
	m.data.SetName("container.memory.usage")
	m.data.SetDescription("Container memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryUsage(cfg MetricConfig) metricContainerMemoryUsage {
	m := metricContainerMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContainerMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills container.memory.working_set metric with initial data.
func (m *metricContainerMemoryWorkingSet) init() {
	m.data.SetName("container.memory.working_set")
	m.data.SetDescription("Container memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricContainerMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContainerMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContainerMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContainerMemoryWorkingSet(cfg MetricConfig) metricContainerMemoryWorkingSet {
	m := metricContainerMemoryWorkingSet{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.cpu.time metric with initial data.
func (m *metricK8sNodeCPUTime) init() {
	m.data.SetName("k8s.node.cpu.time")
	m.data.SetDescription("Node CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sNodeCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeCPUTime(cfg MetricConfig) metricK8sNodeCPUTime {
	m := metricK8sNodeCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.cpu.utilization metric with initial data.
func (m *metricK8sNodeCPUUtilization) init() {
	m.data.SetName("k8s.node.cpu.utilization")
	m.data.SetDescription("Node CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeCPUUtilization(cfg MetricConfig) metricK8sNodeCPUUtilization {
	m := metricK8sNodeCPUUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.available metric with initial data.
func (m *metricK8sNodeFilesystemAvailable) init() {
	m.data.SetName("k8s.node.filesystem.available")
	m.data.SetDescription("Node filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemAvailable(cfg MetricConfig) metricK8sNodeFilesystemAvailable {
	m := metricK8sNodeFilesystemAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.capacity metric with initial data.
func (m *metricK8sNodeFilesystemCapacity) init() {
	m.data.SetName("k8s.node.filesystem.capacity")
	m.data.SetDescription("Node filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemCapacity(cfg MetricConfig) metricK8sNodeFilesystemCapacity {
	m := metricK8sNodeFilesystemCapacity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.filesystem.usage metric with initial data.
func (m *metricK8sNodeFilesystemUsage) init() {
	m.data.SetName("k8s.node.filesystem.usage")
	m.data.SetDescription("Node filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeFilesystemUsage(cfg MetricConfig) metricK8sNodeFilesystemUsage {
	m := metricK8sNodeFilesystemUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.available metric with initial data.
func (m *metricK8sNodeMemoryAvailable) init() {
	m.data.SetName("k8s.node.memory.available")
	m.data.SetDescription("Node memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryAvailable(cfg MetricConfig) metricK8sNodeMemoryAvailable {
	m := metricK8sNodeMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.major_page_faults metric with initial data.
func (m *metricK8sNodeMemoryMajorPageFaults) init() {
	m.data.SetName("k8s.node.memory.major_page_faults")
	m.data.SetDescription("Node memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryMajorPageFaults(cfg MetricConfig) metricK8sNodeMemoryMajorPageFaults {
	m := metricK8sNodeMemoryMajorPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.page_faults metric with initial data.
func (m *metricK8sNodeMemoryPageFaults) init() {
	m.data.SetName("k8s.node.memory.page_faults")
	m.data.SetDescription("Node memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryPageFaults(cfg MetricConfig) metricK8sNodeMemoryPageFaults {
	m := metricK8sNodeMemoryPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.rss metric with initial data.
func (m *metricK8sNodeMemoryRss) init() {
	m.data.SetName("k8s.node.memory.rss")
	m.data.SetDescription("Node memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryRss(cfg MetricConfig) metricK8sNodeMemoryRss {
	m := metricK8sNodeMemoryRss{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.usage metric with initial data.
func (m *metricK8sNodeMemoryUsage) init() {
	m.data.SetName("k8s.node.memory.usage")
	m.data.SetDescription("Node memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryUsage(cfg MetricConfig) metricK8sNodeMemoryUsage {
	m := metricK8sNodeMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.memory.working_set metric with initial data.
func (m *metricK8sNodeMemoryWorkingSet) init() {
	m.data.SetName("k8s.node.memory.working_set")
	m.data.SetDescription("Node memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNodeMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeMemoryWorkingSet(cfg MetricConfig) metricK8sNodeMemoryWorkingSet {
	m := metricK8sNodeMemoryWorkingSet{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeNetworkErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.network.errors metric with initial data.
func (m *metricK8sNodeNetworkErrors) init() {
	m.data.SetName("k8s.node.network.errors")
	m.data.SetDescription("Node network errors")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sNodeNetworkErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeNetworkErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeNetworkErrors(cfg MetricConfig) metricK8sNodeNetworkErrors {
	m := metricK8sNodeNetworkErrors{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNodeNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.node.network.io metric with initial data.
func (m *metricK8sNodeNetworkIo) init() {
	m.data.SetName("k8s.node.network.io")
	m.data.SetDescription("Node network IO")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sNodeNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNodeNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNodeNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNodeNetworkIo(cfg MetricConfig) metricK8sNodeNetworkIo {
	m := metricK8sNodeNetworkIo{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu.time metric with initial data.
func (m *metricK8sPodCPUTime) init() {
	m.data.SetName("k8s.pod.cpu.time")
	m.data.SetDescription("Pod CPU time")
	m.data.SetUnit("s")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricK8sPodCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPUTime(cfg MetricConfig) metricK8sPodCPUTime {
	m := metricK8sPodCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodCPUUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.cpu.utilization metric with initial data.
func (m *metricK8sPodCPUUtilization) init() {
	m.data.SetName("k8s.pod.cpu.utilization")
	m.data.SetDescription("Pod CPU utilization")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodCPUUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodCPUUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodCPUUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodCPUUtilization(cfg MetricConfig) metricK8sPodCPUUtilization {
	m := metricK8sPodCPUUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.available metric with initial data.
func (m *metricK8sPodFilesystemAvailable) init() {
	m.data.SetName("k8s.pod.filesystem.available")
	m.data.SetDescription("Pod filesystem available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemAvailable(cfg MetricConfig) metricK8sPodFilesystemAvailable {
	m := metricK8sPodFilesystemAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.capacity metric with initial data.
func (m *metricK8sPodFilesystemCapacity) init() {
	m.data.SetName("k8s.pod.filesystem.capacity")
	m.data.SetDescription("Pod filesystem capacity")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemCapacity(cfg MetricConfig) metricK8sPodFilesystemCapacity {
	m := metricK8sPodFilesystemCapacity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodFilesystemUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.filesystem.usage metric with initial data.
func (m *metricK8sPodFilesystemUsage) init() {
	m.data.SetName("k8s.pod.filesystem.usage")
	m.data.SetDescription("Pod filesystem usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodFilesystemUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodFilesystemUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodFilesystemUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodFilesystemUsage(cfg MetricConfig) metricK8sPodFilesystemUsage {
	m := metricK8sPodFilesystemUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.available metric with initial data.
func (m *metricK8sPodMemoryAvailable) init() {
	m.data.SetName("k8s.pod.memory.available")
	m.data.SetDescription("Pod memory available")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryAvailable(cfg MetricConfig) metricK8sPodMemoryAvailable {
	m := metricK8sPodMemoryAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryMajorPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.major_page_faults metric with initial data.
func (m *metricK8sPodMemoryMajorPageFaults) init() {
	m.data.SetName("k8s.pod.memory.major_page_faults")
	m.data.SetDescription("Pod memory major_page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryMajorPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryMajorPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryMajorPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryMajorPageFaults(cfg MetricConfig) metricK8sPodMemoryMajorPageFaults {
	m := metricK8sPodMemoryMajorPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryPageFaults struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.page_faults metric with initial data.
func (m *metricK8sPodMemoryPageFaults) init() {
	m.data.SetName("k8s.pod.memory.page_faults")
	m.data.SetDescription("Pod memory page_faults")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryPageFaults) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryPageFaults) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryPageFaults) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryPageFaults(cfg MetricConfig) metricK8sPodMemoryPageFaults {
	m := metricK8sPodMemoryPageFaults{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryRss struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.rss metric with initial data.
func (m *metricK8sPodMemoryRss) init() {
	m.data.SetName("k8s.pod.memory.rss")
	m.data.SetDescription("Pod memory rss")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryRss) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryRss) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryRss) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryRss(cfg MetricConfig) metricK8sPodMemoryRss {
	m := metricK8sPodMemoryRss{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.usage metric with initial data.
func (m *metricK8sPodMemoryUsage) init() {
	m.data.SetName("k8s.pod.memory.usage")
	m.data.SetDescription("Pod memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryUsage(cfg MetricConfig) metricK8sPodMemoryUsage {
	m := metricK8sPodMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodMemoryWorkingSet struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.memory.working_set metric with initial data.
func (m *metricK8sPodMemoryWorkingSet) init() {
	m.data.SetName("k8s.pod.memory.working_set")
	m.data.SetDescription("Pod memory working_set")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodMemoryWorkingSet) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodMemoryWorkingSet) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodMemoryWorkingSet) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodMemoryWorkingSet(cfg MetricConfig) metricK8sPodMemoryWorkingSet {
	m := metricK8sPodMemoryWorkingSet{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodNetworkErrors struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.network.errors metric with initial data.
func (m *metricK8sPodNetworkErrors) init() {
	m.data.SetName("k8s.pod.network.errors")
	m.data.SetDescription("Pod network errors")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sPodNetworkErrors) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodNetworkErrors) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodNetworkErrors) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodNetworkErrors(cfg MetricConfig) metricK8sPodNetworkErrors {
	m := metricK8sPodNetworkErrors{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.network.io metric with initial data.
func (m *metricK8sPodNetworkIo) init() {
	m.data.SetName("k8s.pod.network.io")
	m.data.SetDescription("Pod network IO")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sPodNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("interface", interfaceAttributeValue)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodNetworkIo(cfg MetricConfig) metricK8sPodNetworkIo {
	m := metricK8sPodNetworkIo{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.available metric with initial data.
func (m *metricK8sVolumeAvailable) init() {
	m.data.SetName("k8s.volume.available")
	m.data.SetDescription("The number of available bytes in the volume.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeAvailable(cfg MetricConfig) metricK8sVolumeAvailable {
	m := metricK8sVolumeAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeCapacity struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.capacity metric with initial data.
func (m *metricK8sVolumeCapacity) init() {
	m.data.SetName("k8s.volume.capacity")
	m.data.SetDescription("The total capacity in bytes of the volume.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeCapacity) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeCapacity) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeCapacity) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeCapacity(cfg MetricConfig) metricK8sVolumeCapacity {
	m := metricK8sVolumeCapacity{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes metric with initial data.
func (m *metricK8sVolumeInodes) init() {
	m.data.SetName("k8s.volume.inodes")
	m.data.SetDescription("The total inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodes(cfg MetricConfig) metricK8sVolumeInodes {
	m := metricK8sVolumeInodes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodesFree struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes.free metric with initial data.
func (m *metricK8sVolumeInodesFree) init() {
	m.data.SetName("k8s.volume.inodes.free")
	m.data.SetDescription("The free inodes in the filesystem.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodesFree) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodesFree) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodesFree) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodesFree(cfg MetricConfig) metricK8sVolumeInodesFree {
	m := metricK8sVolumeInodesFree{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sVolumeInodesUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.volume.inodes.used metric with initial data.
func (m *metricK8sVolumeInodesUsed) init() {
	m.data.SetName("k8s.volume.inodes.used")
	m.data.SetDescription("The inodes used by the filesystem. This may not equal inodes - free because filesystem may share inodes with other filesystems.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sVolumeInodesUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sVolumeInodesUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sVolumeInodesUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sVolumeInodesUsed(cfg MetricConfig) metricK8sVolumeInodesUsed {
	m := metricK8sVolumeInodesUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// missedEmitsToDropRMB is number of missed emits after which resource builder will be dropped from MetricsBuilder.rmbMap.
// Potentially, this value can be made configurable through a MetricsBuilder option.
const missedEmitsToDropRMB = 5

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config    MetricsBuilderConfig                 // config of the metrics builder.
	buildInfo component.BuildInfo                  // contains version information
	startTime pcommon.Timestamp                    // start time that will be applied to all recorded data points.
	rmbMap    map[[16]byte]*ResourceMetricsBuilder // map of resource builders by resource hash.
}

type ResourceMetricsBuilder struct {
	buildInfo                            component.BuildInfo
	startTime                            pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                      int               // maximum observed number of metrics per resource.
	resource                             pcommon.Resource
	missedEmits                          int
	metricContainerCPUTime               metricContainerCPUTime
	metricContainerCPUUtilization        metricContainerCPUUtilization
	metricContainerFilesystemAvailable   metricContainerFilesystemAvailable
	metricContainerFilesystemCapacity    metricContainerFilesystemCapacity
	metricContainerFilesystemUsage       metricContainerFilesystemUsage
	metricContainerMemoryAvailable       metricContainerMemoryAvailable
	metricContainerMemoryMajorPageFaults metricContainerMemoryMajorPageFaults
	metricContainerMemoryPageFaults      metricContainerMemoryPageFaults
	metricContainerMemoryRss             metricContainerMemoryRss
	metricContainerMemoryUsage           metricContainerMemoryUsage
	metricContainerMemoryWorkingSet      metricContainerMemoryWorkingSet
	metricK8sNodeCPUTime                 metricK8sNodeCPUTime
	metricK8sNodeCPUUtilization          metricK8sNodeCPUUtilization
	metricK8sNodeFilesystemAvailable     metricK8sNodeFilesystemAvailable
	metricK8sNodeFilesystemCapacity      metricK8sNodeFilesystemCapacity
	metricK8sNodeFilesystemUsage         metricK8sNodeFilesystemUsage
	metricK8sNodeMemoryAvailable         metricK8sNodeMemoryAvailable
	metricK8sNodeMemoryMajorPageFaults   metricK8sNodeMemoryMajorPageFaults
	metricK8sNodeMemoryPageFaults        metricK8sNodeMemoryPageFaults
	metricK8sNodeMemoryRss               metricK8sNodeMemoryRss
	metricK8sNodeMemoryUsage             metricK8sNodeMemoryUsage
	metricK8sNodeMemoryWorkingSet        metricK8sNodeMemoryWorkingSet
	metricK8sNodeNetworkErrors           metricK8sNodeNetworkErrors
	metricK8sNodeNetworkIo               metricK8sNodeNetworkIo
	metricK8sPodCPUTime                  metricK8sPodCPUTime
	metricK8sPodCPUUtilization           metricK8sPodCPUUtilization
	metricK8sPodFilesystemAvailable      metricK8sPodFilesystemAvailable
	metricK8sPodFilesystemCapacity       metricK8sPodFilesystemCapacity
	metricK8sPodFilesystemUsage          metricK8sPodFilesystemUsage
	metricK8sPodMemoryAvailable          metricK8sPodMemoryAvailable
	metricK8sPodMemoryMajorPageFaults    metricK8sPodMemoryMajorPageFaults
	metricK8sPodMemoryPageFaults         metricK8sPodMemoryPageFaults
	metricK8sPodMemoryRss                metricK8sPodMemoryRss
	metricK8sPodMemoryUsage              metricK8sPodMemoryUsage
	metricK8sPodMemoryWorkingSet         metricK8sPodMemoryWorkingSet
	metricK8sPodNetworkErrors            metricK8sPodNetworkErrors
	metricK8sPodNetworkIo                metricK8sPodNetworkIo
	metricK8sVolumeAvailable             metricK8sVolumeAvailable
	metricK8sVolumeCapacity              metricK8sVolumeCapacity
	metricK8sVolumeInodes                metricK8sVolumeInodes
	metricK8sVolumeInodesFree            metricK8sVolumeInodesFree
	metricK8sVolumeInodesUsed            metricK8sVolumeInodesUsed
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:    mbc,
		startTime: pcommon.NewTimestampFromTime(time.Now()),
		buildInfo: settings.BuildInfo,
		rmbMap:    make(map[[16]byte]*ResourceMetricsBuilder),
	}
	for _, opt := range options {
		opt(mb)
	}
	return mb
}

// resourceMetricsBuilderOption applies changes to provided resource metrics.
type resourceMetricsBuilderOption func(*ResourceMetricsBuilder)

// WithStartTimeOverride sets start time for all the resource metrics data points.
func WithStartTimeOverride(start pcommon.Timestamp) resourceMetricsBuilderOption {
	return func(rmb *ResourceMetricsBuilder) {
		rmb.startTime = start
	}
}

// ResourceMetricsBuilder returns a ResourceMetricsBuilder that can be used to record metrics for a specific resource.
// It requires Resource to be provided which should be built with ResourceBuilder.
func (mb *MetricsBuilder) ResourceMetricsBuilder(res pcommon.Resource, options ...resourceMetricsBuilderOption) *ResourceMetricsBuilder {
	hash := pdatautil.MapHash(res.Attributes())
	if rmb, ok := mb.rmbMap[hash]; ok {
		return rmb
	}
	rmb := &ResourceMetricsBuilder{
		startTime:                            mb.startTime,
		buildInfo:                            mb.buildInfo,
		resource:                             res,
		metricContainerCPUTime:               newMetricContainerCPUTime(mb.config.Metrics.ContainerCPUTime),
		metricContainerCPUUtilization:        newMetricContainerCPUUtilization(mb.config.Metrics.ContainerCPUUtilization),
		metricContainerFilesystemAvailable:   newMetricContainerFilesystemAvailable(mb.config.Metrics.ContainerFilesystemAvailable),
		metricContainerFilesystemCapacity:    newMetricContainerFilesystemCapacity(mb.config.Metrics.ContainerFilesystemCapacity),
		metricContainerFilesystemUsage:       newMetricContainerFilesystemUsage(mb.config.Metrics.ContainerFilesystemUsage),
		metricContainerMemoryAvailable:       newMetricContainerMemoryAvailable(mb.config.Metrics.ContainerMemoryAvailable),
		metricContainerMemoryMajorPageFaults: newMetricContainerMemoryMajorPageFaults(mb.config.Metrics.ContainerMemoryMajorPageFaults),
		metricContainerMemoryPageFaults:      newMetricContainerMemoryPageFaults(mb.config.Metrics.ContainerMemoryPageFaults),
		metricContainerMemoryRss:             newMetricContainerMemoryRss(mb.config.Metrics.ContainerMemoryRss),
		metricContainerMemoryUsage:           newMetricContainerMemoryUsage(mb.config.Metrics.ContainerMemoryUsage),
		metricContainerMemoryWorkingSet:      newMetricContainerMemoryWorkingSet(mb.config.Metrics.ContainerMemoryWorkingSet),
		metricK8sNodeCPUTime:                 newMetricK8sNodeCPUTime(mb.config.Metrics.K8sNodeCPUTime),
		metricK8sNodeCPUUtilization:          newMetricK8sNodeCPUUtilization(mb.config.Metrics.K8sNodeCPUUtilization),
		metricK8sNodeFilesystemAvailable:     newMetricK8sNodeFilesystemAvailable(mb.config.Metrics.K8sNodeFilesystemAvailable),
		metricK8sNodeFilesystemCapacity:      newMetricK8sNodeFilesystemCapacity(mb.config.Metrics.K8sNodeFilesystemCapacity),
		metricK8sNodeFilesystemUsage:         newMetricK8sNodeFilesystemUsage(mb.config.Metrics.K8sNodeFilesystemUsage),
		metricK8sNodeMemoryAvailable:         newMetricK8sNodeMemoryAvailable(mb.config.Metrics.K8sNodeMemoryAvailable),
		metricK8sNodeMemoryMajorPageFaults:   newMetricK8sNodeMemoryMajorPageFaults(mb.config.Metrics.K8sNodeMemoryMajorPageFaults),
		metricK8sNodeMemoryPageFaults:        newMetricK8sNodeMemoryPageFaults(mb.config.Metrics.K8sNodeMemoryPageFaults),
		metricK8sNodeMemoryRss:               newMetricK8sNodeMemoryRss(mb.config.Metrics.K8sNodeMemoryRss),
		metricK8sNodeMemoryUsage:             newMetricK8sNodeMemoryUsage(mb.config.Metrics.K8sNodeMemoryUsage),
		metricK8sNodeMemoryWorkingSet:        newMetricK8sNodeMemoryWorkingSet(mb.config.Metrics.K8sNodeMemoryWorkingSet),
		metricK8sNodeNetworkErrors:           newMetricK8sNodeNetworkErrors(mb.config.Metrics.K8sNodeNetworkErrors),
		metricK8sNodeNetworkIo:               newMetricK8sNodeNetworkIo(mb.config.Metrics.K8sNodeNetworkIo),
		metricK8sPodCPUTime:                  newMetricK8sPodCPUTime(mb.config.Metrics.K8sPodCPUTime),
		metricK8sPodCPUUtilization:           newMetricK8sPodCPUUtilization(mb.config.Metrics.K8sPodCPUUtilization),
		metricK8sPodFilesystemAvailable:      newMetricK8sPodFilesystemAvailable(mb.config.Metrics.K8sPodFilesystemAvailable),
		metricK8sPodFilesystemCapacity:       newMetricK8sPodFilesystemCapacity(mb.config.Metrics.K8sPodFilesystemCapacity),
		metricK8sPodFilesystemUsage:          newMetricK8sPodFilesystemUsage(mb.config.Metrics.K8sPodFilesystemUsage),
		metricK8sPodMemoryAvailable:          newMetricK8sPodMemoryAvailable(mb.config.Metrics.K8sPodMemoryAvailable),
		metricK8sPodMemoryMajorPageFaults:    newMetricK8sPodMemoryMajorPageFaults(mb.config.Metrics.K8sPodMemoryMajorPageFaults),
		metricK8sPodMemoryPageFaults:         newMetricK8sPodMemoryPageFaults(mb.config.Metrics.K8sPodMemoryPageFaults),
		metricK8sPodMemoryRss:                newMetricK8sPodMemoryRss(mb.config.Metrics.K8sPodMemoryRss),
		metricK8sPodMemoryUsage:              newMetricK8sPodMemoryUsage(mb.config.Metrics.K8sPodMemoryUsage),
		metricK8sPodMemoryWorkingSet:         newMetricK8sPodMemoryWorkingSet(mb.config.Metrics.K8sPodMemoryWorkingSet),
		metricK8sPodNetworkErrors:            newMetricK8sPodNetworkErrors(mb.config.Metrics.K8sPodNetworkErrors),
		metricK8sPodNetworkIo:                newMetricK8sPodNetworkIo(mb.config.Metrics.K8sPodNetworkIo),
		metricK8sVolumeAvailable:             newMetricK8sVolumeAvailable(mb.config.Metrics.K8sVolumeAvailable),
		metricK8sVolumeCapacity:              newMetricK8sVolumeCapacity(mb.config.Metrics.K8sVolumeCapacity),
		metricK8sVolumeInodes:                newMetricK8sVolumeInodes(mb.config.Metrics.K8sVolumeInodes),
		metricK8sVolumeInodesFree:            newMetricK8sVolumeInodesFree(mb.config.Metrics.K8sVolumeInodesFree),
		metricK8sVolumeInodesUsed:            newMetricK8sVolumeInodesUsed(mb.config.Metrics.K8sVolumeInodesUsed),
	}
	for _, op := range options {
		op(rmb)
	}
	mb.rmbMap[hash] = rmb
	return rmb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (rmb *ResourceMetricsBuilder) updateCapacity(ms pmetric.MetricSlice) {
	if rmb.metricsCapacity < ms.Len() {
		rmb.metricsCapacity = ms.Len()
	}
}

// emit emits all the metrics accumulated by the ResourceMetricsBuilder and updates the internal state to be ready for
// recording another set of metrics. It returns true if any metrics were emitted.
func (rmb *ResourceMetricsBuilder) emit(m pmetric.Metrics) bool {
	sm := pmetric.NewScopeMetrics()
	sm.Metrics().EnsureCapacity(rmb.metricsCapacity)
	rmb.metricContainerCPUTime.emit(sm.Metrics())
	rmb.metricContainerCPUUtilization.emit(sm.Metrics())
	rmb.metricContainerFilesystemAvailable.emit(sm.Metrics())
	rmb.metricContainerFilesystemCapacity.emit(sm.Metrics())
	rmb.metricContainerFilesystemUsage.emit(sm.Metrics())
	rmb.metricContainerMemoryAvailable.emit(sm.Metrics())
	rmb.metricContainerMemoryMajorPageFaults.emit(sm.Metrics())
	rmb.metricContainerMemoryPageFaults.emit(sm.Metrics())
	rmb.metricContainerMemoryRss.emit(sm.Metrics())
	rmb.metricContainerMemoryUsage.emit(sm.Metrics())
	rmb.metricContainerMemoryWorkingSet.emit(sm.Metrics())
	rmb.metricK8sNodeCPUTime.emit(sm.Metrics())
	rmb.metricK8sNodeCPUUtilization.emit(sm.Metrics())
	rmb.metricK8sNodeFilesystemAvailable.emit(sm.Metrics())
	rmb.metricK8sNodeFilesystemCapacity.emit(sm.Metrics())
	rmb.metricK8sNodeFilesystemUsage.emit(sm.Metrics())
	rmb.metricK8sNodeMemoryAvailable.emit(sm.Metrics())
	rmb.metricK8sNodeMemoryMajorPageFaults.emit(sm.Metrics())
	rmb.metricK8sNodeMemoryPageFaults.emit(sm.Metrics())
	rmb.metricK8sNodeMemoryRss.emit(sm.Metrics())
	rmb.metricK8sNodeMemoryUsage.emit(sm.Metrics())
	rmb.metricK8sNodeMemoryWorkingSet.emit(sm.Metrics())
	rmb.metricK8sNodeNetworkErrors.emit(sm.Metrics())
	rmb.metricK8sNodeNetworkIo.emit(sm.Metrics())
	rmb.metricK8sPodCPUTime.emit(sm.Metrics())
	rmb.metricK8sPodCPUUtilization.emit(sm.Metrics())
	rmb.metricK8sPodFilesystemAvailable.emit(sm.Metrics())
	rmb.metricK8sPodFilesystemCapacity.emit(sm.Metrics())
	rmb.metricK8sPodFilesystemUsage.emit(sm.Metrics())
	rmb.metricK8sPodMemoryAvailable.emit(sm.Metrics())
	rmb.metricK8sPodMemoryMajorPageFaults.emit(sm.Metrics())
	rmb.metricK8sPodMemoryPageFaults.emit(sm.Metrics())
	rmb.metricK8sPodMemoryRss.emit(sm.Metrics())
	rmb.metricK8sPodMemoryUsage.emit(sm.Metrics())
	rmb.metricK8sPodMemoryWorkingSet.emit(sm.Metrics())
	rmb.metricK8sPodNetworkErrors.emit(sm.Metrics())
	rmb.metricK8sPodNetworkIo.emit(sm.Metrics())
	rmb.metricK8sVolumeAvailable.emit(sm.Metrics())
	rmb.metricK8sVolumeCapacity.emit(sm.Metrics())
	rmb.metricK8sVolumeInodes.emit(sm.Metrics())
	rmb.metricK8sVolumeInodesFree.emit(sm.Metrics())
	rmb.metricK8sVolumeInodesUsed.emit(sm.Metrics())
	if sm.Metrics().Len() == 0 {
		return false
	}
	rmb.updateCapacity(sm.Metrics())
	sm.Scope().SetName("otelcol/kubeletstatsreceiver")
	sm.Scope().SetVersion(rmb.buildInfo.Version)
	rm := m.ResourceMetrics().AppendEmpty()
	rmb.resource.CopyTo(rm.Resource())
	sm.MoveTo(rm.ScopeMetrics().AppendEmpty())
	return true
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit() pmetric.Metrics {
	m := pmetric.NewMetrics()
	for _, rmb := range mb.rmbMap {
		if ok := rmb.emit(m); !ok {
			rmb.missedEmits++
		}
	}
	for k, rmb := range mb.rmbMap {
		if rmb.missedEmits >= missedEmitsToDropRMB {
			delete(mb.rmbMap, k)
		}
	}
	return m
}

// RecordContainerCPUTimeDataPoint adds a data point to container.cpu.time metric.
func (rmb *ResourceMetricsBuilder) RecordContainerCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricContainerCPUTime.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerCPUUtilizationDataPoint adds a data point to container.cpu.utilization metric.
func (rmb *ResourceMetricsBuilder) RecordContainerCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricContainerCPUUtilization.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerFilesystemAvailableDataPoint adds a data point to container.filesystem.available metric.
func (rmb *ResourceMetricsBuilder) RecordContainerFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricContainerFilesystemAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerFilesystemCapacityDataPoint adds a data point to container.filesystem.capacity metric.
func (rmb *ResourceMetricsBuilder) RecordContainerFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricContainerFilesystemCapacity.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerFilesystemUsageDataPoint adds a data point to container.filesystem.usage metric.
func (rmb *ResourceMetricsBuilder) RecordContainerFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricContainerFilesystemUsage.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerMemoryAvailableDataPoint adds a data point to container.memory.available metric.
func (rmb *ResourceMetricsBuilder) RecordContainerMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricContainerMemoryAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerMemoryMajorPageFaultsDataPoint adds a data point to container.memory.major_page_faults metric.
func (rmb *ResourceMetricsBuilder) RecordContainerMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricContainerMemoryMajorPageFaults.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerMemoryPageFaultsDataPoint adds a data point to container.memory.page_faults metric.
func (rmb *ResourceMetricsBuilder) RecordContainerMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricContainerMemoryPageFaults.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerMemoryRssDataPoint adds a data point to container.memory.rss metric.
func (rmb *ResourceMetricsBuilder) RecordContainerMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricContainerMemoryRss.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerMemoryUsageDataPoint adds a data point to container.memory.usage metric.
func (rmb *ResourceMetricsBuilder) RecordContainerMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricContainerMemoryUsage.recordDataPoint(rmb.startTime, ts, val)
}

// RecordContainerMemoryWorkingSetDataPoint adds a data point to container.memory.working_set metric.
func (rmb *ResourceMetricsBuilder) RecordContainerMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricContainerMemoryWorkingSet.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeCPUTimeDataPoint adds a data point to k8s.node.cpu.time metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricK8sNodeCPUTime.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeCPUUtilizationDataPoint adds a data point to k8s.node.cpu.utilization metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricK8sNodeCPUUtilization.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeFilesystemAvailableDataPoint adds a data point to k8s.node.filesystem.available metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNodeFilesystemAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeFilesystemCapacityDataPoint adds a data point to k8s.node.filesystem.capacity metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNodeFilesystemCapacity.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeFilesystemUsageDataPoint adds a data point to k8s.node.filesystem.usage metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNodeFilesystemUsage.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeMemoryAvailableDataPoint adds a data point to k8s.node.memory.available metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNodeMemoryAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeMemoryMajorPageFaultsDataPoint adds a data point to k8s.node.memory.major_page_faults metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNodeMemoryMajorPageFaults.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeMemoryPageFaultsDataPoint adds a data point to k8s.node.memory.page_faults metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNodeMemoryPageFaults.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeMemoryRssDataPoint adds a data point to k8s.node.memory.rss metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNodeMemoryRss.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeMemoryUsageDataPoint adds a data point to k8s.node.memory.usage metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNodeMemoryUsage.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeMemoryWorkingSetDataPoint adds a data point to k8s.node.memory.working_set metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNodeMemoryWorkingSet.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNodeNetworkErrorsDataPoint adds a data point to k8s.node.network.errors metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeNetworkErrorsDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	rmb.metricK8sNodeNetworkErrors.recordDataPoint(rmb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sNodeNetworkIoDataPoint adds a data point to k8s.node.network.io metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNodeNetworkIoDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	rmb.metricK8sNodeNetworkIo.recordDataPoint(rmb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sPodCPUTimeDataPoint adds a data point to k8s.pod.cpu.time metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodCPUTimeDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricK8sPodCPUTime.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodCPUUtilizationDataPoint adds a data point to k8s.pod.cpu.utilization metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodCPUUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricK8sPodCPUUtilization.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodFilesystemAvailableDataPoint adds a data point to k8s.pod.filesystem.available metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodFilesystemAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodFilesystemAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodFilesystemCapacityDataPoint adds a data point to k8s.pod.filesystem.capacity metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodFilesystemCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodFilesystemCapacity.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodFilesystemUsageDataPoint adds a data point to k8s.pod.filesystem.usage metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodFilesystemUsageDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodFilesystemUsage.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodMemoryAvailableDataPoint adds a data point to k8s.pod.memory.available metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodMemoryAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodMemoryAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodMemoryMajorPageFaultsDataPoint adds a data point to k8s.pod.memory.major_page_faults metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodMemoryMajorPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodMemoryMajorPageFaults.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodMemoryPageFaultsDataPoint adds a data point to k8s.pod.memory.page_faults metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodMemoryPageFaultsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodMemoryPageFaults.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodMemoryRssDataPoint adds a data point to k8s.pod.memory.rss metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodMemoryRssDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodMemoryRss.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodMemoryUsageDataPoint adds a data point to k8s.pod.memory.usage metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodMemoryUsageDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodMemoryUsage.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodMemoryWorkingSetDataPoint adds a data point to k8s.pod.memory.working_set metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodMemoryWorkingSetDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodMemoryWorkingSet.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodNetworkErrorsDataPoint adds a data point to k8s.pod.network.errors metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodNetworkErrorsDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	rmb.metricK8sPodNetworkErrors.recordDataPoint(rmb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sPodNetworkIoDataPoint adds a data point to k8s.pod.network.io metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodNetworkIoDataPoint(ts pcommon.Timestamp, val int64, interfaceAttributeValue string, directionAttributeValue AttributeDirection) {
	rmb.metricK8sPodNetworkIo.recordDataPoint(rmb.startTime, ts, val, interfaceAttributeValue, directionAttributeValue.String())
}

// RecordK8sVolumeAvailableDataPoint adds a data point to k8s.volume.available metric.
func (rmb *ResourceMetricsBuilder) RecordK8sVolumeAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sVolumeAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sVolumeCapacityDataPoint adds a data point to k8s.volume.capacity metric.
func (rmb *ResourceMetricsBuilder) RecordK8sVolumeCapacityDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sVolumeCapacity.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sVolumeInodesDataPoint adds a data point to k8s.volume.inodes metric.
func (rmb *ResourceMetricsBuilder) RecordK8sVolumeInodesDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sVolumeInodes.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sVolumeInodesFreeDataPoint adds a data point to k8s.volume.inodes.free metric.
func (rmb *ResourceMetricsBuilder) RecordK8sVolumeInodesFreeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sVolumeInodesFree.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sVolumeInodesUsedDataPoint adds a data point to k8s.volume.inodes.used metric.
func (rmb *ResourceMetricsBuilder) RecordK8sVolumeInodesUsedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sVolumeInodesUsed.recordDataPoint(rmb.startTime, ts, val)
}

// Reset resets the ResourceMetricsBuilder to its initial state. It should be used when external metrics source is
// restarted, and the ResourceMetricsBuilder should update its startTime and reset it's internal state accordingly.
func (rmb *ResourceMetricsBuilder) Reset(options ...resourceMetricsBuilderOption) {
	rmb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(rmb)
	}
}
