// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"

	"github.com/open-telemetry/opentelemetry-collector-contrib/pkg/pdatautil"
)

// AttributeDirection specifies the a value direction attribute.
type AttributeDirection int

const (
	_ AttributeDirection = iota
	AttributeDirectionSent
	AttributeDirectionReceived
)

// String returns the string representation of the AttributeDirection.
func (av AttributeDirection) String() string {
	switch av {
	case AttributeDirectionSent:
		return "sent"
	case AttributeDirectionReceived:
		return "received"
	}
	return ""
}

// MapAttributeDirection is a helper map of string to AttributeDirection attribute value.
var MapAttributeDirection = map[string]AttributeDirection{
	"sent":     AttributeDirectionSent,
	"received": AttributeDirectionReceived,
}

// AttributeRequest specifies the a value request attribute.
type AttributeRequest int

const (
	_ AttributeRequest = iota
	AttributeRequestDelete
	AttributeRequestGet
	AttributeRequestHead
	AttributeRequestOptions
	AttributeRequestPost
	AttributeRequestPut
	AttributeRequestTrace
)

// String returns the string representation of the AttributeRequest.
func (av AttributeRequest) String() string {
	switch av {
	case AttributeRequestDelete:
		return "delete"
	case AttributeRequestGet:
		return "get"
	case AttributeRequestHead:
		return "head"
	case AttributeRequestOptions:
		return "options"
	case AttributeRequestPost:
		return "post"
	case AttributeRequestPut:
		return "put"
	case AttributeRequestTrace:
		return "trace"
	}
	return ""
}

// MapAttributeRequest is a helper map of string to AttributeRequest attribute value.
var MapAttributeRequest = map[string]AttributeRequest{
	"delete":  AttributeRequestDelete,
	"get":     AttributeRequestGet,
	"head":    AttributeRequestHead,
	"options": AttributeRequestOptions,
	"post":    AttributeRequestPost,
	"put":     AttributeRequestPut,
	"trace":   AttributeRequestTrace,
}

type metricIisConnectionActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.connection.active metric with initial data.
func (m *metricIisConnectionActive) init() {
	m.data.SetName("iis.connection.active")
	m.data.SetDescription("Number of active connections.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricIisConnectionActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisConnectionActive) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisConnectionActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisConnectionActive(cfg MetricConfig) metricIisConnectionActive {
	m := metricIisConnectionActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisConnectionAnonymous struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.connection.anonymous metric with initial data.
func (m *metricIisConnectionAnonymous) init() {
	m.data.SetName("iis.connection.anonymous")
	m.data.SetDescription("Number of connections established anonymously.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricIisConnectionAnonymous) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisConnectionAnonymous) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisConnectionAnonymous) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisConnectionAnonymous(cfg MetricConfig) metricIisConnectionAnonymous {
	m := metricIisConnectionAnonymous{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisConnectionAttemptCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.connection.attempt.count metric with initial data.
func (m *metricIisConnectionAttemptCount) init() {
	m.data.SetName("iis.connection.attempt.count")
	m.data.SetDescription("Total number of attempts to connect to the server.")
	m.data.SetUnit("{attempts}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricIisConnectionAttemptCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisConnectionAttemptCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisConnectionAttemptCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisConnectionAttemptCount(cfg MetricConfig) metricIisConnectionAttemptCount {
	m := metricIisConnectionAttemptCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisNetworkBlocked struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.network.blocked metric with initial data.
func (m *metricIisNetworkBlocked) init() {
	m.data.SetName("iis.network.blocked")
	m.data.SetDescription("Number of bytes blocked due to bandwidth throttling.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricIisNetworkBlocked) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisNetworkBlocked) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisNetworkBlocked) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisNetworkBlocked(cfg MetricConfig) metricIisNetworkBlocked {
	m := metricIisNetworkBlocked{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisNetworkFileCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.network.file.count metric with initial data.
func (m *metricIisNetworkFileCount) init() {
	m.data.SetName("iis.network.file.count")
	m.data.SetDescription("Number of transmitted files.")
	m.data.SetUnit("{files}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIisNetworkFileCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisNetworkFileCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisNetworkFileCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisNetworkFileCount(cfg MetricConfig) metricIisNetworkFileCount {
	m := metricIisNetworkFileCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisNetworkIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.network.io metric with initial data.
func (m *metricIisNetworkIo) init() {
	m.data.SetName("iis.network.io")
	m.data.SetDescription("Total amount of bytes sent and received.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIisNetworkIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisNetworkIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisNetworkIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisNetworkIo(cfg MetricConfig) metricIisNetworkIo {
	m := metricIisNetworkIo{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisRequestCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.request.count metric with initial data.
func (m *metricIisRequestCount) init() {
	m.data.SetName("iis.request.count")
	m.data.SetDescription("Total number of requests of a given type.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIisRequestCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, requestAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("request", requestAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisRequestCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisRequestCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisRequestCount(cfg MetricConfig) metricIisRequestCount {
	m := metricIisRequestCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisRequestQueueAgeMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.request.queue.age.max metric with initial data.
func (m *metricIisRequestQueueAgeMax) init() {
	m.data.SetName("iis.request.queue.age.max")
	m.data.SetDescription("Age of oldest request in the queue.")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricIisRequestQueueAgeMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisRequestQueueAgeMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisRequestQueueAgeMax) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisRequestQueueAgeMax(cfg MetricConfig) metricIisRequestQueueAgeMax {
	m := metricIisRequestQueueAgeMax{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisRequestQueueCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.request.queue.count metric with initial data.
func (m *metricIisRequestQueueCount) init() {
	m.data.SetName("iis.request.queue.count")
	m.data.SetDescription("Current number of requests in the queue.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricIisRequestQueueCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisRequestQueueCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisRequestQueueCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisRequestQueueCount(cfg MetricConfig) metricIisRequestQueueCount {
	m := metricIisRequestQueueCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisRequestRejected struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.request.rejected metric with initial data.
func (m *metricIisRequestRejected) init() {
	m.data.SetName("iis.request.rejected")
	m.data.SetDescription("Total number of requests rejected.")
	m.data.SetUnit("{requests}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricIisRequestRejected) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisRequestRejected) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisRequestRejected) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisRequestRejected(cfg MetricConfig) metricIisRequestRejected {
	m := metricIisRequestRejected{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisThreadActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.thread.active metric with initial data.
func (m *metricIisThreadActive) init() {
	m.data.SetName("iis.thread.active")
	m.data.SetDescription("Current number of active threads.")
	m.data.SetUnit("{threads}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricIisThreadActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisThreadActive) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisThreadActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisThreadActive(cfg MetricConfig) metricIisThreadActive {
	m := metricIisThreadActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIisUptime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills iis.uptime metric with initial data.
func (m *metricIisUptime) init() {
	m.data.SetName("iis.uptime")
	m.data.SetDescription("The amount of time the server has been up.")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricIisUptime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIisUptime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIisUptime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIisUptime(cfg MetricConfig) metricIisUptime {
	m := metricIisUptime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// missedEmitsToDropRMB is number of missed emits after which resource builder will be dropped from MetricsBuilder.rmbMap.
// Potentially, this value can be made configurable through a MetricsBuilder option.
const missedEmitsToDropRMB = 5

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config    MetricsBuilderConfig                 // config of the metrics builder.
	buildInfo component.BuildInfo                  // contains version information
	startTime pcommon.Timestamp                    // start time that will be applied to all recorded data points.
	rmbMap    map[[16]byte]*ResourceMetricsBuilder // map of resource builders by resource hash.
}

type ResourceMetricsBuilder struct {
	buildInfo                       component.BuildInfo
	startTime                       pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                 int               // maximum observed number of metrics per resource.
	resource                        pcommon.Resource
	missedEmits                     int
	metricIisConnectionActive       metricIisConnectionActive
	metricIisConnectionAnonymous    metricIisConnectionAnonymous
	metricIisConnectionAttemptCount metricIisConnectionAttemptCount
	metricIisNetworkBlocked         metricIisNetworkBlocked
	metricIisNetworkFileCount       metricIisNetworkFileCount
	metricIisNetworkIo              metricIisNetworkIo
	metricIisRequestCount           metricIisRequestCount
	metricIisRequestQueueAgeMax     metricIisRequestQueueAgeMax
	metricIisRequestQueueCount      metricIisRequestQueueCount
	metricIisRequestRejected        metricIisRequestRejected
	metricIisThreadActive           metricIisThreadActive
	metricIisUptime                 metricIisUptime
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:    mbc,
		startTime: pcommon.NewTimestampFromTime(time.Now()),
		buildInfo: settings.BuildInfo,
		rmbMap:    make(map[[16]byte]*ResourceMetricsBuilder),
	}
	for _, opt := range options {
		opt(mb)
	}
	return mb
}

// resourceMetricsBuilderOption applies changes to provided resource metrics.
type resourceMetricsBuilderOption func(*ResourceMetricsBuilder)

// WithStartTimeOverride sets start time for all the resource metrics data points.
func WithStartTimeOverride(start pcommon.Timestamp) resourceMetricsBuilderOption {
	return func(rmb *ResourceMetricsBuilder) {
		rmb.startTime = start
	}
}

// ResourceMetricsBuilder returns a ResourceMetricsBuilder that can be used to record metrics for a specific resource.
// It requires Resource to be provided which should be built with ResourceBuilder.
func (mb *MetricsBuilder) ResourceMetricsBuilder(res pcommon.Resource, options ...resourceMetricsBuilderOption) *ResourceMetricsBuilder {
	hash := pdatautil.MapHash(res.Attributes())
	if rmb, ok := mb.rmbMap[hash]; ok {
		return rmb
	}
	rmb := &ResourceMetricsBuilder{
		startTime:                       mb.startTime,
		buildInfo:                       mb.buildInfo,
		resource:                        res,
		metricIisConnectionActive:       newMetricIisConnectionActive(mb.config.Metrics.IisConnectionActive),
		metricIisConnectionAnonymous:    newMetricIisConnectionAnonymous(mb.config.Metrics.IisConnectionAnonymous),
		metricIisConnectionAttemptCount: newMetricIisConnectionAttemptCount(mb.config.Metrics.IisConnectionAttemptCount),
		metricIisNetworkBlocked:         newMetricIisNetworkBlocked(mb.config.Metrics.IisNetworkBlocked),
		metricIisNetworkFileCount:       newMetricIisNetworkFileCount(mb.config.Metrics.IisNetworkFileCount),
		metricIisNetworkIo:              newMetricIisNetworkIo(mb.config.Metrics.IisNetworkIo),
		metricIisRequestCount:           newMetricIisRequestCount(mb.config.Metrics.IisRequestCount),
		metricIisRequestQueueAgeMax:     newMetricIisRequestQueueAgeMax(mb.config.Metrics.IisRequestQueueAgeMax),
		metricIisRequestQueueCount:      newMetricIisRequestQueueCount(mb.config.Metrics.IisRequestQueueCount),
		metricIisRequestRejected:        newMetricIisRequestRejected(mb.config.Metrics.IisRequestRejected),
		metricIisThreadActive:           newMetricIisThreadActive(mb.config.Metrics.IisThreadActive),
		metricIisUptime:                 newMetricIisUptime(mb.config.Metrics.IisUptime),
	}
	for _, op := range options {
		op(rmb)
	}
	mb.rmbMap[hash] = rmb
	return rmb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (rmb *ResourceMetricsBuilder) updateCapacity(ms pmetric.MetricSlice) {
	if rmb.metricsCapacity < ms.Len() {
		rmb.metricsCapacity = ms.Len()
	}
}

// emit emits all the metrics accumulated by the ResourceMetricsBuilder and updates the internal state to be ready for
// recording another set of metrics. It returns true if any metrics were emitted.
func (rmb *ResourceMetricsBuilder) emit(m pmetric.Metrics) bool {
	sm := pmetric.NewScopeMetrics()
	sm.Metrics().EnsureCapacity(rmb.metricsCapacity)
	rmb.metricIisConnectionActive.emit(sm.Metrics())
	rmb.metricIisConnectionAnonymous.emit(sm.Metrics())
	rmb.metricIisConnectionAttemptCount.emit(sm.Metrics())
	rmb.metricIisNetworkBlocked.emit(sm.Metrics())
	rmb.metricIisNetworkFileCount.emit(sm.Metrics())
	rmb.metricIisNetworkIo.emit(sm.Metrics())
	rmb.metricIisRequestCount.emit(sm.Metrics())
	rmb.metricIisRequestQueueAgeMax.emit(sm.Metrics())
	rmb.metricIisRequestQueueCount.emit(sm.Metrics())
	rmb.metricIisRequestRejected.emit(sm.Metrics())
	rmb.metricIisThreadActive.emit(sm.Metrics())
	rmb.metricIisUptime.emit(sm.Metrics())
	if sm.Metrics().Len() == 0 {
		return false
	}
	rmb.updateCapacity(sm.Metrics())
	sm.Scope().SetName("otelcol/iisreceiver")
	sm.Scope().SetVersion(rmb.buildInfo.Version)
	rm := m.ResourceMetrics().AppendEmpty()
	rmb.resource.CopyTo(rm.Resource())
	sm.MoveTo(rm.ScopeMetrics().AppendEmpty())
	return true
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit() pmetric.Metrics {
	m := pmetric.NewMetrics()
	for _, rmb := range mb.rmbMap {
		if ok := rmb.emit(m); !ok {
			rmb.missedEmits++
		}
	}
	for k, rmb := range mb.rmbMap {
		if rmb.missedEmits >= missedEmitsToDropRMB {
			delete(mb.rmbMap, k)
		}
	}
	return m
}

// RecordIisConnectionActiveDataPoint adds a data point to iis.connection.active metric.
func (rmb *ResourceMetricsBuilder) RecordIisConnectionActiveDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricIisConnectionActive.recordDataPoint(rmb.startTime, ts, val)
}

// RecordIisConnectionAnonymousDataPoint adds a data point to iis.connection.anonymous metric.
func (rmb *ResourceMetricsBuilder) RecordIisConnectionAnonymousDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricIisConnectionAnonymous.recordDataPoint(rmb.startTime, ts, val)
}

// RecordIisConnectionAttemptCountDataPoint adds a data point to iis.connection.attempt.count metric.
func (rmb *ResourceMetricsBuilder) RecordIisConnectionAttemptCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricIisConnectionAttemptCount.recordDataPoint(rmb.startTime, ts, val)
}

// RecordIisNetworkBlockedDataPoint adds a data point to iis.network.blocked metric.
func (rmb *ResourceMetricsBuilder) RecordIisNetworkBlockedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricIisNetworkBlocked.recordDataPoint(rmb.startTime, ts, val)
}

// RecordIisNetworkFileCountDataPoint adds a data point to iis.network.file.count metric.
func (rmb *ResourceMetricsBuilder) RecordIisNetworkFileCountDataPoint(ts pcommon.Timestamp, val int64, directionAttributeValue AttributeDirection) {
	rmb.metricIisNetworkFileCount.recordDataPoint(rmb.startTime, ts, val, directionAttributeValue.String())
}

// RecordIisNetworkIoDataPoint adds a data point to iis.network.io metric.
func (rmb *ResourceMetricsBuilder) RecordIisNetworkIoDataPoint(ts pcommon.Timestamp, val int64, directionAttributeValue AttributeDirection) {
	rmb.metricIisNetworkIo.recordDataPoint(rmb.startTime, ts, val, directionAttributeValue.String())
}

// RecordIisRequestCountDataPoint adds a data point to iis.request.count metric.
func (rmb *ResourceMetricsBuilder) RecordIisRequestCountDataPoint(ts pcommon.Timestamp, val int64, requestAttributeValue AttributeRequest) {
	rmb.metricIisRequestCount.recordDataPoint(rmb.startTime, ts, val, requestAttributeValue.String())
}

// RecordIisRequestQueueAgeMaxDataPoint adds a data point to iis.request.queue.age.max metric.
func (rmb *ResourceMetricsBuilder) RecordIisRequestQueueAgeMaxDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricIisRequestQueueAgeMax.recordDataPoint(rmb.startTime, ts, val)
}

// RecordIisRequestQueueCountDataPoint adds a data point to iis.request.queue.count metric.
func (rmb *ResourceMetricsBuilder) RecordIisRequestQueueCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricIisRequestQueueCount.recordDataPoint(rmb.startTime, ts, val)
}

// RecordIisRequestRejectedDataPoint adds a data point to iis.request.rejected metric.
func (rmb *ResourceMetricsBuilder) RecordIisRequestRejectedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricIisRequestRejected.recordDataPoint(rmb.startTime, ts, val)
}

// RecordIisThreadActiveDataPoint adds a data point to iis.thread.active metric.
func (rmb *ResourceMetricsBuilder) RecordIisThreadActiveDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricIisThreadActive.recordDataPoint(rmb.startTime, ts, val)
}

// RecordIisUptimeDataPoint adds a data point to iis.uptime metric.
func (rmb *ResourceMetricsBuilder) RecordIisUptimeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricIisUptime.recordDataPoint(rmb.startTime, ts, val)
}

// Reset resets the ResourceMetricsBuilder to its initial state. It should be used when external metrics source is
// restarted, and the ResourceMetricsBuilder should update its startTime and reset it's internal state accordingly.
func (rmb *ResourceMetricsBuilder) Reset(options ...resourceMetricsBuilderOption) {
	rmb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(rmb)
	}
}
