// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
	conventions "go.opentelemetry.io/collector/semconv/v1.18.0"

	"github.com/open-telemetry/opentelemetry-collector-contrib/pkg/pdatautil"
)

type metricK8sContainerCPULimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.cpu_limit metric with initial data.
func (m *metricK8sContainerCPULimit) init() {
	m.data.SetName("k8s.container.cpu_limit")
	m.data.SetDescription("Maximum resource limit set for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details")
	m.data.SetUnit("{cpu}")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerCPULimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerCPULimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerCPULimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerCPULimit(cfg MetricConfig) metricK8sContainerCPULimit {
	m := metricK8sContainerCPULimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerCPURequest struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.cpu_request metric with initial data.
func (m *metricK8sContainerCPURequest) init() {
	m.data.SetName("k8s.container.cpu_request")
	m.data.SetDescription("Resource requested for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details")
	m.data.SetUnit("{cpu}")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerCPURequest) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerCPURequest) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerCPURequest) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerCPURequest(cfg MetricConfig) metricK8sContainerCPURequest {
	m := metricK8sContainerCPURequest{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerEphemeralstorageLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.ephemeralstorage_limit metric with initial data.
func (m *metricK8sContainerEphemeralstorageLimit) init() {
	m.data.SetName("k8s.container.ephemeralstorage_limit")
	m.data.SetDescription("Maximum resource limit set for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerEphemeralstorageLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerEphemeralstorageLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerEphemeralstorageLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerEphemeralstorageLimit(cfg MetricConfig) metricK8sContainerEphemeralstorageLimit {
	m := metricK8sContainerEphemeralstorageLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerEphemeralstorageRequest struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.ephemeralstorage_request metric with initial data.
func (m *metricK8sContainerEphemeralstorageRequest) init() {
	m.data.SetName("k8s.container.ephemeralstorage_request")
	m.data.SetDescription("Resource requested for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerEphemeralstorageRequest) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerEphemeralstorageRequest) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerEphemeralstorageRequest) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerEphemeralstorageRequest(cfg MetricConfig) metricK8sContainerEphemeralstorageRequest {
	m := metricK8sContainerEphemeralstorageRequest{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory_limit metric with initial data.
func (m *metricK8sContainerMemoryLimit) init() {
	m.data.SetName("k8s.container.memory_limit")
	m.data.SetDescription("Maximum resource limit set for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryLimit(cfg MetricConfig) metricK8sContainerMemoryLimit {
	m := metricK8sContainerMemoryLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerMemoryRequest struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.memory_request metric with initial data.
func (m *metricK8sContainerMemoryRequest) init() {
	m.data.SetName("k8s.container.memory_request")
	m.data.SetDescription("Resource requested for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerMemoryRequest) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerMemoryRequest) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerMemoryRequest) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerMemoryRequest(cfg MetricConfig) metricK8sContainerMemoryRequest {
	m := metricK8sContainerMemoryRequest{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerReady struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.ready metric with initial data.
func (m *metricK8sContainerReady) init() {
	m.data.SetName("k8s.container.ready")
	m.data.SetDescription("Whether a container has passed its readiness probe (0 for no, 1 for yes)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerReady) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerReady) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerReady) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerReady(cfg MetricConfig) metricK8sContainerReady {
	m := metricK8sContainerReady{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerRestarts struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.restarts metric with initial data.
func (m *metricK8sContainerRestarts) init() {
	m.data.SetName("k8s.container.restarts")
	m.data.SetDescription("How many times the container has restarted in the recent past. This value is pulled directly from the K8s API and the value can go indefinitely high and be reset to 0 at any time depending on how your kubelet is configured to prune dead containers. It is best to not depend too much on the exact value but rather look at it as either == 0, in which case you can conclude there were no restarts in the recent past, or > 0, in which case you can conclude there were restarts in the recent past, and not try and analyze the value beyond that.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerRestarts) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerRestarts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerRestarts) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerRestarts(cfg MetricConfig) metricK8sContainerRestarts {
	m := metricK8sContainerRestarts{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerStorageLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.storage_limit metric with initial data.
func (m *metricK8sContainerStorageLimit) init() {
	m.data.SetName("k8s.container.storage_limit")
	m.data.SetDescription("Maximum resource limit set for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerStorageLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerStorageLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerStorageLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerStorageLimit(cfg MetricConfig) metricK8sContainerStorageLimit {
	m := metricK8sContainerStorageLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sContainerStorageRequest struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.container.storage_request metric with initial data.
func (m *metricK8sContainerStorageRequest) init() {
	m.data.SetName("k8s.container.storage_request")
	m.data.SetDescription("Resource requested for the container. See https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#resourcerequirements-v1-core for details")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricK8sContainerStorageRequest) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sContainerStorageRequest) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sContainerStorageRequest) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sContainerStorageRequest(cfg MetricConfig) metricK8sContainerStorageRequest {
	m := metricK8sContainerStorageRequest{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sCronjobActiveJobs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.cronjob.active_jobs metric with initial data.
func (m *metricK8sCronjobActiveJobs) init() {
	m.data.SetName("k8s.cronjob.active_jobs")
	m.data.SetDescription("The number of actively running jobs for a cronjob")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sCronjobActiveJobs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sCronjobActiveJobs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sCronjobActiveJobs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sCronjobActiveJobs(cfg MetricConfig) metricK8sCronjobActiveJobs {
	m := metricK8sCronjobActiveJobs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sDaemonsetCurrentScheduledNodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.daemonset.current_scheduled_nodes metric with initial data.
func (m *metricK8sDaemonsetCurrentScheduledNodes) init() {
	m.data.SetName("k8s.daemonset.current_scheduled_nodes")
	m.data.SetDescription("Number of nodes that are running at least 1 daemon pod and are supposed to run the daemon pod")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sDaemonsetCurrentScheduledNodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sDaemonsetCurrentScheduledNodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sDaemonsetCurrentScheduledNodes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sDaemonsetCurrentScheduledNodes(cfg MetricConfig) metricK8sDaemonsetCurrentScheduledNodes {
	m := metricK8sDaemonsetCurrentScheduledNodes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sDaemonsetDesiredScheduledNodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.daemonset.desired_scheduled_nodes metric with initial data.
func (m *metricK8sDaemonsetDesiredScheduledNodes) init() {
	m.data.SetName("k8s.daemonset.desired_scheduled_nodes")
	m.data.SetDescription("Number of nodes that should be running the daemon pod (including nodes currently running the daemon pod)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sDaemonsetDesiredScheduledNodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sDaemonsetDesiredScheduledNodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sDaemonsetDesiredScheduledNodes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sDaemonsetDesiredScheduledNodes(cfg MetricConfig) metricK8sDaemonsetDesiredScheduledNodes {
	m := metricK8sDaemonsetDesiredScheduledNodes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sDaemonsetMisscheduledNodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.daemonset.misscheduled_nodes metric with initial data.
func (m *metricK8sDaemonsetMisscheduledNodes) init() {
	m.data.SetName("k8s.daemonset.misscheduled_nodes")
	m.data.SetDescription("Number of nodes that are running the daemon pod, but are not supposed to run the daemon pod")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sDaemonsetMisscheduledNodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sDaemonsetMisscheduledNodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sDaemonsetMisscheduledNodes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sDaemonsetMisscheduledNodes(cfg MetricConfig) metricK8sDaemonsetMisscheduledNodes {
	m := metricK8sDaemonsetMisscheduledNodes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sDaemonsetReadyNodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.daemonset.ready_nodes metric with initial data.
func (m *metricK8sDaemonsetReadyNodes) init() {
	m.data.SetName("k8s.daemonset.ready_nodes")
	m.data.SetDescription("Number of nodes that should be running the daemon pod and have one or more of the daemon pod running and ready")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sDaemonsetReadyNodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sDaemonsetReadyNodes) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sDaemonsetReadyNodes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sDaemonsetReadyNodes(cfg MetricConfig) metricK8sDaemonsetReadyNodes {
	m := metricK8sDaemonsetReadyNodes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sDeploymentAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.deployment.available metric with initial data.
func (m *metricK8sDeploymentAvailable) init() {
	m.data.SetName("k8s.deployment.available")
	m.data.SetDescription("Total number of available pods (ready for at least minReadySeconds) targeted by this deployment")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sDeploymentAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sDeploymentAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sDeploymentAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sDeploymentAvailable(cfg MetricConfig) metricK8sDeploymentAvailable {
	m := metricK8sDeploymentAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sDeploymentDesired struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.deployment.desired metric with initial data.
func (m *metricK8sDeploymentDesired) init() {
	m.data.SetName("k8s.deployment.desired")
	m.data.SetDescription("Number of desired pods in this deployment")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sDeploymentDesired) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sDeploymentDesired) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sDeploymentDesired) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sDeploymentDesired(cfg MetricConfig) metricK8sDeploymentDesired {
	m := metricK8sDeploymentDesired{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sHpaCurrentReplicas struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.hpa.current_replicas metric with initial data.
func (m *metricK8sHpaCurrentReplicas) init() {
	m.data.SetName("k8s.hpa.current_replicas")
	m.data.SetDescription("Current number of pod replicas managed by this autoscaler.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sHpaCurrentReplicas) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sHpaCurrentReplicas) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sHpaCurrentReplicas) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sHpaCurrentReplicas(cfg MetricConfig) metricK8sHpaCurrentReplicas {
	m := metricK8sHpaCurrentReplicas{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sHpaDesiredReplicas struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.hpa.desired_replicas metric with initial data.
func (m *metricK8sHpaDesiredReplicas) init() {
	m.data.SetName("k8s.hpa.desired_replicas")
	m.data.SetDescription("Desired number of pod replicas managed by this autoscaler.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sHpaDesiredReplicas) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sHpaDesiredReplicas) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sHpaDesiredReplicas) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sHpaDesiredReplicas(cfg MetricConfig) metricK8sHpaDesiredReplicas {
	m := metricK8sHpaDesiredReplicas{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sHpaMaxReplicas struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.hpa.max_replicas metric with initial data.
func (m *metricK8sHpaMaxReplicas) init() {
	m.data.SetName("k8s.hpa.max_replicas")
	m.data.SetDescription("Maximum number of replicas to which the autoscaler can scale up.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sHpaMaxReplicas) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sHpaMaxReplicas) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sHpaMaxReplicas) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sHpaMaxReplicas(cfg MetricConfig) metricK8sHpaMaxReplicas {
	m := metricK8sHpaMaxReplicas{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sHpaMinReplicas struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.hpa.min_replicas metric with initial data.
func (m *metricK8sHpaMinReplicas) init() {
	m.data.SetName("k8s.hpa.min_replicas")
	m.data.SetDescription("Minimum number of replicas to which the autoscaler can scale up.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sHpaMinReplicas) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sHpaMinReplicas) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sHpaMinReplicas) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sHpaMinReplicas(cfg MetricConfig) metricK8sHpaMinReplicas {
	m := metricK8sHpaMinReplicas{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sJobActivePods struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.job.active_pods metric with initial data.
func (m *metricK8sJobActivePods) init() {
	m.data.SetName("k8s.job.active_pods")
	m.data.SetDescription("The number of actively running pods for a job")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sJobActivePods) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sJobActivePods) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sJobActivePods) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sJobActivePods(cfg MetricConfig) metricK8sJobActivePods {
	m := metricK8sJobActivePods{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sJobDesiredSuccessfulPods struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.job.desired_successful_pods metric with initial data.
func (m *metricK8sJobDesiredSuccessfulPods) init() {
	m.data.SetName("k8s.job.desired_successful_pods")
	m.data.SetDescription("The desired number of successfully finished pods the job should be run with")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sJobDesiredSuccessfulPods) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sJobDesiredSuccessfulPods) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sJobDesiredSuccessfulPods) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sJobDesiredSuccessfulPods(cfg MetricConfig) metricK8sJobDesiredSuccessfulPods {
	m := metricK8sJobDesiredSuccessfulPods{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sJobFailedPods struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.job.failed_pods metric with initial data.
func (m *metricK8sJobFailedPods) init() {
	m.data.SetName("k8s.job.failed_pods")
	m.data.SetDescription("The number of pods which reached phase Failed for a job")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sJobFailedPods) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sJobFailedPods) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sJobFailedPods) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sJobFailedPods(cfg MetricConfig) metricK8sJobFailedPods {
	m := metricK8sJobFailedPods{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sJobMaxParallelPods struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.job.max_parallel_pods metric with initial data.
func (m *metricK8sJobMaxParallelPods) init() {
	m.data.SetName("k8s.job.max_parallel_pods")
	m.data.SetDescription("The max desired number of pods the job should run at any given time")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sJobMaxParallelPods) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sJobMaxParallelPods) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sJobMaxParallelPods) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sJobMaxParallelPods(cfg MetricConfig) metricK8sJobMaxParallelPods {
	m := metricK8sJobMaxParallelPods{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sJobSuccessfulPods struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.job.successful_pods metric with initial data.
func (m *metricK8sJobSuccessfulPods) init() {
	m.data.SetName("k8s.job.successful_pods")
	m.data.SetDescription("The number of pods which reached phase Succeeded for a job")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sJobSuccessfulPods) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sJobSuccessfulPods) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sJobSuccessfulPods) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sJobSuccessfulPods(cfg MetricConfig) metricK8sJobSuccessfulPods {
	m := metricK8sJobSuccessfulPods{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sNamespacePhase struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.namespace.phase metric with initial data.
func (m *metricK8sNamespacePhase) init() {
	m.data.SetName("k8s.namespace.phase")
	m.data.SetDescription("The current phase of namespaces (1 for active and 0 for terminating)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sNamespacePhase) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sNamespacePhase) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sNamespacePhase) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sNamespacePhase(cfg MetricConfig) metricK8sNamespacePhase {
	m := metricK8sNamespacePhase{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sPodPhase struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.pod.phase metric with initial data.
func (m *metricK8sPodPhase) init() {
	m.data.SetName("k8s.pod.phase")
	m.data.SetDescription("Current phase of the pod (1 - Pending, 2 - Running, 3 - Succeeded, 4 - Failed, 5 - Unknown)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sPodPhase) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sPodPhase) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sPodPhase) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sPodPhase(cfg MetricConfig) metricK8sPodPhase {
	m := metricK8sPodPhase{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sReplicasetAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.replicaset.available metric with initial data.
func (m *metricK8sReplicasetAvailable) init() {
	m.data.SetName("k8s.replicaset.available")
	m.data.SetDescription("Total number of available pods (ready for at least minReadySeconds) targeted by this replicaset")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sReplicasetAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sReplicasetAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sReplicasetAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sReplicasetAvailable(cfg MetricConfig) metricK8sReplicasetAvailable {
	m := metricK8sReplicasetAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sReplicasetDesired struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.replicaset.desired metric with initial data.
func (m *metricK8sReplicasetDesired) init() {
	m.data.SetName("k8s.replicaset.desired")
	m.data.SetDescription("Number of desired pods in this replicaset")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sReplicasetDesired) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sReplicasetDesired) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sReplicasetDesired) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sReplicasetDesired(cfg MetricConfig) metricK8sReplicasetDesired {
	m := metricK8sReplicasetDesired{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sReplicationControllerAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.replication_controller.available metric with initial data.
func (m *metricK8sReplicationControllerAvailable) init() {
	m.data.SetName("k8s.replication_controller.available")
	m.data.SetDescription("Total number of available pods (ready for at least minReadySeconds) targeted by this replication_controller")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sReplicationControllerAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sReplicationControllerAvailable) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sReplicationControllerAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sReplicationControllerAvailable(cfg MetricConfig) metricK8sReplicationControllerAvailable {
	m := metricK8sReplicationControllerAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sReplicationControllerDesired struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.replication_controller.desired metric with initial data.
func (m *metricK8sReplicationControllerDesired) init() {
	m.data.SetName("k8s.replication_controller.desired")
	m.data.SetDescription("Number of desired pods in this replication_controller")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sReplicationControllerDesired) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sReplicationControllerDesired) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sReplicationControllerDesired) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sReplicationControllerDesired(cfg MetricConfig) metricK8sReplicationControllerDesired {
	m := metricK8sReplicationControllerDesired{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sResourceQuotaHardLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.resource_quota.hard_limit metric with initial data.
func (m *metricK8sResourceQuotaHardLimit) init() {
	m.data.SetName("k8s.resource_quota.hard_limit")
	m.data.SetDescription("The upper limit for a particular resource in a specific namespace. Will only be sent if a quota is specified. CPU requests/limits will be sent as millicores")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sResourceQuotaHardLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, resourceAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("resource", resourceAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sResourceQuotaHardLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sResourceQuotaHardLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sResourceQuotaHardLimit(cfg MetricConfig) metricK8sResourceQuotaHardLimit {
	m := metricK8sResourceQuotaHardLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sResourceQuotaUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.resource_quota.used metric with initial data.
func (m *metricK8sResourceQuotaUsed) init() {
	m.data.SetName("k8s.resource_quota.used")
	m.data.SetDescription("The usage for a particular resource in a specific namespace. Will only be sent if a quota is specified. CPU requests/limits will be sent as millicores")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricK8sResourceQuotaUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, resourceAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("resource", resourceAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sResourceQuotaUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sResourceQuotaUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sResourceQuotaUsed(cfg MetricConfig) metricK8sResourceQuotaUsed {
	m := metricK8sResourceQuotaUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sStatefulsetCurrentPods struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.statefulset.current_pods metric with initial data.
func (m *metricK8sStatefulsetCurrentPods) init() {
	m.data.SetName("k8s.statefulset.current_pods")
	m.data.SetDescription("The number of pods created by the StatefulSet controller from the StatefulSet version")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sStatefulsetCurrentPods) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sStatefulsetCurrentPods) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sStatefulsetCurrentPods) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sStatefulsetCurrentPods(cfg MetricConfig) metricK8sStatefulsetCurrentPods {
	m := metricK8sStatefulsetCurrentPods{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sStatefulsetDesiredPods struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.statefulset.desired_pods metric with initial data.
func (m *metricK8sStatefulsetDesiredPods) init() {
	m.data.SetName("k8s.statefulset.desired_pods")
	m.data.SetDescription("Number of desired pods in the stateful set (the `spec.replicas` field)")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sStatefulsetDesiredPods) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sStatefulsetDesiredPods) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sStatefulsetDesiredPods) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sStatefulsetDesiredPods(cfg MetricConfig) metricK8sStatefulsetDesiredPods {
	m := metricK8sStatefulsetDesiredPods{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sStatefulsetReadyPods struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.statefulset.ready_pods metric with initial data.
func (m *metricK8sStatefulsetReadyPods) init() {
	m.data.SetName("k8s.statefulset.ready_pods")
	m.data.SetDescription("Number of pods created by the stateful set that have the `Ready` condition")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sStatefulsetReadyPods) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sStatefulsetReadyPods) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sStatefulsetReadyPods) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sStatefulsetReadyPods(cfg MetricConfig) metricK8sStatefulsetReadyPods {
	m := metricK8sStatefulsetReadyPods{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricK8sStatefulsetUpdatedPods struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills k8s.statefulset.updated_pods metric with initial data.
func (m *metricK8sStatefulsetUpdatedPods) init() {
	m.data.SetName("k8s.statefulset.updated_pods")
	m.data.SetDescription("Number of pods created by the StatefulSet controller from the StatefulSet version")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricK8sStatefulsetUpdatedPods) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricK8sStatefulsetUpdatedPods) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricK8sStatefulsetUpdatedPods) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricK8sStatefulsetUpdatedPods(cfg MetricConfig) metricK8sStatefulsetUpdatedPods {
	m := metricK8sStatefulsetUpdatedPods{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOpenshiftAppliedclusterquotaLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills openshift.appliedclusterquota.limit metric with initial data.
func (m *metricOpenshiftAppliedclusterquotaLimit) init() {
	m.data.SetName("openshift.appliedclusterquota.limit")
	m.data.SetDescription("The upper limit for a particular resource in a specific namespace.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOpenshiftAppliedclusterquotaLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, k8sNamespaceNameAttributeValue string, resourceAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("k8s.namespace.name", k8sNamespaceNameAttributeValue)
	dp.Attributes().PutStr("resource", resourceAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOpenshiftAppliedclusterquotaLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOpenshiftAppliedclusterquotaLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOpenshiftAppliedclusterquotaLimit(cfg MetricConfig) metricOpenshiftAppliedclusterquotaLimit {
	m := metricOpenshiftAppliedclusterquotaLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOpenshiftAppliedclusterquotaUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills openshift.appliedclusterquota.used metric with initial data.
func (m *metricOpenshiftAppliedclusterquotaUsed) init() {
	m.data.SetName("openshift.appliedclusterquota.used")
	m.data.SetDescription("The usage for a particular resource in a specific namespace.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOpenshiftAppliedclusterquotaUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, k8sNamespaceNameAttributeValue string, resourceAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("k8s.namespace.name", k8sNamespaceNameAttributeValue)
	dp.Attributes().PutStr("resource", resourceAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOpenshiftAppliedclusterquotaUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOpenshiftAppliedclusterquotaUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOpenshiftAppliedclusterquotaUsed(cfg MetricConfig) metricOpenshiftAppliedclusterquotaUsed {
	m := metricOpenshiftAppliedclusterquotaUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOpenshiftClusterquotaLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills openshift.clusterquota.limit metric with initial data.
func (m *metricOpenshiftClusterquotaLimit) init() {
	m.data.SetName("openshift.clusterquota.limit")
	m.data.SetDescription("The configured upper limit for a particular resource.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOpenshiftClusterquotaLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, resourceAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("resource", resourceAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOpenshiftClusterquotaLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOpenshiftClusterquotaLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOpenshiftClusterquotaLimit(cfg MetricConfig) metricOpenshiftClusterquotaLimit {
	m := metricOpenshiftClusterquotaLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricOpenshiftClusterquotaUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills openshift.clusterquota.used metric with initial data.
func (m *metricOpenshiftClusterquotaUsed) init() {
	m.data.SetName("openshift.clusterquota.used")
	m.data.SetDescription("The usage for a particular resource with a configured limit.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricOpenshiftClusterquotaUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, resourceAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("resource", resourceAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricOpenshiftClusterquotaUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricOpenshiftClusterquotaUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricOpenshiftClusterquotaUsed(cfg MetricConfig) metricOpenshiftClusterquotaUsed {
	m := metricOpenshiftClusterquotaUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// missedEmitsToDropRMB is number of missed emits after which resource builder will be dropped from MetricsBuilder.rmbMap.
// Potentially, this value can be made configurable through a MetricsBuilder option.
const missedEmitsToDropRMB = 5

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config    MetricsBuilderConfig                 // config of the metrics builder.
	buildInfo component.BuildInfo                  // contains version information
	startTime pcommon.Timestamp                    // start time that will be applied to all recorded data points.
	rmbMap    map[[16]byte]*ResourceMetricsBuilder // map of resource builders by resource hash.
}

type ResourceMetricsBuilder struct {
	buildInfo                                 component.BuildInfo
	startTime                                 pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                           int               // maximum observed number of metrics per resource.
	resource                                  pcommon.Resource
	missedEmits                               int
	metricK8sContainerCPULimit                metricK8sContainerCPULimit
	metricK8sContainerCPURequest              metricK8sContainerCPURequest
	metricK8sContainerEphemeralstorageLimit   metricK8sContainerEphemeralstorageLimit
	metricK8sContainerEphemeralstorageRequest metricK8sContainerEphemeralstorageRequest
	metricK8sContainerMemoryLimit             metricK8sContainerMemoryLimit
	metricK8sContainerMemoryRequest           metricK8sContainerMemoryRequest
	metricK8sContainerReady                   metricK8sContainerReady
	metricK8sContainerRestarts                metricK8sContainerRestarts
	metricK8sContainerStorageLimit            metricK8sContainerStorageLimit
	metricK8sContainerStorageRequest          metricK8sContainerStorageRequest
	metricK8sCronjobActiveJobs                metricK8sCronjobActiveJobs
	metricK8sDaemonsetCurrentScheduledNodes   metricK8sDaemonsetCurrentScheduledNodes
	metricK8sDaemonsetDesiredScheduledNodes   metricK8sDaemonsetDesiredScheduledNodes
	metricK8sDaemonsetMisscheduledNodes       metricK8sDaemonsetMisscheduledNodes
	metricK8sDaemonsetReadyNodes              metricK8sDaemonsetReadyNodes
	metricK8sDeploymentAvailable              metricK8sDeploymentAvailable
	metricK8sDeploymentDesired                metricK8sDeploymentDesired
	metricK8sHpaCurrentReplicas               metricK8sHpaCurrentReplicas
	metricK8sHpaDesiredReplicas               metricK8sHpaDesiredReplicas
	metricK8sHpaMaxReplicas                   metricK8sHpaMaxReplicas
	metricK8sHpaMinReplicas                   metricK8sHpaMinReplicas
	metricK8sJobActivePods                    metricK8sJobActivePods
	metricK8sJobDesiredSuccessfulPods         metricK8sJobDesiredSuccessfulPods
	metricK8sJobFailedPods                    metricK8sJobFailedPods
	metricK8sJobMaxParallelPods               metricK8sJobMaxParallelPods
	metricK8sJobSuccessfulPods                metricK8sJobSuccessfulPods
	metricK8sNamespacePhase                   metricK8sNamespacePhase
	metricK8sPodPhase                         metricK8sPodPhase
	metricK8sReplicasetAvailable              metricK8sReplicasetAvailable
	metricK8sReplicasetDesired                metricK8sReplicasetDesired
	metricK8sReplicationControllerAvailable   metricK8sReplicationControllerAvailable
	metricK8sReplicationControllerDesired     metricK8sReplicationControllerDesired
	metricK8sResourceQuotaHardLimit           metricK8sResourceQuotaHardLimit
	metricK8sResourceQuotaUsed                metricK8sResourceQuotaUsed
	metricK8sStatefulsetCurrentPods           metricK8sStatefulsetCurrentPods
	metricK8sStatefulsetDesiredPods           metricK8sStatefulsetDesiredPods
	metricK8sStatefulsetReadyPods             metricK8sStatefulsetReadyPods
	metricK8sStatefulsetUpdatedPods           metricK8sStatefulsetUpdatedPods
	metricOpenshiftAppliedclusterquotaLimit   metricOpenshiftAppliedclusterquotaLimit
	metricOpenshiftAppliedclusterquotaUsed    metricOpenshiftAppliedclusterquotaUsed
	metricOpenshiftClusterquotaLimit          metricOpenshiftClusterquotaLimit
	metricOpenshiftClusterquotaUsed           metricOpenshiftClusterquotaUsed
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:    mbc,
		startTime: pcommon.NewTimestampFromTime(time.Now()),
		buildInfo: settings.BuildInfo,
		rmbMap:    make(map[[16]byte]*ResourceMetricsBuilder),
	}
	for _, opt := range options {
		opt(mb)
	}
	return mb
}

// resourceMetricsBuilderOption applies changes to provided resource metrics.
type resourceMetricsBuilderOption func(*ResourceMetricsBuilder)

// WithStartTimeOverride sets start time for all the resource metrics data points.
func WithStartTimeOverride(start pcommon.Timestamp) resourceMetricsBuilderOption {
	return func(rmb *ResourceMetricsBuilder) {
		rmb.startTime = start
	}
}

// ResourceMetricsBuilder returns a ResourceMetricsBuilder that can be used to record metrics for a specific resource.
// It requires Resource to be provided which should be built with ResourceBuilder.
func (mb *MetricsBuilder) ResourceMetricsBuilder(res pcommon.Resource, options ...resourceMetricsBuilderOption) *ResourceMetricsBuilder {
	hash := pdatautil.MapHash(res.Attributes())
	if rmb, ok := mb.rmbMap[hash]; ok {
		return rmb
	}
	rmb := &ResourceMetricsBuilder{
		startTime:                               mb.startTime,
		buildInfo:                               mb.buildInfo,
		resource:                                res,
		metricK8sContainerCPULimit:              newMetricK8sContainerCPULimit(mb.config.Metrics.K8sContainerCPULimit),
		metricK8sContainerCPURequest:            newMetricK8sContainerCPURequest(mb.config.Metrics.K8sContainerCPURequest),
		metricK8sContainerEphemeralstorageLimit: newMetricK8sContainerEphemeralstorageLimit(mb.config.Metrics.K8sContainerEphemeralstorageLimit),
		metricK8sContainerEphemeralstorageRequest: newMetricK8sContainerEphemeralstorageRequest(mb.config.Metrics.K8sContainerEphemeralstorageRequest),
		metricK8sContainerMemoryLimit:             newMetricK8sContainerMemoryLimit(mb.config.Metrics.K8sContainerMemoryLimit),
		metricK8sContainerMemoryRequest:           newMetricK8sContainerMemoryRequest(mb.config.Metrics.K8sContainerMemoryRequest),
		metricK8sContainerReady:                   newMetricK8sContainerReady(mb.config.Metrics.K8sContainerReady),
		metricK8sContainerRestarts:                newMetricK8sContainerRestarts(mb.config.Metrics.K8sContainerRestarts),
		metricK8sContainerStorageLimit:            newMetricK8sContainerStorageLimit(mb.config.Metrics.K8sContainerStorageLimit),
		metricK8sContainerStorageRequest:          newMetricK8sContainerStorageRequest(mb.config.Metrics.K8sContainerStorageRequest),
		metricK8sCronjobActiveJobs:                newMetricK8sCronjobActiveJobs(mb.config.Metrics.K8sCronjobActiveJobs),
		metricK8sDaemonsetCurrentScheduledNodes:   newMetricK8sDaemonsetCurrentScheduledNodes(mb.config.Metrics.K8sDaemonsetCurrentScheduledNodes),
		metricK8sDaemonsetDesiredScheduledNodes:   newMetricK8sDaemonsetDesiredScheduledNodes(mb.config.Metrics.K8sDaemonsetDesiredScheduledNodes),
		metricK8sDaemonsetMisscheduledNodes:       newMetricK8sDaemonsetMisscheduledNodes(mb.config.Metrics.K8sDaemonsetMisscheduledNodes),
		metricK8sDaemonsetReadyNodes:              newMetricK8sDaemonsetReadyNodes(mb.config.Metrics.K8sDaemonsetReadyNodes),
		metricK8sDeploymentAvailable:              newMetricK8sDeploymentAvailable(mb.config.Metrics.K8sDeploymentAvailable),
		metricK8sDeploymentDesired:                newMetricK8sDeploymentDesired(mb.config.Metrics.K8sDeploymentDesired),
		metricK8sHpaCurrentReplicas:               newMetricK8sHpaCurrentReplicas(mb.config.Metrics.K8sHpaCurrentReplicas),
		metricK8sHpaDesiredReplicas:               newMetricK8sHpaDesiredReplicas(mb.config.Metrics.K8sHpaDesiredReplicas),
		metricK8sHpaMaxReplicas:                   newMetricK8sHpaMaxReplicas(mb.config.Metrics.K8sHpaMaxReplicas),
		metricK8sHpaMinReplicas:                   newMetricK8sHpaMinReplicas(mb.config.Metrics.K8sHpaMinReplicas),
		metricK8sJobActivePods:                    newMetricK8sJobActivePods(mb.config.Metrics.K8sJobActivePods),
		metricK8sJobDesiredSuccessfulPods:         newMetricK8sJobDesiredSuccessfulPods(mb.config.Metrics.K8sJobDesiredSuccessfulPods),
		metricK8sJobFailedPods:                    newMetricK8sJobFailedPods(mb.config.Metrics.K8sJobFailedPods),
		metricK8sJobMaxParallelPods:               newMetricK8sJobMaxParallelPods(mb.config.Metrics.K8sJobMaxParallelPods),
		metricK8sJobSuccessfulPods:                newMetricK8sJobSuccessfulPods(mb.config.Metrics.K8sJobSuccessfulPods),
		metricK8sNamespacePhase:                   newMetricK8sNamespacePhase(mb.config.Metrics.K8sNamespacePhase),
		metricK8sPodPhase:                         newMetricK8sPodPhase(mb.config.Metrics.K8sPodPhase),
		metricK8sReplicasetAvailable:              newMetricK8sReplicasetAvailable(mb.config.Metrics.K8sReplicasetAvailable),
		metricK8sReplicasetDesired:                newMetricK8sReplicasetDesired(mb.config.Metrics.K8sReplicasetDesired),
		metricK8sReplicationControllerAvailable:   newMetricK8sReplicationControllerAvailable(mb.config.Metrics.K8sReplicationControllerAvailable),
		metricK8sReplicationControllerDesired:     newMetricK8sReplicationControllerDesired(mb.config.Metrics.K8sReplicationControllerDesired),
		metricK8sResourceQuotaHardLimit:           newMetricK8sResourceQuotaHardLimit(mb.config.Metrics.K8sResourceQuotaHardLimit),
		metricK8sResourceQuotaUsed:                newMetricK8sResourceQuotaUsed(mb.config.Metrics.K8sResourceQuotaUsed),
		metricK8sStatefulsetCurrentPods:           newMetricK8sStatefulsetCurrentPods(mb.config.Metrics.K8sStatefulsetCurrentPods),
		metricK8sStatefulsetDesiredPods:           newMetricK8sStatefulsetDesiredPods(mb.config.Metrics.K8sStatefulsetDesiredPods),
		metricK8sStatefulsetReadyPods:             newMetricK8sStatefulsetReadyPods(mb.config.Metrics.K8sStatefulsetReadyPods),
		metricK8sStatefulsetUpdatedPods:           newMetricK8sStatefulsetUpdatedPods(mb.config.Metrics.K8sStatefulsetUpdatedPods),
		metricOpenshiftAppliedclusterquotaLimit:   newMetricOpenshiftAppliedclusterquotaLimit(mb.config.Metrics.OpenshiftAppliedclusterquotaLimit),
		metricOpenshiftAppliedclusterquotaUsed:    newMetricOpenshiftAppliedclusterquotaUsed(mb.config.Metrics.OpenshiftAppliedclusterquotaUsed),
		metricOpenshiftClusterquotaLimit:          newMetricOpenshiftClusterquotaLimit(mb.config.Metrics.OpenshiftClusterquotaLimit),
		metricOpenshiftClusterquotaUsed:           newMetricOpenshiftClusterquotaUsed(mb.config.Metrics.OpenshiftClusterquotaUsed),
	}
	for _, op := range options {
		op(rmb)
	}
	mb.rmbMap[hash] = rmb
	return rmb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (rmb *ResourceMetricsBuilder) updateCapacity(ms pmetric.MetricSlice) {
	if rmb.metricsCapacity < ms.Len() {
		rmb.metricsCapacity = ms.Len()
	}
}

// emit emits all the metrics accumulated by the ResourceMetricsBuilder and updates the internal state to be ready for
// recording another set of metrics. It returns true if any metrics were emitted.
func (rmb *ResourceMetricsBuilder) emit(m pmetric.Metrics) bool {
	sm := pmetric.NewScopeMetrics()
	sm.Metrics().EnsureCapacity(rmb.metricsCapacity)
	rmb.metricK8sContainerCPULimit.emit(sm.Metrics())
	rmb.metricK8sContainerCPURequest.emit(sm.Metrics())
	rmb.metricK8sContainerEphemeralstorageLimit.emit(sm.Metrics())
	rmb.metricK8sContainerEphemeralstorageRequest.emit(sm.Metrics())
	rmb.metricK8sContainerMemoryLimit.emit(sm.Metrics())
	rmb.metricK8sContainerMemoryRequest.emit(sm.Metrics())
	rmb.metricK8sContainerReady.emit(sm.Metrics())
	rmb.metricK8sContainerRestarts.emit(sm.Metrics())
	rmb.metricK8sContainerStorageLimit.emit(sm.Metrics())
	rmb.metricK8sContainerStorageRequest.emit(sm.Metrics())
	rmb.metricK8sCronjobActiveJobs.emit(sm.Metrics())
	rmb.metricK8sDaemonsetCurrentScheduledNodes.emit(sm.Metrics())
	rmb.metricK8sDaemonsetDesiredScheduledNodes.emit(sm.Metrics())
	rmb.metricK8sDaemonsetMisscheduledNodes.emit(sm.Metrics())
	rmb.metricK8sDaemonsetReadyNodes.emit(sm.Metrics())
	rmb.metricK8sDeploymentAvailable.emit(sm.Metrics())
	rmb.metricK8sDeploymentDesired.emit(sm.Metrics())
	rmb.metricK8sHpaCurrentReplicas.emit(sm.Metrics())
	rmb.metricK8sHpaDesiredReplicas.emit(sm.Metrics())
	rmb.metricK8sHpaMaxReplicas.emit(sm.Metrics())
	rmb.metricK8sHpaMinReplicas.emit(sm.Metrics())
	rmb.metricK8sJobActivePods.emit(sm.Metrics())
	rmb.metricK8sJobDesiredSuccessfulPods.emit(sm.Metrics())
	rmb.metricK8sJobFailedPods.emit(sm.Metrics())
	rmb.metricK8sJobMaxParallelPods.emit(sm.Metrics())
	rmb.metricK8sJobSuccessfulPods.emit(sm.Metrics())
	rmb.metricK8sNamespacePhase.emit(sm.Metrics())
	rmb.metricK8sPodPhase.emit(sm.Metrics())
	rmb.metricK8sReplicasetAvailable.emit(sm.Metrics())
	rmb.metricK8sReplicasetDesired.emit(sm.Metrics())
	rmb.metricK8sReplicationControllerAvailable.emit(sm.Metrics())
	rmb.metricK8sReplicationControllerDesired.emit(sm.Metrics())
	rmb.metricK8sResourceQuotaHardLimit.emit(sm.Metrics())
	rmb.metricK8sResourceQuotaUsed.emit(sm.Metrics())
	rmb.metricK8sStatefulsetCurrentPods.emit(sm.Metrics())
	rmb.metricK8sStatefulsetDesiredPods.emit(sm.Metrics())
	rmb.metricK8sStatefulsetReadyPods.emit(sm.Metrics())
	rmb.metricK8sStatefulsetUpdatedPods.emit(sm.Metrics())
	rmb.metricOpenshiftAppliedclusterquotaLimit.emit(sm.Metrics())
	rmb.metricOpenshiftAppliedclusterquotaUsed.emit(sm.Metrics())
	rmb.metricOpenshiftClusterquotaLimit.emit(sm.Metrics())
	rmb.metricOpenshiftClusterquotaUsed.emit(sm.Metrics())
	if sm.Metrics().Len() == 0 {
		return false
	}
	rmb.updateCapacity(sm.Metrics())
	sm.Scope().SetName("otelcol/k8sclusterreceiver")
	sm.Scope().SetVersion(rmb.buildInfo.Version)
	rm := m.ResourceMetrics().AppendEmpty()
	rm.SetSchemaUrl(conventions.SchemaURL)
	rmb.resource.CopyTo(rm.Resource())
	sm.MoveTo(rm.ScopeMetrics().AppendEmpty())
	return true
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit() pmetric.Metrics {
	m := pmetric.NewMetrics()
	for _, rmb := range mb.rmbMap {
		if ok := rmb.emit(m); !ok {
			rmb.missedEmits++
		}
	}
	for k, rmb := range mb.rmbMap {
		if rmb.missedEmits >= missedEmitsToDropRMB {
			delete(mb.rmbMap, k)
		}
	}
	return m
}

// RecordK8sContainerCPULimitDataPoint adds a data point to k8s.container.cpu_limit metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerCPULimitDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricK8sContainerCPULimit.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sContainerCPURequestDataPoint adds a data point to k8s.container.cpu_request metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerCPURequestDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricK8sContainerCPURequest.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sContainerEphemeralstorageLimitDataPoint adds a data point to k8s.container.ephemeralstorage_limit metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerEphemeralstorageLimitDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sContainerEphemeralstorageLimit.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sContainerEphemeralstorageRequestDataPoint adds a data point to k8s.container.ephemeralstorage_request metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerEphemeralstorageRequestDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sContainerEphemeralstorageRequest.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sContainerMemoryLimitDataPoint adds a data point to k8s.container.memory_limit metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerMemoryLimitDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sContainerMemoryLimit.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sContainerMemoryRequestDataPoint adds a data point to k8s.container.memory_request metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerMemoryRequestDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sContainerMemoryRequest.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sContainerReadyDataPoint adds a data point to k8s.container.ready metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerReadyDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sContainerReady.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sContainerRestartsDataPoint adds a data point to k8s.container.restarts metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerRestartsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sContainerRestarts.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sContainerStorageLimitDataPoint adds a data point to k8s.container.storage_limit metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerStorageLimitDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sContainerStorageLimit.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sContainerStorageRequestDataPoint adds a data point to k8s.container.storage_request metric.
func (rmb *ResourceMetricsBuilder) RecordK8sContainerStorageRequestDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sContainerStorageRequest.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sCronjobActiveJobsDataPoint adds a data point to k8s.cronjob.active_jobs metric.
func (rmb *ResourceMetricsBuilder) RecordK8sCronjobActiveJobsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sCronjobActiveJobs.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sDaemonsetCurrentScheduledNodesDataPoint adds a data point to k8s.daemonset.current_scheduled_nodes metric.
func (rmb *ResourceMetricsBuilder) RecordK8sDaemonsetCurrentScheduledNodesDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sDaemonsetCurrentScheduledNodes.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sDaemonsetDesiredScheduledNodesDataPoint adds a data point to k8s.daemonset.desired_scheduled_nodes metric.
func (rmb *ResourceMetricsBuilder) RecordK8sDaemonsetDesiredScheduledNodesDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sDaemonsetDesiredScheduledNodes.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sDaemonsetMisscheduledNodesDataPoint adds a data point to k8s.daemonset.misscheduled_nodes metric.
func (rmb *ResourceMetricsBuilder) RecordK8sDaemonsetMisscheduledNodesDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sDaemonsetMisscheduledNodes.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sDaemonsetReadyNodesDataPoint adds a data point to k8s.daemonset.ready_nodes metric.
func (rmb *ResourceMetricsBuilder) RecordK8sDaemonsetReadyNodesDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sDaemonsetReadyNodes.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sDeploymentAvailableDataPoint adds a data point to k8s.deployment.available metric.
func (rmb *ResourceMetricsBuilder) RecordK8sDeploymentAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sDeploymentAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sDeploymentDesiredDataPoint adds a data point to k8s.deployment.desired metric.
func (rmb *ResourceMetricsBuilder) RecordK8sDeploymentDesiredDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sDeploymentDesired.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sHpaCurrentReplicasDataPoint adds a data point to k8s.hpa.current_replicas metric.
func (rmb *ResourceMetricsBuilder) RecordK8sHpaCurrentReplicasDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sHpaCurrentReplicas.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sHpaDesiredReplicasDataPoint adds a data point to k8s.hpa.desired_replicas metric.
func (rmb *ResourceMetricsBuilder) RecordK8sHpaDesiredReplicasDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sHpaDesiredReplicas.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sHpaMaxReplicasDataPoint adds a data point to k8s.hpa.max_replicas metric.
func (rmb *ResourceMetricsBuilder) RecordK8sHpaMaxReplicasDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sHpaMaxReplicas.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sHpaMinReplicasDataPoint adds a data point to k8s.hpa.min_replicas metric.
func (rmb *ResourceMetricsBuilder) RecordK8sHpaMinReplicasDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sHpaMinReplicas.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sJobActivePodsDataPoint adds a data point to k8s.job.active_pods metric.
func (rmb *ResourceMetricsBuilder) RecordK8sJobActivePodsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sJobActivePods.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sJobDesiredSuccessfulPodsDataPoint adds a data point to k8s.job.desired_successful_pods metric.
func (rmb *ResourceMetricsBuilder) RecordK8sJobDesiredSuccessfulPodsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sJobDesiredSuccessfulPods.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sJobFailedPodsDataPoint adds a data point to k8s.job.failed_pods metric.
func (rmb *ResourceMetricsBuilder) RecordK8sJobFailedPodsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sJobFailedPods.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sJobMaxParallelPodsDataPoint adds a data point to k8s.job.max_parallel_pods metric.
func (rmb *ResourceMetricsBuilder) RecordK8sJobMaxParallelPodsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sJobMaxParallelPods.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sJobSuccessfulPodsDataPoint adds a data point to k8s.job.successful_pods metric.
func (rmb *ResourceMetricsBuilder) RecordK8sJobSuccessfulPodsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sJobSuccessfulPods.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sNamespacePhaseDataPoint adds a data point to k8s.namespace.phase metric.
func (rmb *ResourceMetricsBuilder) RecordK8sNamespacePhaseDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sNamespacePhase.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sPodPhaseDataPoint adds a data point to k8s.pod.phase metric.
func (rmb *ResourceMetricsBuilder) RecordK8sPodPhaseDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sPodPhase.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sReplicasetAvailableDataPoint adds a data point to k8s.replicaset.available metric.
func (rmb *ResourceMetricsBuilder) RecordK8sReplicasetAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sReplicasetAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sReplicasetDesiredDataPoint adds a data point to k8s.replicaset.desired metric.
func (rmb *ResourceMetricsBuilder) RecordK8sReplicasetDesiredDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sReplicasetDesired.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sReplicationControllerAvailableDataPoint adds a data point to k8s.replication_controller.available metric.
func (rmb *ResourceMetricsBuilder) RecordK8sReplicationControllerAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sReplicationControllerAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sReplicationControllerDesiredDataPoint adds a data point to k8s.replication_controller.desired metric.
func (rmb *ResourceMetricsBuilder) RecordK8sReplicationControllerDesiredDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sReplicationControllerDesired.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sResourceQuotaHardLimitDataPoint adds a data point to k8s.resource_quota.hard_limit metric.
func (rmb *ResourceMetricsBuilder) RecordK8sResourceQuotaHardLimitDataPoint(ts pcommon.Timestamp, val int64, resourceAttributeValue string) {
	rmb.metricK8sResourceQuotaHardLimit.recordDataPoint(rmb.startTime, ts, val, resourceAttributeValue)
}

// RecordK8sResourceQuotaUsedDataPoint adds a data point to k8s.resource_quota.used metric.
func (rmb *ResourceMetricsBuilder) RecordK8sResourceQuotaUsedDataPoint(ts pcommon.Timestamp, val int64, resourceAttributeValue string) {
	rmb.metricK8sResourceQuotaUsed.recordDataPoint(rmb.startTime, ts, val, resourceAttributeValue)
}

// RecordK8sStatefulsetCurrentPodsDataPoint adds a data point to k8s.statefulset.current_pods metric.
func (rmb *ResourceMetricsBuilder) RecordK8sStatefulsetCurrentPodsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sStatefulsetCurrentPods.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sStatefulsetDesiredPodsDataPoint adds a data point to k8s.statefulset.desired_pods metric.
func (rmb *ResourceMetricsBuilder) RecordK8sStatefulsetDesiredPodsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sStatefulsetDesiredPods.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sStatefulsetReadyPodsDataPoint adds a data point to k8s.statefulset.ready_pods metric.
func (rmb *ResourceMetricsBuilder) RecordK8sStatefulsetReadyPodsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sStatefulsetReadyPods.recordDataPoint(rmb.startTime, ts, val)
}

// RecordK8sStatefulsetUpdatedPodsDataPoint adds a data point to k8s.statefulset.updated_pods metric.
func (rmb *ResourceMetricsBuilder) RecordK8sStatefulsetUpdatedPodsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricK8sStatefulsetUpdatedPods.recordDataPoint(rmb.startTime, ts, val)
}

// RecordOpenshiftAppliedclusterquotaLimitDataPoint adds a data point to openshift.appliedclusterquota.limit metric.
func (rmb *ResourceMetricsBuilder) RecordOpenshiftAppliedclusterquotaLimitDataPoint(ts pcommon.Timestamp, val int64, k8sNamespaceNameAttributeValue string, resourceAttributeValue string) {
	rmb.metricOpenshiftAppliedclusterquotaLimit.recordDataPoint(rmb.startTime, ts, val, k8sNamespaceNameAttributeValue, resourceAttributeValue)
}

// RecordOpenshiftAppliedclusterquotaUsedDataPoint adds a data point to openshift.appliedclusterquota.used metric.
func (rmb *ResourceMetricsBuilder) RecordOpenshiftAppliedclusterquotaUsedDataPoint(ts pcommon.Timestamp, val int64, k8sNamespaceNameAttributeValue string, resourceAttributeValue string) {
	rmb.metricOpenshiftAppliedclusterquotaUsed.recordDataPoint(rmb.startTime, ts, val, k8sNamespaceNameAttributeValue, resourceAttributeValue)
}

// RecordOpenshiftClusterquotaLimitDataPoint adds a data point to openshift.clusterquota.limit metric.
func (rmb *ResourceMetricsBuilder) RecordOpenshiftClusterquotaLimitDataPoint(ts pcommon.Timestamp, val int64, resourceAttributeValue string) {
	rmb.metricOpenshiftClusterquotaLimit.recordDataPoint(rmb.startTime, ts, val, resourceAttributeValue)
}

// RecordOpenshiftClusterquotaUsedDataPoint adds a data point to openshift.clusterquota.used metric.
func (rmb *ResourceMetricsBuilder) RecordOpenshiftClusterquotaUsedDataPoint(ts pcommon.Timestamp, val int64, resourceAttributeValue string) {
	rmb.metricOpenshiftClusterquotaUsed.recordDataPoint(rmb.startTime, ts, val, resourceAttributeValue)
}

// Reset resets the ResourceMetricsBuilder to its initial state. It should be used when external metrics source is
// restarted, and the ResourceMetricsBuilder should update its startTime and reset it's internal state accordingly.
func (rmb *ResourceMetricsBuilder) Reset(options ...resourceMetricsBuilderOption) {
	rmb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(rmb)
	}
}
