// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"

	"github.com/open-telemetry/opentelemetry-collector-contrib/pkg/pdatautil"
)

// AttributeCacheName specifies the a value cache_name attribute.
type AttributeCacheName int

const (
	_ AttributeCacheName = iota
	AttributeCacheNameFielddata
	AttributeCacheNameQuery
)

// String returns the string representation of the AttributeCacheName.
func (av AttributeCacheName) String() string {
	switch av {
	case AttributeCacheNameFielddata:
		return "fielddata"
	case AttributeCacheNameQuery:
		return "query"
	}
	return ""
}

// MapAttributeCacheName is a helper map of string to AttributeCacheName attribute value.
var MapAttributeCacheName = map[string]AttributeCacheName{
	"fielddata": AttributeCacheNameFielddata,
	"query":     AttributeCacheNameQuery,
}

// AttributeClusterPublishedDifferenceState specifies the a value cluster_published_difference_state attribute.
type AttributeClusterPublishedDifferenceState int

const (
	_ AttributeClusterPublishedDifferenceState = iota
	AttributeClusterPublishedDifferenceStateIncompatible
	AttributeClusterPublishedDifferenceStateCompatible
)

// String returns the string representation of the AttributeClusterPublishedDifferenceState.
func (av AttributeClusterPublishedDifferenceState) String() string {
	switch av {
	case AttributeClusterPublishedDifferenceStateIncompatible:
		return "incompatible"
	case AttributeClusterPublishedDifferenceStateCompatible:
		return "compatible"
	}
	return ""
}

// MapAttributeClusterPublishedDifferenceState is a helper map of string to AttributeClusterPublishedDifferenceState attribute value.
var MapAttributeClusterPublishedDifferenceState = map[string]AttributeClusterPublishedDifferenceState{
	"incompatible": AttributeClusterPublishedDifferenceStateIncompatible,
	"compatible":   AttributeClusterPublishedDifferenceStateCompatible,
}

// AttributeClusterStateQueueState specifies the a value cluster_state_queue_state attribute.
type AttributeClusterStateQueueState int

const (
	_ AttributeClusterStateQueueState = iota
	AttributeClusterStateQueueStatePending
	AttributeClusterStateQueueStateCommitted
)

// String returns the string representation of the AttributeClusterStateQueueState.
func (av AttributeClusterStateQueueState) String() string {
	switch av {
	case AttributeClusterStateQueueStatePending:
		return "pending"
	case AttributeClusterStateQueueStateCommitted:
		return "committed"
	}
	return ""
}

// MapAttributeClusterStateQueueState is a helper map of string to AttributeClusterStateQueueState attribute value.
var MapAttributeClusterStateQueueState = map[string]AttributeClusterStateQueueState{
	"pending":   AttributeClusterStateQueueStatePending,
	"committed": AttributeClusterStateQueueStateCommitted,
}

// AttributeClusterStateUpdateType specifies the a value cluster_state_update_type attribute.
type AttributeClusterStateUpdateType int

const (
	_ AttributeClusterStateUpdateType = iota
	AttributeClusterStateUpdateTypeComputation
	AttributeClusterStateUpdateTypeContextConstruction
	AttributeClusterStateUpdateTypeCommit
	AttributeClusterStateUpdateTypeCompletion
	AttributeClusterStateUpdateTypeMasterApply
	AttributeClusterStateUpdateTypeNotification
)

// String returns the string representation of the AttributeClusterStateUpdateType.
func (av AttributeClusterStateUpdateType) String() string {
	switch av {
	case AttributeClusterStateUpdateTypeComputation:
		return "computation"
	case AttributeClusterStateUpdateTypeContextConstruction:
		return "context_construction"
	case AttributeClusterStateUpdateTypeCommit:
		return "commit"
	case AttributeClusterStateUpdateTypeCompletion:
		return "completion"
	case AttributeClusterStateUpdateTypeMasterApply:
		return "master_apply"
	case AttributeClusterStateUpdateTypeNotification:
		return "notification"
	}
	return ""
}

// MapAttributeClusterStateUpdateType is a helper map of string to AttributeClusterStateUpdateType attribute value.
var MapAttributeClusterStateUpdateType = map[string]AttributeClusterStateUpdateType{
	"computation":          AttributeClusterStateUpdateTypeComputation,
	"context_construction": AttributeClusterStateUpdateTypeContextConstruction,
	"commit":               AttributeClusterStateUpdateTypeCommit,
	"completion":           AttributeClusterStateUpdateTypeCompletion,
	"master_apply":         AttributeClusterStateUpdateTypeMasterApply,
	"notification":         AttributeClusterStateUpdateTypeNotification,
}

// AttributeDirection specifies the a value direction attribute.
type AttributeDirection int

const (
	_ AttributeDirection = iota
	AttributeDirectionReceived
	AttributeDirectionSent
)

// String returns the string representation of the AttributeDirection.
func (av AttributeDirection) String() string {
	switch av {
	case AttributeDirectionReceived:
		return "received"
	case AttributeDirectionSent:
		return "sent"
	}
	return ""
}

// MapAttributeDirection is a helper map of string to AttributeDirection attribute value.
var MapAttributeDirection = map[string]AttributeDirection{
	"received": AttributeDirectionReceived,
	"sent":     AttributeDirectionSent,
}

// AttributeDocumentState specifies the a value document_state attribute.
type AttributeDocumentState int

const (
	_ AttributeDocumentState = iota
	AttributeDocumentStateActive
	AttributeDocumentStateDeleted
)

// String returns the string representation of the AttributeDocumentState.
func (av AttributeDocumentState) String() string {
	switch av {
	case AttributeDocumentStateActive:
		return "active"
	case AttributeDocumentStateDeleted:
		return "deleted"
	}
	return ""
}

// MapAttributeDocumentState is a helper map of string to AttributeDocumentState attribute value.
var MapAttributeDocumentState = map[string]AttributeDocumentState{
	"active":  AttributeDocumentStateActive,
	"deleted": AttributeDocumentStateDeleted,
}

// AttributeGetResult specifies the a value get_result attribute.
type AttributeGetResult int

const (
	_ AttributeGetResult = iota
	AttributeGetResultHit
	AttributeGetResultMiss
)

// String returns the string representation of the AttributeGetResult.
func (av AttributeGetResult) String() string {
	switch av {
	case AttributeGetResultHit:
		return "hit"
	case AttributeGetResultMiss:
		return "miss"
	}
	return ""
}

// MapAttributeGetResult is a helper map of string to AttributeGetResult attribute value.
var MapAttributeGetResult = map[string]AttributeGetResult{
	"hit":  AttributeGetResultHit,
	"miss": AttributeGetResultMiss,
}

// AttributeHealthStatus specifies the a value health_status attribute.
type AttributeHealthStatus int

const (
	_ AttributeHealthStatus = iota
	AttributeHealthStatusGreen
	AttributeHealthStatusYellow
	AttributeHealthStatusRed
)

// String returns the string representation of the AttributeHealthStatus.
func (av AttributeHealthStatus) String() string {
	switch av {
	case AttributeHealthStatusGreen:
		return "green"
	case AttributeHealthStatusYellow:
		return "yellow"
	case AttributeHealthStatusRed:
		return "red"
	}
	return ""
}

// MapAttributeHealthStatus is a helper map of string to AttributeHealthStatus attribute value.
var MapAttributeHealthStatus = map[string]AttributeHealthStatus{
	"green":  AttributeHealthStatusGreen,
	"yellow": AttributeHealthStatusYellow,
	"red":    AttributeHealthStatusRed,
}

// AttributeIndexAggregationType specifies the a value index_aggregation_type attribute.
type AttributeIndexAggregationType int

const (
	_ AttributeIndexAggregationType = iota
	AttributeIndexAggregationTypePrimaryShards
	AttributeIndexAggregationTypeTotal
)

// String returns the string representation of the AttributeIndexAggregationType.
func (av AttributeIndexAggregationType) String() string {
	switch av {
	case AttributeIndexAggregationTypePrimaryShards:
		return "primary_shards"
	case AttributeIndexAggregationTypeTotal:
		return "total"
	}
	return ""
}

// MapAttributeIndexAggregationType is a helper map of string to AttributeIndexAggregationType attribute value.
var MapAttributeIndexAggregationType = map[string]AttributeIndexAggregationType{
	"primary_shards": AttributeIndexAggregationTypePrimaryShards,
	"total":          AttributeIndexAggregationTypeTotal,
}

// AttributeIndexingPressureStage specifies the a value indexing_pressure_stage attribute.
type AttributeIndexingPressureStage int

const (
	_ AttributeIndexingPressureStage = iota
	AttributeIndexingPressureStageCoordinating
	AttributeIndexingPressureStagePrimary
	AttributeIndexingPressureStageReplica
)

// String returns the string representation of the AttributeIndexingPressureStage.
func (av AttributeIndexingPressureStage) String() string {
	switch av {
	case AttributeIndexingPressureStageCoordinating:
		return "coordinating"
	case AttributeIndexingPressureStagePrimary:
		return "primary"
	case AttributeIndexingPressureStageReplica:
		return "replica"
	}
	return ""
}

// MapAttributeIndexingPressureStage is a helper map of string to AttributeIndexingPressureStage attribute value.
var MapAttributeIndexingPressureStage = map[string]AttributeIndexingPressureStage{
	"coordinating": AttributeIndexingPressureStageCoordinating,
	"primary":      AttributeIndexingPressureStagePrimary,
	"replica":      AttributeIndexingPressureStageReplica,
}

// AttributeMemoryState specifies the a value memory_state attribute.
type AttributeMemoryState int

const (
	_ AttributeMemoryState = iota
	AttributeMemoryStateFree
	AttributeMemoryStateUsed
)

// String returns the string representation of the AttributeMemoryState.
func (av AttributeMemoryState) String() string {
	switch av {
	case AttributeMemoryStateFree:
		return "free"
	case AttributeMemoryStateUsed:
		return "used"
	}
	return ""
}

// MapAttributeMemoryState is a helper map of string to AttributeMemoryState attribute value.
var MapAttributeMemoryState = map[string]AttributeMemoryState{
	"free": AttributeMemoryStateFree,
	"used": AttributeMemoryStateUsed,
}

// AttributeOperation specifies the a value operation attribute.
type AttributeOperation int

const (
	_ AttributeOperation = iota
	AttributeOperationIndex
	AttributeOperationDelete
	AttributeOperationGet
	AttributeOperationQuery
	AttributeOperationFetch
	AttributeOperationScroll
	AttributeOperationSuggest
	AttributeOperationMerge
	AttributeOperationRefresh
	AttributeOperationFlush
	AttributeOperationWarmer
)

// String returns the string representation of the AttributeOperation.
func (av AttributeOperation) String() string {
	switch av {
	case AttributeOperationIndex:
		return "index"
	case AttributeOperationDelete:
		return "delete"
	case AttributeOperationGet:
		return "get"
	case AttributeOperationQuery:
		return "query"
	case AttributeOperationFetch:
		return "fetch"
	case AttributeOperationScroll:
		return "scroll"
	case AttributeOperationSuggest:
		return "suggest"
	case AttributeOperationMerge:
		return "merge"
	case AttributeOperationRefresh:
		return "refresh"
	case AttributeOperationFlush:
		return "flush"
	case AttributeOperationWarmer:
		return "warmer"
	}
	return ""
}

// MapAttributeOperation is a helper map of string to AttributeOperation attribute value.
var MapAttributeOperation = map[string]AttributeOperation{
	"index":   AttributeOperationIndex,
	"delete":  AttributeOperationDelete,
	"get":     AttributeOperationGet,
	"query":   AttributeOperationQuery,
	"fetch":   AttributeOperationFetch,
	"scroll":  AttributeOperationScroll,
	"suggest": AttributeOperationSuggest,
	"merge":   AttributeOperationMerge,
	"refresh": AttributeOperationRefresh,
	"flush":   AttributeOperationFlush,
	"warmer":  AttributeOperationWarmer,
}

// AttributeQueryCacheCountType specifies the a value query_cache_count_type attribute.
type AttributeQueryCacheCountType int

const (
	_ AttributeQueryCacheCountType = iota
	AttributeQueryCacheCountTypeHit
	AttributeQueryCacheCountTypeMiss
)

// String returns the string representation of the AttributeQueryCacheCountType.
func (av AttributeQueryCacheCountType) String() string {
	switch av {
	case AttributeQueryCacheCountTypeHit:
		return "hit"
	case AttributeQueryCacheCountTypeMiss:
		return "miss"
	}
	return ""
}

// MapAttributeQueryCacheCountType is a helper map of string to AttributeQueryCacheCountType attribute value.
var MapAttributeQueryCacheCountType = map[string]AttributeQueryCacheCountType{
	"hit":  AttributeQueryCacheCountTypeHit,
	"miss": AttributeQueryCacheCountTypeMiss,
}

// AttributeSegmentsMemoryObjectType specifies the a value segments_memory_object_type attribute.
type AttributeSegmentsMemoryObjectType int

const (
	_ AttributeSegmentsMemoryObjectType = iota
	AttributeSegmentsMemoryObjectTypeTerm
	AttributeSegmentsMemoryObjectTypeDocValue
	AttributeSegmentsMemoryObjectTypeIndexWriter
	AttributeSegmentsMemoryObjectTypeFixedBitSet
)

// String returns the string representation of the AttributeSegmentsMemoryObjectType.
func (av AttributeSegmentsMemoryObjectType) String() string {
	switch av {
	case AttributeSegmentsMemoryObjectTypeTerm:
		return "term"
	case AttributeSegmentsMemoryObjectTypeDocValue:
		return "doc_value"
	case AttributeSegmentsMemoryObjectTypeIndexWriter:
		return "index_writer"
	case AttributeSegmentsMemoryObjectTypeFixedBitSet:
		return "fixed_bit_set"
	}
	return ""
}

// MapAttributeSegmentsMemoryObjectType is a helper map of string to AttributeSegmentsMemoryObjectType attribute value.
var MapAttributeSegmentsMemoryObjectType = map[string]AttributeSegmentsMemoryObjectType{
	"term":          AttributeSegmentsMemoryObjectTypeTerm,
	"doc_value":     AttributeSegmentsMemoryObjectTypeDocValue,
	"index_writer":  AttributeSegmentsMemoryObjectTypeIndexWriter,
	"fixed_bit_set": AttributeSegmentsMemoryObjectTypeFixedBitSet,
}

// AttributeShardState specifies the a value shard_state attribute.
type AttributeShardState int

const (
	_ AttributeShardState = iota
	AttributeShardStateActive
	AttributeShardStateActivePrimary
	AttributeShardStateRelocating
	AttributeShardStateInitializing
	AttributeShardStateUnassigned
	AttributeShardStateUnassignedDelayed
)

// String returns the string representation of the AttributeShardState.
func (av AttributeShardState) String() string {
	switch av {
	case AttributeShardStateActive:
		return "active"
	case AttributeShardStateActivePrimary:
		return "active_primary"
	case AttributeShardStateRelocating:
		return "relocating"
	case AttributeShardStateInitializing:
		return "initializing"
	case AttributeShardStateUnassigned:
		return "unassigned"
	case AttributeShardStateUnassignedDelayed:
		return "unassigned_delayed"
	}
	return ""
}

// MapAttributeShardState is a helper map of string to AttributeShardState attribute value.
var MapAttributeShardState = map[string]AttributeShardState{
	"active":             AttributeShardStateActive,
	"active_primary":     AttributeShardStateActivePrimary,
	"relocating":         AttributeShardStateRelocating,
	"initializing":       AttributeShardStateInitializing,
	"unassigned":         AttributeShardStateUnassigned,
	"unassigned_delayed": AttributeShardStateUnassignedDelayed,
}

// AttributeTaskState specifies the a value task_state attribute.
type AttributeTaskState int

const (
	_ AttributeTaskState = iota
	AttributeTaskStateRejected
	AttributeTaskStateCompleted
)

// String returns the string representation of the AttributeTaskState.
func (av AttributeTaskState) String() string {
	switch av {
	case AttributeTaskStateRejected:
		return "rejected"
	case AttributeTaskStateCompleted:
		return "completed"
	}
	return ""
}

// MapAttributeTaskState is a helper map of string to AttributeTaskState attribute value.
var MapAttributeTaskState = map[string]AttributeTaskState{
	"rejected":  AttributeTaskStateRejected,
	"completed": AttributeTaskStateCompleted,
}

// AttributeThreadState specifies the a value thread_state attribute.
type AttributeThreadState int

const (
	_ AttributeThreadState = iota
	AttributeThreadStateActive
	AttributeThreadStateIdle
)

// String returns the string representation of the AttributeThreadState.
func (av AttributeThreadState) String() string {
	switch av {
	case AttributeThreadStateActive:
		return "active"
	case AttributeThreadStateIdle:
		return "idle"
	}
	return ""
}

// MapAttributeThreadState is a helper map of string to AttributeThreadState attribute value.
var MapAttributeThreadState = map[string]AttributeThreadState{
	"active": AttributeThreadStateActive,
	"idle":   AttributeThreadStateIdle,
}

type metricElasticsearchBreakerMemoryEstimated struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.breaker.memory.estimated metric with initial data.
func (m *metricElasticsearchBreakerMemoryEstimated) init() {
	m.data.SetName("elasticsearch.breaker.memory.estimated")
	m.data.SetDescription("Estimated memory used for the operation.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchBreakerMemoryEstimated) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, circuitBreakerNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", circuitBreakerNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchBreakerMemoryEstimated) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchBreakerMemoryEstimated) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchBreakerMemoryEstimated(cfg MetricConfig) metricElasticsearchBreakerMemoryEstimated {
	m := metricElasticsearchBreakerMemoryEstimated{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchBreakerMemoryLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.breaker.memory.limit metric with initial data.
func (m *metricElasticsearchBreakerMemoryLimit) init() {
	m.data.SetName("elasticsearch.breaker.memory.limit")
	m.data.SetDescription("Memory limit for the circuit breaker.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchBreakerMemoryLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, circuitBreakerNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", circuitBreakerNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchBreakerMemoryLimit) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchBreakerMemoryLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchBreakerMemoryLimit(cfg MetricConfig) metricElasticsearchBreakerMemoryLimit {
	m := metricElasticsearchBreakerMemoryLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchBreakerTripped struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.breaker.tripped metric with initial data.
func (m *metricElasticsearchBreakerTripped) init() {
	m.data.SetName("elasticsearch.breaker.tripped")
	m.data.SetDescription("Total number of times the circuit breaker has been triggered and prevented an out of memory error.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchBreakerTripped) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, circuitBreakerNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", circuitBreakerNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchBreakerTripped) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchBreakerTripped) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchBreakerTripped(cfg MetricConfig) metricElasticsearchBreakerTripped {
	m := metricElasticsearchBreakerTripped{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterDataNodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.data_nodes metric with initial data.
func (m *metricElasticsearchClusterDataNodes) init() {
	m.data.SetName("elasticsearch.cluster.data_nodes")
	m.data.SetDescription("The number of data nodes in the cluster.")
	m.data.SetUnit("{nodes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchClusterDataNodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterDataNodes) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterDataNodes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterDataNodes(cfg MetricConfig) metricElasticsearchClusterDataNodes {
	m := metricElasticsearchClusterDataNodes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterHealth struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.health metric with initial data.
func (m *metricElasticsearchClusterHealth) init() {
	m.data.SetName("elasticsearch.cluster.health")
	m.data.SetDescription("The health status of the cluster.")
	m.data.SetUnit("{status}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchClusterHealth) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, healthStatusAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("status", healthStatusAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterHealth) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterHealth) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterHealth(cfg MetricConfig) metricElasticsearchClusterHealth {
	m := metricElasticsearchClusterHealth{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterInFlightFetch struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.in_flight_fetch metric with initial data.
func (m *metricElasticsearchClusterInFlightFetch) init() {
	m.data.SetName("elasticsearch.cluster.in_flight_fetch")
	m.data.SetDescription("The number of unfinished fetches.")
	m.data.SetUnit("{fetches}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchClusterInFlightFetch) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterInFlightFetch) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterInFlightFetch) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterInFlightFetch(cfg MetricConfig) metricElasticsearchClusterInFlightFetch {
	m := metricElasticsearchClusterInFlightFetch{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterIndicesCacheEvictions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.indices.cache.evictions metric with initial data.
func (m *metricElasticsearchClusterIndicesCacheEvictions) init() {
	m.data.SetName("elasticsearch.cluster.indices.cache.evictions")
	m.data.SetDescription("The number of evictions from the cache for indices in cluster.")
	m.data.SetUnit("{evictions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchClusterIndicesCacheEvictions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, cacheNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("cache_name", cacheNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterIndicesCacheEvictions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterIndicesCacheEvictions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterIndicesCacheEvictions(cfg MetricConfig) metricElasticsearchClusterIndicesCacheEvictions {
	m := metricElasticsearchClusterIndicesCacheEvictions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterNodes struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.nodes metric with initial data.
func (m *metricElasticsearchClusterNodes) init() {
	m.data.SetName("elasticsearch.cluster.nodes")
	m.data.SetDescription("The total number of nodes in the cluster.")
	m.data.SetUnit("{nodes}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchClusterNodes) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterNodes) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterNodes) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterNodes(cfg MetricConfig) metricElasticsearchClusterNodes {
	m := metricElasticsearchClusterNodes{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterPendingTasks struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.pending_tasks metric with initial data.
func (m *metricElasticsearchClusterPendingTasks) init() {
	m.data.SetName("elasticsearch.cluster.pending_tasks")
	m.data.SetDescription("The number of cluster-level changes that have not yet been executed.")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchClusterPendingTasks) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterPendingTasks) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterPendingTasks) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterPendingTasks(cfg MetricConfig) metricElasticsearchClusterPendingTasks {
	m := metricElasticsearchClusterPendingTasks{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterPublishedStatesDifferences struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.published_states.differences metric with initial data.
func (m *metricElasticsearchClusterPublishedStatesDifferences) init() {
	m.data.SetName("elasticsearch.cluster.published_states.differences")
	m.data.SetDescription("Number of differences between published cluster states.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchClusterPublishedStatesDifferences) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, clusterPublishedDifferenceStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", clusterPublishedDifferenceStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterPublishedStatesDifferences) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterPublishedStatesDifferences) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterPublishedStatesDifferences(cfg MetricConfig) metricElasticsearchClusterPublishedStatesDifferences {
	m := metricElasticsearchClusterPublishedStatesDifferences{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterPublishedStatesFull struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.published_states.full metric with initial data.
func (m *metricElasticsearchClusterPublishedStatesFull) init() {
	m.data.SetName("elasticsearch.cluster.published_states.full")
	m.data.SetDescription("Number of published cluster states.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchClusterPublishedStatesFull) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterPublishedStatesFull) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterPublishedStatesFull) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterPublishedStatesFull(cfg MetricConfig) metricElasticsearchClusterPublishedStatesFull {
	m := metricElasticsearchClusterPublishedStatesFull{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterShards struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.shards metric with initial data.
func (m *metricElasticsearchClusterShards) init() {
	m.data.SetName("elasticsearch.cluster.shards")
	m.data.SetDescription("The number of shards in the cluster.")
	m.data.SetUnit("{shards}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchClusterShards) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, shardStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", shardStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterShards) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterShards) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterShards(cfg MetricConfig) metricElasticsearchClusterShards {
	m := metricElasticsearchClusterShards{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterStateQueue struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.state_queue metric with initial data.
func (m *metricElasticsearchClusterStateQueue) init() {
	m.data.SetName("elasticsearch.cluster.state_queue")
	m.data.SetDescription("Number of cluster states in queue.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchClusterStateQueue) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, clusterStateQueueStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", clusterStateQueueStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterStateQueue) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterStateQueue) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterStateQueue(cfg MetricConfig) metricElasticsearchClusterStateQueue {
	m := metricElasticsearchClusterStateQueue{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterStateUpdateCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.state_update.count metric with initial data.
func (m *metricElasticsearchClusterStateUpdateCount) init() {
	m.data.SetName("elasticsearch.cluster.state_update.count")
	m.data.SetDescription("The number of cluster state update attempts that changed the cluster state since the node started.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchClusterStateUpdateCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, clusterStateUpdateStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", clusterStateUpdateStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterStateUpdateCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterStateUpdateCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterStateUpdateCount(cfg MetricConfig) metricElasticsearchClusterStateUpdateCount {
	m := metricElasticsearchClusterStateUpdateCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchClusterStateUpdateTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.cluster.state_update.time metric with initial data.
func (m *metricElasticsearchClusterStateUpdateTime) init() {
	m.data.SetName("elasticsearch.cluster.state_update.time")
	m.data.SetDescription("The cumulative amount of time updating the cluster state since the node started.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchClusterStateUpdateTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, clusterStateUpdateStateAttributeValue string, clusterStateUpdateTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", clusterStateUpdateStateAttributeValue)
	dp.Attributes().PutStr("type", clusterStateUpdateTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchClusterStateUpdateTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchClusterStateUpdateTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchClusterStateUpdateTime(cfg MetricConfig) metricElasticsearchClusterStateUpdateTime {
	m := metricElasticsearchClusterStateUpdateTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexCacheEvictions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.cache.evictions metric with initial data.
func (m *metricElasticsearchIndexCacheEvictions) init() {
	m.data.SetName("elasticsearch.index.cache.evictions")
	m.data.SetDescription("The number of evictions from the cache for an index.")
	m.data.SetUnit("{evictions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexCacheEvictions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, cacheNameAttributeValue string, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("cache_name", cacheNameAttributeValue)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexCacheEvictions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexCacheEvictions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexCacheEvictions(cfg MetricConfig) metricElasticsearchIndexCacheEvictions {
	m := metricElasticsearchIndexCacheEvictions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexCacheMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.cache.memory.usage metric with initial data.
func (m *metricElasticsearchIndexCacheMemoryUsage) init() {
	m.data.SetName("elasticsearch.index.cache.memory.usage")
	m.data.SetDescription("The size in bytes of the cache for an index.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexCacheMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, cacheNameAttributeValue string, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("cache_name", cacheNameAttributeValue)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexCacheMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexCacheMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexCacheMemoryUsage(cfg MetricConfig) metricElasticsearchIndexCacheMemoryUsage {
	m := metricElasticsearchIndexCacheMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexCacheSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.cache.size metric with initial data.
func (m *metricElasticsearchIndexCacheSize) init() {
	m.data.SetName("elasticsearch.index.cache.size")
	m.data.SetDescription("The number of elements of the query cache for an index.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexCacheSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexCacheSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexCacheSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexCacheSize(cfg MetricConfig) metricElasticsearchIndexCacheSize {
	m := metricElasticsearchIndexCacheSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexDocuments struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.documents metric with initial data.
func (m *metricElasticsearchIndexDocuments) init() {
	m.data.SetName("elasticsearch.index.documents")
	m.data.SetDescription("The number of documents for an index.")
	m.data.SetUnit("{documents}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexDocuments) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, documentStateAttributeValue string, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", documentStateAttributeValue)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexDocuments) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexDocuments) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexDocuments(cfg MetricConfig) metricElasticsearchIndexDocuments {
	m := metricElasticsearchIndexDocuments{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexOperationsCompleted struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.operations.completed metric with initial data.
func (m *metricElasticsearchIndexOperationsCompleted) init() {
	m.data.SetName("elasticsearch.index.operations.completed")
	m.data.SetDescription("The number of operations completed for an index.")
	m.data.SetUnit("{operations}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexOperationsCompleted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, operationAttributeValue string, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("operation", operationAttributeValue)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexOperationsCompleted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexOperationsCompleted) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexOperationsCompleted(cfg MetricConfig) metricElasticsearchIndexOperationsCompleted {
	m := metricElasticsearchIndexOperationsCompleted{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexOperationsMergeDocsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.operations.merge.docs_count metric with initial data.
func (m *metricElasticsearchIndexOperationsMergeDocsCount) init() {
	m.data.SetName("elasticsearch.index.operations.merge.docs_count")
	m.data.SetDescription("The total number of documents in merge operations for an index.")
	m.data.SetUnit("{documents}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexOperationsMergeDocsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexOperationsMergeDocsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexOperationsMergeDocsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexOperationsMergeDocsCount(cfg MetricConfig) metricElasticsearchIndexOperationsMergeDocsCount {
	m := metricElasticsearchIndexOperationsMergeDocsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexOperationsMergeSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.operations.merge.size metric with initial data.
func (m *metricElasticsearchIndexOperationsMergeSize) init() {
	m.data.SetName("elasticsearch.index.operations.merge.size")
	m.data.SetDescription("The total size of merged segments for an index.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexOperationsMergeSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexOperationsMergeSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexOperationsMergeSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexOperationsMergeSize(cfg MetricConfig) metricElasticsearchIndexOperationsMergeSize {
	m := metricElasticsearchIndexOperationsMergeSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexOperationsTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.operations.time metric with initial data.
func (m *metricElasticsearchIndexOperationsTime) init() {
	m.data.SetName("elasticsearch.index.operations.time")
	m.data.SetDescription("Time spent on operations for an index.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexOperationsTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, operationAttributeValue string, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("operation", operationAttributeValue)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexOperationsTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexOperationsTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexOperationsTime(cfg MetricConfig) metricElasticsearchIndexOperationsTime {
	m := metricElasticsearchIndexOperationsTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexSegmentsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.segments.count metric with initial data.
func (m *metricElasticsearchIndexSegmentsCount) init() {
	m.data.SetName("elasticsearch.index.segments.count")
	m.data.SetDescription("Number of segments of an index.")
	m.data.SetUnit("{segments}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexSegmentsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexSegmentsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexSegmentsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexSegmentsCount(cfg MetricConfig) metricElasticsearchIndexSegmentsCount {
	m := metricElasticsearchIndexSegmentsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexSegmentsMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.segments.memory metric with initial data.
func (m *metricElasticsearchIndexSegmentsMemory) init() {
	m.data.SetName("elasticsearch.index.segments.memory")
	m.data.SetDescription("Size of memory for segment object of an index.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexSegmentsMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue string, segmentsMemoryObjectTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
	dp.Attributes().PutStr("object", segmentsMemoryObjectTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexSegmentsMemory) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexSegmentsMemory) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexSegmentsMemory(cfg MetricConfig) metricElasticsearchIndexSegmentsMemory {
	m := metricElasticsearchIndexSegmentsMemory{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexSegmentsSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.segments.size metric with initial data.
func (m *metricElasticsearchIndexSegmentsSize) init() {
	m.data.SetName("elasticsearch.index.segments.size")
	m.data.SetDescription("Size of segments of an index.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexSegmentsSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexSegmentsSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexSegmentsSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexSegmentsSize(cfg MetricConfig) metricElasticsearchIndexSegmentsSize {
	m := metricElasticsearchIndexSegmentsSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexShardsSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.shards.size metric with initial data.
func (m *metricElasticsearchIndexShardsSize) init() {
	m.data.SetName("elasticsearch.index.shards.size")
	m.data.SetDescription("The size of the shards assigned to this index.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexShardsSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexShardsSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexShardsSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexShardsSize(cfg MetricConfig) metricElasticsearchIndexShardsSize {
	m := metricElasticsearchIndexShardsSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexTranslogOperations struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.translog.operations metric with initial data.
func (m *metricElasticsearchIndexTranslogOperations) init() {
	m.data.SetName("elasticsearch.index.translog.operations")
	m.data.SetDescription("Number of transaction log operations for an index.")
	m.data.SetUnit("{operations}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexTranslogOperations) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexTranslogOperations) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexTranslogOperations) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexTranslogOperations(cfg MetricConfig) metricElasticsearchIndexTranslogOperations {
	m := metricElasticsearchIndexTranslogOperations{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexTranslogSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.index.translog.size metric with initial data.
func (m *metricElasticsearchIndexTranslogSize) init() {
	m.data.SetName("elasticsearch.index.translog.size")
	m.data.SetDescription("Size of the transaction log for an index.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchIndexTranslogSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("aggregation", indexAggregationTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexTranslogSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexTranslogSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexTranslogSize(cfg MetricConfig) metricElasticsearchIndexTranslogSize {
	m := metricElasticsearchIndexTranslogSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexingPressureMemoryLimit struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.indexing_pressure.memory.limit metric with initial data.
func (m *metricElasticsearchIndexingPressureMemoryLimit) init() {
	m.data.SetName("elasticsearch.indexing_pressure.memory.limit")
	m.data.SetDescription("Configured memory limit, in bytes, for the indexing requests.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricElasticsearchIndexingPressureMemoryLimit) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexingPressureMemoryLimit) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexingPressureMemoryLimit) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexingPressureMemoryLimit(cfg MetricConfig) metricElasticsearchIndexingPressureMemoryLimit {
	m := metricElasticsearchIndexingPressureMemoryLimit{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.indexing_pressure.memory.total.primary_rejections metric with initial data.
func (m *metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections) init() {
	m.data.SetName("elasticsearch.indexing_pressure.memory.total.primary_rejections")
	m.data.SetDescription("Cumulative number of indexing requests rejected in the primary stage.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexingPressureMemoryTotalPrimaryRejections(cfg MetricConfig) metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections {
	m := metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchIndexingPressureMemoryTotalReplicaRejections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.indexing_pressure.memory.total.replica_rejections metric with initial data.
func (m *metricElasticsearchIndexingPressureMemoryTotalReplicaRejections) init() {
	m.data.SetName("elasticsearch.indexing_pressure.memory.total.replica_rejections")
	m.data.SetDescription("Number of indexing requests rejected in the replica stage.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchIndexingPressureMemoryTotalReplicaRejections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchIndexingPressureMemoryTotalReplicaRejections) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchIndexingPressureMemoryTotalReplicaRejections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchIndexingPressureMemoryTotalReplicaRejections(cfg MetricConfig) metricElasticsearchIndexingPressureMemoryTotalReplicaRejections {
	m := metricElasticsearchIndexingPressureMemoryTotalReplicaRejections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchMemoryIndexingPressure struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.memory.indexing_pressure metric with initial data.
func (m *metricElasticsearchMemoryIndexingPressure) init() {
	m.data.SetName("elasticsearch.memory.indexing_pressure")
	m.data.SetDescription("Memory consumed, in bytes, by indexing requests in the specified stage.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchMemoryIndexingPressure) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, indexingPressureStageAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("stage", indexingPressureStageAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchMemoryIndexingPressure) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchMemoryIndexingPressure) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchMemoryIndexingPressure(cfg MetricConfig) metricElasticsearchMemoryIndexingPressure {
	m := metricElasticsearchMemoryIndexingPressure{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeCacheCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cache.count metric with initial data.
func (m *metricElasticsearchNodeCacheCount) init() {
	m.data.SetName("elasticsearch.node.cache.count")
	m.data.SetDescription("Total count of query cache misses across all shards assigned to selected nodes.")
	m.data.SetUnit("{count}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeCacheCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, queryCacheCountTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("type", queryCacheCountTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeCacheCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeCacheCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeCacheCount(cfg MetricConfig) metricElasticsearchNodeCacheCount {
	m := metricElasticsearchNodeCacheCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeCacheEvictions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cache.evictions metric with initial data.
func (m *metricElasticsearchNodeCacheEvictions) init() {
	m.data.SetName("elasticsearch.node.cache.evictions")
	m.data.SetDescription("The number of evictions from the cache on a node.")
	m.data.SetUnit("{evictions}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeCacheEvictions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, cacheNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("cache_name", cacheNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeCacheEvictions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeCacheEvictions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeCacheEvictions(cfg MetricConfig) metricElasticsearchNodeCacheEvictions {
	m := metricElasticsearchNodeCacheEvictions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeCacheMemoryUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cache.memory.usage metric with initial data.
func (m *metricElasticsearchNodeCacheMemoryUsage) init() {
	m.data.SetName("elasticsearch.node.cache.memory.usage")
	m.data.SetDescription("The size in bytes of the cache on a node.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeCacheMemoryUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, cacheNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("cache_name", cacheNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeCacheMemoryUsage) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeCacheMemoryUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeCacheMemoryUsage(cfg MetricConfig) metricElasticsearchNodeCacheMemoryUsage {
	m := metricElasticsearchNodeCacheMemoryUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeCacheSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cache.size metric with initial data.
func (m *metricElasticsearchNodeCacheSize) init() {
	m.data.SetName("elasticsearch.node.cache.size")
	m.data.SetDescription("Total amount of memory used for the query cache across all shards assigned to the node.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeCacheSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeCacheSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeCacheSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeCacheSize(cfg MetricConfig) metricElasticsearchNodeCacheSize {
	m := metricElasticsearchNodeCacheSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeClusterConnections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cluster.connections metric with initial data.
func (m *metricElasticsearchNodeClusterConnections) init() {
	m.data.SetName("elasticsearch.node.cluster.connections")
	m.data.SetDescription("The number of open tcp connections for internal cluster communication.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeClusterConnections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeClusterConnections) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeClusterConnections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeClusterConnections(cfg MetricConfig) metricElasticsearchNodeClusterConnections {
	m := metricElasticsearchNodeClusterConnections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeClusterIo struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.cluster.io metric with initial data.
func (m *metricElasticsearchNodeClusterIo) init() {
	m.data.SetName("elasticsearch.node.cluster.io")
	m.data.SetDescription("The number of bytes sent and received on the network for internal cluster communication.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeClusterIo) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, directionAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("direction", directionAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeClusterIo) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeClusterIo) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeClusterIo(cfg MetricConfig) metricElasticsearchNodeClusterIo {
	m := metricElasticsearchNodeClusterIo{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeDiskIoRead struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.disk.io.read metric with initial data.
func (m *metricElasticsearchNodeDiskIoRead) init() {
	m.data.SetName("elasticsearch.node.disk.io.read")
	m.data.SetDescription("The total number of kilobytes read across all file stores for this node.")
	m.data.SetUnit("KiBy")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeDiskIoRead) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeDiskIoRead) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeDiskIoRead) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeDiskIoRead(cfg MetricConfig) metricElasticsearchNodeDiskIoRead {
	m := metricElasticsearchNodeDiskIoRead{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeDiskIoWrite struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.disk.io.write metric with initial data.
func (m *metricElasticsearchNodeDiskIoWrite) init() {
	m.data.SetName("elasticsearch.node.disk.io.write")
	m.data.SetDescription("The total number of kilobytes written across all file stores for this node.")
	m.data.SetUnit("KiBy")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeDiskIoWrite) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeDiskIoWrite) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeDiskIoWrite) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeDiskIoWrite(cfg MetricConfig) metricElasticsearchNodeDiskIoWrite {
	m := metricElasticsearchNodeDiskIoWrite{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeDocuments struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.documents metric with initial data.
func (m *metricElasticsearchNodeDocuments) init() {
	m.data.SetName("elasticsearch.node.documents")
	m.data.SetDescription("The number of documents on the node.")
	m.data.SetUnit("{documents}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeDocuments) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, documentStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", documentStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeDocuments) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeDocuments) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeDocuments(cfg MetricConfig) metricElasticsearchNodeDocuments {
	m := metricElasticsearchNodeDocuments{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeFsDiskAvailable struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.fs.disk.available metric with initial data.
func (m *metricElasticsearchNodeFsDiskAvailable) init() {
	m.data.SetName("elasticsearch.node.fs.disk.available")
	m.data.SetDescription("The amount of disk space available to the JVM across all file stores for this node. Depending on OS or process level restrictions, this might appear less than free. This is the actual amount of free disk space the Elasticsearch node can utilise.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeFsDiskAvailable) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeFsDiskAvailable) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeFsDiskAvailable) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeFsDiskAvailable(cfg MetricConfig) metricElasticsearchNodeFsDiskAvailable {
	m := metricElasticsearchNodeFsDiskAvailable{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeFsDiskFree struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.fs.disk.free metric with initial data.
func (m *metricElasticsearchNodeFsDiskFree) init() {
	m.data.SetName("elasticsearch.node.fs.disk.free")
	m.data.SetDescription("The amount of unallocated disk space across all file stores for this node.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeFsDiskFree) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeFsDiskFree) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeFsDiskFree) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeFsDiskFree(cfg MetricConfig) metricElasticsearchNodeFsDiskFree {
	m := metricElasticsearchNodeFsDiskFree{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeFsDiskTotal struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.fs.disk.total metric with initial data.
func (m *metricElasticsearchNodeFsDiskTotal) init() {
	m.data.SetName("elasticsearch.node.fs.disk.total")
	m.data.SetDescription("The amount of disk space across all file stores for this node.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeFsDiskTotal) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeFsDiskTotal) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeFsDiskTotal) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeFsDiskTotal(cfg MetricConfig) metricElasticsearchNodeFsDiskTotal {
	m := metricElasticsearchNodeFsDiskTotal{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeHTTPConnections struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.http.connections metric with initial data.
func (m *metricElasticsearchNodeHTTPConnections) init() {
	m.data.SetName("elasticsearch.node.http.connections")
	m.data.SetDescription("The number of HTTP connections to the node.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeHTTPConnections) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeHTTPConnections) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeHTTPConnections) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeHTTPConnections(cfg MetricConfig) metricElasticsearchNodeHTTPConnections {
	m := metricElasticsearchNodeHTTPConnections{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeIngestDocuments struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.ingest.documents metric with initial data.
func (m *metricElasticsearchNodeIngestDocuments) init() {
	m.data.SetName("elasticsearch.node.ingest.documents")
	m.data.SetDescription("Total number of documents ingested during the lifetime of this node.")
	m.data.SetUnit("{documents}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeIngestDocuments) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeIngestDocuments) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeIngestDocuments) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeIngestDocuments(cfg MetricConfig) metricElasticsearchNodeIngestDocuments {
	m := metricElasticsearchNodeIngestDocuments{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeIngestDocumentsCurrent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.ingest.documents.current metric with initial data.
func (m *metricElasticsearchNodeIngestDocumentsCurrent) init() {
	m.data.SetName("elasticsearch.node.ingest.documents.current")
	m.data.SetDescription("Total number of documents currently being ingested.")
	m.data.SetUnit("{documents}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeIngestDocumentsCurrent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeIngestDocumentsCurrent) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeIngestDocumentsCurrent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeIngestDocumentsCurrent(cfg MetricConfig) metricElasticsearchNodeIngestDocumentsCurrent {
	m := metricElasticsearchNodeIngestDocumentsCurrent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeIngestOperationsFailed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.ingest.operations.failed metric with initial data.
func (m *metricElasticsearchNodeIngestOperationsFailed) init() {
	m.data.SetName("elasticsearch.node.ingest.operations.failed")
	m.data.SetDescription("Total number of failed ingest operations during the lifetime of this node.")
	m.data.SetUnit("{operation}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeIngestOperationsFailed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeIngestOperationsFailed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeIngestOperationsFailed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeIngestOperationsFailed(cfg MetricConfig) metricElasticsearchNodeIngestOperationsFailed {
	m := metricElasticsearchNodeIngestOperationsFailed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeOpenFiles struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.open_files metric with initial data.
func (m *metricElasticsearchNodeOpenFiles) init() {
	m.data.SetName("elasticsearch.node.open_files")
	m.data.SetDescription("The number of open file descriptors held by the node.")
	m.data.SetUnit("{files}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeOpenFiles) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeOpenFiles) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeOpenFiles) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeOpenFiles(cfg MetricConfig) metricElasticsearchNodeOpenFiles {
	m := metricElasticsearchNodeOpenFiles{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeOperationsCompleted struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.operations.completed metric with initial data.
func (m *metricElasticsearchNodeOperationsCompleted) init() {
	m.data.SetName("elasticsearch.node.operations.completed")
	m.data.SetDescription("The number of operations completed by a node.")
	m.data.SetUnit("{operations}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeOperationsCompleted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, operationAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("operation", operationAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeOperationsCompleted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeOperationsCompleted) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeOperationsCompleted(cfg MetricConfig) metricElasticsearchNodeOperationsCompleted {
	m := metricElasticsearchNodeOperationsCompleted{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeOperationsCurrent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.operations.current metric with initial data.
func (m *metricElasticsearchNodeOperationsCurrent) init() {
	m.data.SetName("elasticsearch.node.operations.current")
	m.data.SetDescription("Number of query operations currently running.")
	m.data.SetUnit("{operations}")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeOperationsCurrent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, operationAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("operation", operationAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeOperationsCurrent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeOperationsCurrent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeOperationsCurrent(cfg MetricConfig) metricElasticsearchNodeOperationsCurrent {
	m := metricElasticsearchNodeOperationsCurrent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeOperationsGetCompleted struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.operations.get.completed metric with initial data.
func (m *metricElasticsearchNodeOperationsGetCompleted) init() {
	m.data.SetName("elasticsearch.node.operations.get.completed")
	m.data.SetDescription("The number of hits and misses resulting from GET operations.")
	m.data.SetUnit("{operations}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeOperationsGetCompleted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, getResultAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("result", getResultAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeOperationsGetCompleted) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeOperationsGetCompleted) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeOperationsGetCompleted(cfg MetricConfig) metricElasticsearchNodeOperationsGetCompleted {
	m := metricElasticsearchNodeOperationsGetCompleted{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeOperationsGetTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.operations.get.time metric with initial data.
func (m *metricElasticsearchNodeOperationsGetTime) init() {
	m.data.SetName("elasticsearch.node.operations.get.time")
	m.data.SetDescription("The time spent on hits and misses resulting from GET operations.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeOperationsGetTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, getResultAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("result", getResultAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeOperationsGetTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeOperationsGetTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeOperationsGetTime(cfg MetricConfig) metricElasticsearchNodeOperationsGetTime {
	m := metricElasticsearchNodeOperationsGetTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeOperationsTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.operations.time metric with initial data.
func (m *metricElasticsearchNodeOperationsTime) init() {
	m.data.SetName("elasticsearch.node.operations.time")
	m.data.SetDescription("Time spent on operations by a node.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeOperationsTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, operationAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("operation", operationAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeOperationsTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeOperationsTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeOperationsTime(cfg MetricConfig) metricElasticsearchNodeOperationsTime {
	m := metricElasticsearchNodeOperationsTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodePipelineIngestDocumentsCurrent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.pipeline.ingest.documents.current metric with initial data.
func (m *metricElasticsearchNodePipelineIngestDocumentsCurrent) init() {
	m.data.SetName("elasticsearch.node.pipeline.ingest.documents.current")
	m.data.SetDescription("Total number of documents currently being ingested by a pipeline.")
	m.data.SetUnit("{documents}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodePipelineIngestDocumentsCurrent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, ingestPipelineNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", ingestPipelineNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodePipelineIngestDocumentsCurrent) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodePipelineIngestDocumentsCurrent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodePipelineIngestDocumentsCurrent(cfg MetricConfig) metricElasticsearchNodePipelineIngestDocumentsCurrent {
	m := metricElasticsearchNodePipelineIngestDocumentsCurrent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodePipelineIngestDocumentsPreprocessed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.pipeline.ingest.documents.preprocessed metric with initial data.
func (m *metricElasticsearchNodePipelineIngestDocumentsPreprocessed) init() {
	m.data.SetName("elasticsearch.node.pipeline.ingest.documents.preprocessed")
	m.data.SetDescription("Number of documents preprocessed by the ingest pipeline.")
	m.data.SetUnit("{documents}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodePipelineIngestDocumentsPreprocessed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, ingestPipelineNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", ingestPipelineNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodePipelineIngestDocumentsPreprocessed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodePipelineIngestDocumentsPreprocessed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodePipelineIngestDocumentsPreprocessed(cfg MetricConfig) metricElasticsearchNodePipelineIngestDocumentsPreprocessed {
	m := metricElasticsearchNodePipelineIngestDocumentsPreprocessed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodePipelineIngestOperationsFailed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.pipeline.ingest.operations.failed metric with initial data.
func (m *metricElasticsearchNodePipelineIngestOperationsFailed) init() {
	m.data.SetName("elasticsearch.node.pipeline.ingest.operations.failed")
	m.data.SetDescription("Total number of failed operations for the ingest pipeline.")
	m.data.SetUnit("{operation}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodePipelineIngestOperationsFailed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, ingestPipelineNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", ingestPipelineNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodePipelineIngestOperationsFailed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodePipelineIngestOperationsFailed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodePipelineIngestOperationsFailed(cfg MetricConfig) metricElasticsearchNodePipelineIngestOperationsFailed {
	m := metricElasticsearchNodePipelineIngestOperationsFailed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeScriptCacheEvictions struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.script.cache_evictions metric with initial data.
func (m *metricElasticsearchNodeScriptCacheEvictions) init() {
	m.data.SetName("elasticsearch.node.script.cache_evictions")
	m.data.SetDescription("Total number of times the script cache has evicted old data.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeScriptCacheEvictions) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeScriptCacheEvictions) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeScriptCacheEvictions) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeScriptCacheEvictions(cfg MetricConfig) metricElasticsearchNodeScriptCacheEvictions {
	m := metricElasticsearchNodeScriptCacheEvictions{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeScriptCompilationLimitTriggered struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.script.compilation_limit_triggered metric with initial data.
func (m *metricElasticsearchNodeScriptCompilationLimitTriggered) init() {
	m.data.SetName("elasticsearch.node.script.compilation_limit_triggered")
	m.data.SetDescription("Total number of times the script compilation circuit breaker has limited inline script compilations.")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeScriptCompilationLimitTriggered) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeScriptCompilationLimitTriggered) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeScriptCompilationLimitTriggered) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeScriptCompilationLimitTriggered(cfg MetricConfig) metricElasticsearchNodeScriptCompilationLimitTriggered {
	m := metricElasticsearchNodeScriptCompilationLimitTriggered{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeScriptCompilations struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.script.compilations metric with initial data.
func (m *metricElasticsearchNodeScriptCompilations) init() {
	m.data.SetName("elasticsearch.node.script.compilations")
	m.data.SetDescription("Total number of inline script compilations performed by the node.")
	m.data.SetUnit("{compilations}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeScriptCompilations) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeScriptCompilations) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeScriptCompilations) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeScriptCompilations(cfg MetricConfig) metricElasticsearchNodeScriptCompilations {
	m := metricElasticsearchNodeScriptCompilations{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeSegmentsMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.segments.memory metric with initial data.
func (m *metricElasticsearchNodeSegmentsMemory) init() {
	m.data.SetName("elasticsearch.node.segments.memory")
	m.data.SetDescription("Size of memory for segment object of a node.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeSegmentsMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, segmentsMemoryObjectTypeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("object", segmentsMemoryObjectTypeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeSegmentsMemory) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeSegmentsMemory) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeSegmentsMemory(cfg MetricConfig) metricElasticsearchNodeSegmentsMemory {
	m := metricElasticsearchNodeSegmentsMemory{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeShardsDataSetSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.shards.data_set.size metric with initial data.
func (m *metricElasticsearchNodeShardsDataSetSize) init() {
	m.data.SetName("elasticsearch.node.shards.data_set.size")
	m.data.SetDescription("Total data set size of all shards assigned to the node. This includes the size of shards not stored fully on the node, such as the cache for partially mounted indices.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeShardsDataSetSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeShardsDataSetSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeShardsDataSetSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeShardsDataSetSize(cfg MetricConfig) metricElasticsearchNodeShardsDataSetSize {
	m := metricElasticsearchNodeShardsDataSetSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeShardsReservedSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.shards.reserved.size metric with initial data.
func (m *metricElasticsearchNodeShardsReservedSize) init() {
	m.data.SetName("elasticsearch.node.shards.reserved.size")
	m.data.SetDescription("A prediction of how much larger the shard stores on this node will eventually grow due to ongoing peer recoveries, restoring snapshots, and similar activities. A value of -1 indicates that this is not available.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeShardsReservedSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeShardsReservedSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeShardsReservedSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeShardsReservedSize(cfg MetricConfig) metricElasticsearchNodeShardsReservedSize {
	m := metricElasticsearchNodeShardsReservedSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeShardsSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.shards.size metric with initial data.
func (m *metricElasticsearchNodeShardsSize) init() {
	m.data.SetName("elasticsearch.node.shards.size")
	m.data.SetDescription("The size of the shards assigned to this node.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeShardsSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeShardsSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeShardsSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeShardsSize(cfg MetricConfig) metricElasticsearchNodeShardsSize {
	m := metricElasticsearchNodeShardsSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeThreadPoolTasksFinished struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.thread_pool.tasks.finished metric with initial data.
func (m *metricElasticsearchNodeThreadPoolTasksFinished) init() {
	m.data.SetName("elasticsearch.node.thread_pool.tasks.finished")
	m.data.SetDescription("The number of tasks finished by the thread pool.")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeThreadPoolTasksFinished) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, threadPoolNameAttributeValue string, taskStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("thread_pool_name", threadPoolNameAttributeValue)
	dp.Attributes().PutStr("state", taskStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeThreadPoolTasksFinished) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeThreadPoolTasksFinished) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeThreadPoolTasksFinished(cfg MetricConfig) metricElasticsearchNodeThreadPoolTasksFinished {
	m := metricElasticsearchNodeThreadPoolTasksFinished{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeThreadPoolTasksQueued struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.thread_pool.tasks.queued metric with initial data.
func (m *metricElasticsearchNodeThreadPoolTasksQueued) init() {
	m.data.SetName("elasticsearch.node.thread_pool.tasks.queued")
	m.data.SetDescription("The number of queued tasks in the thread pool.")
	m.data.SetUnit("{tasks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeThreadPoolTasksQueued) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, threadPoolNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("thread_pool_name", threadPoolNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeThreadPoolTasksQueued) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeThreadPoolTasksQueued) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeThreadPoolTasksQueued(cfg MetricConfig) metricElasticsearchNodeThreadPoolTasksQueued {
	m := metricElasticsearchNodeThreadPoolTasksQueued{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeThreadPoolThreads struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.thread_pool.threads metric with initial data.
func (m *metricElasticsearchNodeThreadPoolThreads) init() {
	m.data.SetName("elasticsearch.node.thread_pool.threads")
	m.data.SetDescription("The number of threads in the thread pool.")
	m.data.SetUnit("{threads}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchNodeThreadPoolThreads) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, threadPoolNameAttributeValue string, threadStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("thread_pool_name", threadPoolNameAttributeValue)
	dp.Attributes().PutStr("state", threadStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeThreadPoolThreads) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeThreadPoolThreads) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeThreadPoolThreads(cfg MetricConfig) metricElasticsearchNodeThreadPoolThreads {
	m := metricElasticsearchNodeThreadPoolThreads{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeTranslogOperations struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.translog.operations metric with initial data.
func (m *metricElasticsearchNodeTranslogOperations) init() {
	m.data.SetName("elasticsearch.node.translog.operations")
	m.data.SetDescription("Number of transaction log operations.")
	m.data.SetUnit("{operations}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeTranslogOperations) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeTranslogOperations) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeTranslogOperations) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeTranslogOperations(cfg MetricConfig) metricElasticsearchNodeTranslogOperations {
	m := metricElasticsearchNodeTranslogOperations{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeTranslogSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.translog.size metric with initial data.
func (m *metricElasticsearchNodeTranslogSize) init() {
	m.data.SetName("elasticsearch.node.translog.size")
	m.data.SetDescription("Size of the transaction log.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeTranslogSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeTranslogSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeTranslogSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeTranslogSize(cfg MetricConfig) metricElasticsearchNodeTranslogSize {
	m := metricElasticsearchNodeTranslogSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchNodeTranslogUncommittedSize struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.node.translog.uncommitted.size metric with initial data.
func (m *metricElasticsearchNodeTranslogUncommittedSize) init() {
	m.data.SetName("elasticsearch.node.translog.uncommitted.size")
	m.data.SetDescription("Size of uncommitted transaction log operations.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchNodeTranslogUncommittedSize) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchNodeTranslogUncommittedSize) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchNodeTranslogUncommittedSize) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchNodeTranslogUncommittedSize(cfg MetricConfig) metricElasticsearchNodeTranslogUncommittedSize {
	m := metricElasticsearchNodeTranslogUncommittedSize{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchOsCPULoadAvg15m struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.os.cpu.load_avg.15m metric with initial data.
func (m *metricElasticsearchOsCPULoadAvg15m) init() {
	m.data.SetName("elasticsearch.os.cpu.load_avg.15m")
	m.data.SetDescription("Fifteen-minute load average on the system (field is not present if fifteen-minute load average is not available).")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricElasticsearchOsCPULoadAvg15m) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchOsCPULoadAvg15m) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchOsCPULoadAvg15m) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchOsCPULoadAvg15m(cfg MetricConfig) metricElasticsearchOsCPULoadAvg15m {
	m := metricElasticsearchOsCPULoadAvg15m{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchOsCPULoadAvg1m struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.os.cpu.load_avg.1m metric with initial data.
func (m *metricElasticsearchOsCPULoadAvg1m) init() {
	m.data.SetName("elasticsearch.os.cpu.load_avg.1m")
	m.data.SetDescription("One-minute load average on the system (field is not present if one-minute load average is not available).")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricElasticsearchOsCPULoadAvg1m) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchOsCPULoadAvg1m) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchOsCPULoadAvg1m) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchOsCPULoadAvg1m(cfg MetricConfig) metricElasticsearchOsCPULoadAvg1m {
	m := metricElasticsearchOsCPULoadAvg1m{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchOsCPULoadAvg5m struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.os.cpu.load_avg.5m metric with initial data.
func (m *metricElasticsearchOsCPULoadAvg5m) init() {
	m.data.SetName("elasticsearch.os.cpu.load_avg.5m")
	m.data.SetDescription("Five-minute load average on the system (field is not present if five-minute load average is not available).")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricElasticsearchOsCPULoadAvg5m) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchOsCPULoadAvg5m) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchOsCPULoadAvg5m) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchOsCPULoadAvg5m(cfg MetricConfig) metricElasticsearchOsCPULoadAvg5m {
	m := metricElasticsearchOsCPULoadAvg5m{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchOsCPUUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.os.cpu.usage metric with initial data.
func (m *metricElasticsearchOsCPUUsage) init() {
	m.data.SetName("elasticsearch.os.cpu.usage")
	m.data.SetDescription("Recent CPU usage for the whole system, or -1 if not supported.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricElasticsearchOsCPUUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchOsCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchOsCPUUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchOsCPUUsage(cfg MetricConfig) metricElasticsearchOsCPUUsage {
	m := metricElasticsearchOsCPUUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchOsMemory struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.os.memory metric with initial data.
func (m *metricElasticsearchOsMemory) init() {
	m.data.SetName("elasticsearch.os.memory")
	m.data.SetDescription("Amount of physical memory.")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricElasticsearchOsMemory) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, memoryStateAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("state", memoryStateAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchOsMemory) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchOsMemory) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchOsMemory(cfg MetricConfig) metricElasticsearchOsMemory {
	m := metricElasticsearchOsMemory{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchProcessCPUTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.process.cpu.time metric with initial data.
func (m *metricElasticsearchProcessCPUTime) init() {
	m.data.SetName("elasticsearch.process.cpu.time")
	m.data.SetDescription("CPU time used by the process on which the Java virtual machine is running.")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchProcessCPUTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchProcessCPUTime) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchProcessCPUTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchProcessCPUTime(cfg MetricConfig) metricElasticsearchProcessCPUTime {
	m := metricElasticsearchProcessCPUTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchProcessCPUUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.process.cpu.usage metric with initial data.
func (m *metricElasticsearchProcessCPUUsage) init() {
	m.data.SetName("elasticsearch.process.cpu.usage")
	m.data.SetDescription("CPU usage in percent.")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricElasticsearchProcessCPUUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchProcessCPUUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchProcessCPUUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchProcessCPUUsage(cfg MetricConfig) metricElasticsearchProcessCPUUsage {
	m := metricElasticsearchProcessCPUUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricElasticsearchProcessMemoryVirtual struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills elasticsearch.process.memory.virtual metric with initial data.
func (m *metricElasticsearchProcessMemoryVirtual) init() {
	m.data.SetName("elasticsearch.process.memory.virtual")
	m.data.SetDescription("Size of virtual memory that is guaranteed to be available to the running process.")
	m.data.SetUnit("By")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(false)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricElasticsearchProcessMemoryVirtual) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricElasticsearchProcessMemoryVirtual) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricElasticsearchProcessMemoryVirtual) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricElasticsearchProcessMemoryVirtual(cfg MetricConfig) metricElasticsearchProcessMemoryVirtual {
	m := metricElasticsearchProcessMemoryVirtual{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmClassesLoaded struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.classes.loaded metric with initial data.
func (m *metricJvmClassesLoaded) init() {
	m.data.SetName("jvm.classes.loaded")
	m.data.SetDescription("The number of loaded classes")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricJvmClassesLoaded) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmClassesLoaded) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmClassesLoaded) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmClassesLoaded(cfg MetricConfig) metricJvmClassesLoaded {
	m := metricJvmClassesLoaded{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmGcCollectionsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.gc.collections.count metric with initial data.
func (m *metricJvmGcCollectionsCount) init() {
	m.data.SetName("jvm.gc.collections.count")
	m.data.SetDescription("The total number of garbage collections that have occurred")
	m.data.SetUnit("1")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricJvmGcCollectionsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, collectorNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", collectorNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmGcCollectionsCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmGcCollectionsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmGcCollectionsCount(cfg MetricConfig) metricJvmGcCollectionsCount {
	m := metricJvmGcCollectionsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmGcCollectionsElapsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.gc.collections.elapsed metric with initial data.
func (m *metricJvmGcCollectionsElapsed) init() {
	m.data.SetName("jvm.gc.collections.elapsed")
	m.data.SetDescription("The approximate accumulated collection elapsed time")
	m.data.SetUnit("ms")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
	m.data.Sum().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricJvmGcCollectionsElapsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, collectorNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", collectorNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmGcCollectionsElapsed) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmGcCollectionsElapsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmGcCollectionsElapsed(cfg MetricConfig) metricJvmGcCollectionsElapsed {
	m := metricJvmGcCollectionsElapsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmMemoryHeapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.memory.heap.committed metric with initial data.
func (m *metricJvmMemoryHeapCommitted) init() {
	m.data.SetName("jvm.memory.heap.committed")
	m.data.SetDescription("The amount of memory that is guaranteed to be available for the heap")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricJvmMemoryHeapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmMemoryHeapCommitted) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmMemoryHeapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmMemoryHeapCommitted(cfg MetricConfig) metricJvmMemoryHeapCommitted {
	m := metricJvmMemoryHeapCommitted{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmMemoryHeapMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.memory.heap.max metric with initial data.
func (m *metricJvmMemoryHeapMax) init() {
	m.data.SetName("jvm.memory.heap.max")
	m.data.SetDescription("The maximum amount of memory can be used for the heap")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricJvmMemoryHeapMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmMemoryHeapMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmMemoryHeapMax) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmMemoryHeapMax(cfg MetricConfig) metricJvmMemoryHeapMax {
	m := metricJvmMemoryHeapMax{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmMemoryHeapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.memory.heap.used metric with initial data.
func (m *metricJvmMemoryHeapUsed) init() {
	m.data.SetName("jvm.memory.heap.used")
	m.data.SetDescription("The current heap memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricJvmMemoryHeapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmMemoryHeapUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmMemoryHeapUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmMemoryHeapUsed(cfg MetricConfig) metricJvmMemoryHeapUsed {
	m := metricJvmMemoryHeapUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmMemoryHeapUtilization struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.memory.heap.utilization metric with initial data.
func (m *metricJvmMemoryHeapUtilization) init() {
	m.data.SetName("jvm.memory.heap.utilization")
	m.data.SetDescription("Fraction of heap memory usage")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricJvmMemoryHeapUtilization) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmMemoryHeapUtilization) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmMemoryHeapUtilization) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmMemoryHeapUtilization(cfg MetricConfig) metricJvmMemoryHeapUtilization {
	m := metricJvmMemoryHeapUtilization{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmMemoryNonheapCommitted struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.memory.nonheap.committed metric with initial data.
func (m *metricJvmMemoryNonheapCommitted) init() {
	m.data.SetName("jvm.memory.nonheap.committed")
	m.data.SetDescription("The amount of memory that is guaranteed to be available for non-heap purposes")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricJvmMemoryNonheapCommitted) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmMemoryNonheapCommitted) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmMemoryNonheapCommitted) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmMemoryNonheapCommitted(cfg MetricConfig) metricJvmMemoryNonheapCommitted {
	m := metricJvmMemoryNonheapCommitted{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmMemoryNonheapUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.memory.nonheap.used metric with initial data.
func (m *metricJvmMemoryNonheapUsed) init() {
	m.data.SetName("jvm.memory.nonheap.used")
	m.data.SetDescription("The current non-heap memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
}

func (m *metricJvmMemoryNonheapUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmMemoryNonheapUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmMemoryNonheapUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmMemoryNonheapUsed(cfg MetricConfig) metricJvmMemoryNonheapUsed {
	m := metricJvmMemoryNonheapUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmMemoryPoolMax struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.memory.pool.max metric with initial data.
func (m *metricJvmMemoryPoolMax) init() {
	m.data.SetName("jvm.memory.pool.max")
	m.data.SetDescription("The maximum amount of memory can be used for the memory pool")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricJvmMemoryPoolMax) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", memoryPoolNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmMemoryPoolMax) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmMemoryPoolMax) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmMemoryPoolMax(cfg MetricConfig) metricJvmMemoryPoolMax {
	m := metricJvmMemoryPoolMax{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmMemoryPoolUsed struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.memory.pool.used metric with initial data.
func (m *metricJvmMemoryPoolUsed) init() {
	m.data.SetName("jvm.memory.pool.used")
	m.data.SetDescription("The current memory pool memory usage")
	m.data.SetUnit("By")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricJvmMemoryPoolUsed) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("name", memoryPoolNameAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmMemoryPoolUsed) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmMemoryPoolUsed) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmMemoryPoolUsed(cfg MetricConfig) metricJvmMemoryPoolUsed {
	m := metricJvmMemoryPoolUsed{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricJvmThreadsCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills jvm.threads.count metric with initial data.
func (m *metricJvmThreadsCount) init() {
	m.data.SetName("jvm.threads.count")
	m.data.SetDescription("The current number of threads")
	m.data.SetUnit("1")
	m.data.SetEmptyGauge()
}

func (m *metricJvmThreadsCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricJvmThreadsCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricJvmThreadsCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricJvmThreadsCount(cfg MetricConfig) metricJvmThreadsCount {
	m := metricJvmThreadsCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// missedEmitsToDropRMB is number of missed emits after which resource builder will be dropped from MetricsBuilder.rmbMap.
// Potentially, this value can be made configurable through a MetricsBuilder option.
const missedEmitsToDropRMB = 5

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config    MetricsBuilderConfig                 // config of the metrics builder.
	buildInfo component.BuildInfo                  // contains version information
	startTime pcommon.Timestamp                    // start time that will be applied to all recorded data points.
	rmbMap    map[[16]byte]*ResourceMetricsBuilder // map of resource builders by resource hash.
}

type ResourceMetricsBuilder struct {
	buildInfo                                                       component.BuildInfo
	startTime                                                       pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                                                 int               // maximum observed number of metrics per resource.
	resource                                                        pcommon.Resource
	missedEmits                                                     int
	metricElasticsearchBreakerMemoryEstimated                       metricElasticsearchBreakerMemoryEstimated
	metricElasticsearchBreakerMemoryLimit                           metricElasticsearchBreakerMemoryLimit
	metricElasticsearchBreakerTripped                               metricElasticsearchBreakerTripped
	metricElasticsearchClusterDataNodes                             metricElasticsearchClusterDataNodes
	metricElasticsearchClusterHealth                                metricElasticsearchClusterHealth
	metricElasticsearchClusterInFlightFetch                         metricElasticsearchClusterInFlightFetch
	metricElasticsearchClusterIndicesCacheEvictions                 metricElasticsearchClusterIndicesCacheEvictions
	metricElasticsearchClusterNodes                                 metricElasticsearchClusterNodes
	metricElasticsearchClusterPendingTasks                          metricElasticsearchClusterPendingTasks
	metricElasticsearchClusterPublishedStatesDifferences            metricElasticsearchClusterPublishedStatesDifferences
	metricElasticsearchClusterPublishedStatesFull                   metricElasticsearchClusterPublishedStatesFull
	metricElasticsearchClusterShards                                metricElasticsearchClusterShards
	metricElasticsearchClusterStateQueue                            metricElasticsearchClusterStateQueue
	metricElasticsearchClusterStateUpdateCount                      metricElasticsearchClusterStateUpdateCount
	metricElasticsearchClusterStateUpdateTime                       metricElasticsearchClusterStateUpdateTime
	metricElasticsearchIndexCacheEvictions                          metricElasticsearchIndexCacheEvictions
	metricElasticsearchIndexCacheMemoryUsage                        metricElasticsearchIndexCacheMemoryUsage
	metricElasticsearchIndexCacheSize                               metricElasticsearchIndexCacheSize
	metricElasticsearchIndexDocuments                               metricElasticsearchIndexDocuments
	metricElasticsearchIndexOperationsCompleted                     metricElasticsearchIndexOperationsCompleted
	metricElasticsearchIndexOperationsMergeDocsCount                metricElasticsearchIndexOperationsMergeDocsCount
	metricElasticsearchIndexOperationsMergeSize                     metricElasticsearchIndexOperationsMergeSize
	metricElasticsearchIndexOperationsTime                          metricElasticsearchIndexOperationsTime
	metricElasticsearchIndexSegmentsCount                           metricElasticsearchIndexSegmentsCount
	metricElasticsearchIndexSegmentsMemory                          metricElasticsearchIndexSegmentsMemory
	metricElasticsearchIndexSegmentsSize                            metricElasticsearchIndexSegmentsSize
	metricElasticsearchIndexShardsSize                              metricElasticsearchIndexShardsSize
	metricElasticsearchIndexTranslogOperations                      metricElasticsearchIndexTranslogOperations
	metricElasticsearchIndexTranslogSize                            metricElasticsearchIndexTranslogSize
	metricElasticsearchIndexingPressureMemoryLimit                  metricElasticsearchIndexingPressureMemoryLimit
	metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections
	metricElasticsearchIndexingPressureMemoryTotalReplicaRejections metricElasticsearchIndexingPressureMemoryTotalReplicaRejections
	metricElasticsearchMemoryIndexingPressure                       metricElasticsearchMemoryIndexingPressure
	metricElasticsearchNodeCacheCount                               metricElasticsearchNodeCacheCount
	metricElasticsearchNodeCacheEvictions                           metricElasticsearchNodeCacheEvictions
	metricElasticsearchNodeCacheMemoryUsage                         metricElasticsearchNodeCacheMemoryUsage
	metricElasticsearchNodeCacheSize                                metricElasticsearchNodeCacheSize
	metricElasticsearchNodeClusterConnections                       metricElasticsearchNodeClusterConnections
	metricElasticsearchNodeClusterIo                                metricElasticsearchNodeClusterIo
	metricElasticsearchNodeDiskIoRead                               metricElasticsearchNodeDiskIoRead
	metricElasticsearchNodeDiskIoWrite                              metricElasticsearchNodeDiskIoWrite
	metricElasticsearchNodeDocuments                                metricElasticsearchNodeDocuments
	metricElasticsearchNodeFsDiskAvailable                          metricElasticsearchNodeFsDiskAvailable
	metricElasticsearchNodeFsDiskFree                               metricElasticsearchNodeFsDiskFree
	metricElasticsearchNodeFsDiskTotal                              metricElasticsearchNodeFsDiskTotal
	metricElasticsearchNodeHTTPConnections                          metricElasticsearchNodeHTTPConnections
	metricElasticsearchNodeIngestDocuments                          metricElasticsearchNodeIngestDocuments
	metricElasticsearchNodeIngestDocumentsCurrent                   metricElasticsearchNodeIngestDocumentsCurrent
	metricElasticsearchNodeIngestOperationsFailed                   metricElasticsearchNodeIngestOperationsFailed
	metricElasticsearchNodeOpenFiles                                metricElasticsearchNodeOpenFiles
	metricElasticsearchNodeOperationsCompleted                      metricElasticsearchNodeOperationsCompleted
	metricElasticsearchNodeOperationsCurrent                        metricElasticsearchNodeOperationsCurrent
	metricElasticsearchNodeOperationsGetCompleted                   metricElasticsearchNodeOperationsGetCompleted
	metricElasticsearchNodeOperationsGetTime                        metricElasticsearchNodeOperationsGetTime
	metricElasticsearchNodeOperationsTime                           metricElasticsearchNodeOperationsTime
	metricElasticsearchNodePipelineIngestDocumentsCurrent           metricElasticsearchNodePipelineIngestDocumentsCurrent
	metricElasticsearchNodePipelineIngestDocumentsPreprocessed      metricElasticsearchNodePipelineIngestDocumentsPreprocessed
	metricElasticsearchNodePipelineIngestOperationsFailed           metricElasticsearchNodePipelineIngestOperationsFailed
	metricElasticsearchNodeScriptCacheEvictions                     metricElasticsearchNodeScriptCacheEvictions
	metricElasticsearchNodeScriptCompilationLimitTriggered          metricElasticsearchNodeScriptCompilationLimitTriggered
	metricElasticsearchNodeScriptCompilations                       metricElasticsearchNodeScriptCompilations
	metricElasticsearchNodeSegmentsMemory                           metricElasticsearchNodeSegmentsMemory
	metricElasticsearchNodeShardsDataSetSize                        metricElasticsearchNodeShardsDataSetSize
	metricElasticsearchNodeShardsReservedSize                       metricElasticsearchNodeShardsReservedSize
	metricElasticsearchNodeShardsSize                               metricElasticsearchNodeShardsSize
	metricElasticsearchNodeThreadPoolTasksFinished                  metricElasticsearchNodeThreadPoolTasksFinished
	metricElasticsearchNodeThreadPoolTasksQueued                    metricElasticsearchNodeThreadPoolTasksQueued
	metricElasticsearchNodeThreadPoolThreads                        metricElasticsearchNodeThreadPoolThreads
	metricElasticsearchNodeTranslogOperations                       metricElasticsearchNodeTranslogOperations
	metricElasticsearchNodeTranslogSize                             metricElasticsearchNodeTranslogSize
	metricElasticsearchNodeTranslogUncommittedSize                  metricElasticsearchNodeTranslogUncommittedSize
	metricElasticsearchOsCPULoadAvg15m                              metricElasticsearchOsCPULoadAvg15m
	metricElasticsearchOsCPULoadAvg1m                               metricElasticsearchOsCPULoadAvg1m
	metricElasticsearchOsCPULoadAvg5m                               metricElasticsearchOsCPULoadAvg5m
	metricElasticsearchOsCPUUsage                                   metricElasticsearchOsCPUUsage
	metricElasticsearchOsMemory                                     metricElasticsearchOsMemory
	metricElasticsearchProcessCPUTime                               metricElasticsearchProcessCPUTime
	metricElasticsearchProcessCPUUsage                              metricElasticsearchProcessCPUUsage
	metricElasticsearchProcessMemoryVirtual                         metricElasticsearchProcessMemoryVirtual
	metricJvmClassesLoaded                                          metricJvmClassesLoaded
	metricJvmGcCollectionsCount                                     metricJvmGcCollectionsCount
	metricJvmGcCollectionsElapsed                                   metricJvmGcCollectionsElapsed
	metricJvmMemoryHeapCommitted                                    metricJvmMemoryHeapCommitted
	metricJvmMemoryHeapMax                                          metricJvmMemoryHeapMax
	metricJvmMemoryHeapUsed                                         metricJvmMemoryHeapUsed
	metricJvmMemoryHeapUtilization                                  metricJvmMemoryHeapUtilization
	metricJvmMemoryNonheapCommitted                                 metricJvmMemoryNonheapCommitted
	metricJvmMemoryNonheapUsed                                      metricJvmMemoryNonheapUsed
	metricJvmMemoryPoolMax                                          metricJvmMemoryPoolMax
	metricJvmMemoryPoolUsed                                         metricJvmMemoryPoolUsed
	metricJvmThreadsCount                                           metricJvmThreadsCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:    mbc,
		startTime: pcommon.NewTimestampFromTime(time.Now()),
		buildInfo: settings.BuildInfo,
		rmbMap:    make(map[[16]byte]*ResourceMetricsBuilder),
	}
	for _, opt := range options {
		opt(mb)
	}
	return mb
}

// resourceMetricsBuilderOption applies changes to provided resource metrics.
type resourceMetricsBuilderOption func(*ResourceMetricsBuilder)

// WithStartTimeOverride sets start time for all the resource metrics data points.
func WithStartTimeOverride(start pcommon.Timestamp) resourceMetricsBuilderOption {
	return func(rmb *ResourceMetricsBuilder) {
		rmb.startTime = start
	}
}

// ResourceMetricsBuilder returns a ResourceMetricsBuilder that can be used to record metrics for a specific resource.
// It requires Resource to be provided which should be built with ResourceBuilder.
func (mb *MetricsBuilder) ResourceMetricsBuilder(res pcommon.Resource, options ...resourceMetricsBuilderOption) *ResourceMetricsBuilder {
	hash := pdatautil.MapHash(res.Attributes())
	if rmb, ok := mb.rmbMap[hash]; ok {
		return rmb
	}
	rmb := &ResourceMetricsBuilder{
		startTime: mb.startTime,
		buildInfo: mb.buildInfo,
		resource:  res,
		metricElasticsearchBreakerMemoryEstimated:                       newMetricElasticsearchBreakerMemoryEstimated(mb.config.Metrics.ElasticsearchBreakerMemoryEstimated),
		metricElasticsearchBreakerMemoryLimit:                           newMetricElasticsearchBreakerMemoryLimit(mb.config.Metrics.ElasticsearchBreakerMemoryLimit),
		metricElasticsearchBreakerTripped:                               newMetricElasticsearchBreakerTripped(mb.config.Metrics.ElasticsearchBreakerTripped),
		metricElasticsearchClusterDataNodes:                             newMetricElasticsearchClusterDataNodes(mb.config.Metrics.ElasticsearchClusterDataNodes),
		metricElasticsearchClusterHealth:                                newMetricElasticsearchClusterHealth(mb.config.Metrics.ElasticsearchClusterHealth),
		metricElasticsearchClusterInFlightFetch:                         newMetricElasticsearchClusterInFlightFetch(mb.config.Metrics.ElasticsearchClusterInFlightFetch),
		metricElasticsearchClusterIndicesCacheEvictions:                 newMetricElasticsearchClusterIndicesCacheEvictions(mb.config.Metrics.ElasticsearchClusterIndicesCacheEvictions),
		metricElasticsearchClusterNodes:                                 newMetricElasticsearchClusterNodes(mb.config.Metrics.ElasticsearchClusterNodes),
		metricElasticsearchClusterPendingTasks:                          newMetricElasticsearchClusterPendingTasks(mb.config.Metrics.ElasticsearchClusterPendingTasks),
		metricElasticsearchClusterPublishedStatesDifferences:            newMetricElasticsearchClusterPublishedStatesDifferences(mb.config.Metrics.ElasticsearchClusterPublishedStatesDifferences),
		metricElasticsearchClusterPublishedStatesFull:                   newMetricElasticsearchClusterPublishedStatesFull(mb.config.Metrics.ElasticsearchClusterPublishedStatesFull),
		metricElasticsearchClusterShards:                                newMetricElasticsearchClusterShards(mb.config.Metrics.ElasticsearchClusterShards),
		metricElasticsearchClusterStateQueue:                            newMetricElasticsearchClusterStateQueue(mb.config.Metrics.ElasticsearchClusterStateQueue),
		metricElasticsearchClusterStateUpdateCount:                      newMetricElasticsearchClusterStateUpdateCount(mb.config.Metrics.ElasticsearchClusterStateUpdateCount),
		metricElasticsearchClusterStateUpdateTime:                       newMetricElasticsearchClusterStateUpdateTime(mb.config.Metrics.ElasticsearchClusterStateUpdateTime),
		metricElasticsearchIndexCacheEvictions:                          newMetricElasticsearchIndexCacheEvictions(mb.config.Metrics.ElasticsearchIndexCacheEvictions),
		metricElasticsearchIndexCacheMemoryUsage:                        newMetricElasticsearchIndexCacheMemoryUsage(mb.config.Metrics.ElasticsearchIndexCacheMemoryUsage),
		metricElasticsearchIndexCacheSize:                               newMetricElasticsearchIndexCacheSize(mb.config.Metrics.ElasticsearchIndexCacheSize),
		metricElasticsearchIndexDocuments:                               newMetricElasticsearchIndexDocuments(mb.config.Metrics.ElasticsearchIndexDocuments),
		metricElasticsearchIndexOperationsCompleted:                     newMetricElasticsearchIndexOperationsCompleted(mb.config.Metrics.ElasticsearchIndexOperationsCompleted),
		metricElasticsearchIndexOperationsMergeDocsCount:                newMetricElasticsearchIndexOperationsMergeDocsCount(mb.config.Metrics.ElasticsearchIndexOperationsMergeDocsCount),
		metricElasticsearchIndexOperationsMergeSize:                     newMetricElasticsearchIndexOperationsMergeSize(mb.config.Metrics.ElasticsearchIndexOperationsMergeSize),
		metricElasticsearchIndexOperationsTime:                          newMetricElasticsearchIndexOperationsTime(mb.config.Metrics.ElasticsearchIndexOperationsTime),
		metricElasticsearchIndexSegmentsCount:                           newMetricElasticsearchIndexSegmentsCount(mb.config.Metrics.ElasticsearchIndexSegmentsCount),
		metricElasticsearchIndexSegmentsMemory:                          newMetricElasticsearchIndexSegmentsMemory(mb.config.Metrics.ElasticsearchIndexSegmentsMemory),
		metricElasticsearchIndexSegmentsSize:                            newMetricElasticsearchIndexSegmentsSize(mb.config.Metrics.ElasticsearchIndexSegmentsSize),
		metricElasticsearchIndexShardsSize:                              newMetricElasticsearchIndexShardsSize(mb.config.Metrics.ElasticsearchIndexShardsSize),
		metricElasticsearchIndexTranslogOperations:                      newMetricElasticsearchIndexTranslogOperations(mb.config.Metrics.ElasticsearchIndexTranslogOperations),
		metricElasticsearchIndexTranslogSize:                            newMetricElasticsearchIndexTranslogSize(mb.config.Metrics.ElasticsearchIndexTranslogSize),
		metricElasticsearchIndexingPressureMemoryLimit:                  newMetricElasticsearchIndexingPressureMemoryLimit(mb.config.Metrics.ElasticsearchIndexingPressureMemoryLimit),
		metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections: newMetricElasticsearchIndexingPressureMemoryTotalPrimaryRejections(mb.config.Metrics.ElasticsearchIndexingPressureMemoryTotalPrimaryRejections),
		metricElasticsearchIndexingPressureMemoryTotalReplicaRejections: newMetricElasticsearchIndexingPressureMemoryTotalReplicaRejections(mb.config.Metrics.ElasticsearchIndexingPressureMemoryTotalReplicaRejections),
		metricElasticsearchMemoryIndexingPressure:                       newMetricElasticsearchMemoryIndexingPressure(mb.config.Metrics.ElasticsearchMemoryIndexingPressure),
		metricElasticsearchNodeCacheCount:                               newMetricElasticsearchNodeCacheCount(mb.config.Metrics.ElasticsearchNodeCacheCount),
		metricElasticsearchNodeCacheEvictions:                           newMetricElasticsearchNodeCacheEvictions(mb.config.Metrics.ElasticsearchNodeCacheEvictions),
		metricElasticsearchNodeCacheMemoryUsage:                         newMetricElasticsearchNodeCacheMemoryUsage(mb.config.Metrics.ElasticsearchNodeCacheMemoryUsage),
		metricElasticsearchNodeCacheSize:                                newMetricElasticsearchNodeCacheSize(mb.config.Metrics.ElasticsearchNodeCacheSize),
		metricElasticsearchNodeClusterConnections:                       newMetricElasticsearchNodeClusterConnections(mb.config.Metrics.ElasticsearchNodeClusterConnections),
		metricElasticsearchNodeClusterIo:                                newMetricElasticsearchNodeClusterIo(mb.config.Metrics.ElasticsearchNodeClusterIo),
		metricElasticsearchNodeDiskIoRead:                               newMetricElasticsearchNodeDiskIoRead(mb.config.Metrics.ElasticsearchNodeDiskIoRead),
		metricElasticsearchNodeDiskIoWrite:                              newMetricElasticsearchNodeDiskIoWrite(mb.config.Metrics.ElasticsearchNodeDiskIoWrite),
		metricElasticsearchNodeDocuments:                                newMetricElasticsearchNodeDocuments(mb.config.Metrics.ElasticsearchNodeDocuments),
		metricElasticsearchNodeFsDiskAvailable:                          newMetricElasticsearchNodeFsDiskAvailable(mb.config.Metrics.ElasticsearchNodeFsDiskAvailable),
		metricElasticsearchNodeFsDiskFree:                               newMetricElasticsearchNodeFsDiskFree(mb.config.Metrics.ElasticsearchNodeFsDiskFree),
		metricElasticsearchNodeFsDiskTotal:                              newMetricElasticsearchNodeFsDiskTotal(mb.config.Metrics.ElasticsearchNodeFsDiskTotal),
		metricElasticsearchNodeHTTPConnections:                          newMetricElasticsearchNodeHTTPConnections(mb.config.Metrics.ElasticsearchNodeHTTPConnections),
		metricElasticsearchNodeIngestDocuments:                          newMetricElasticsearchNodeIngestDocuments(mb.config.Metrics.ElasticsearchNodeIngestDocuments),
		metricElasticsearchNodeIngestDocumentsCurrent:                   newMetricElasticsearchNodeIngestDocumentsCurrent(mb.config.Metrics.ElasticsearchNodeIngestDocumentsCurrent),
		metricElasticsearchNodeIngestOperationsFailed:                   newMetricElasticsearchNodeIngestOperationsFailed(mb.config.Metrics.ElasticsearchNodeIngestOperationsFailed),
		metricElasticsearchNodeOpenFiles:                                newMetricElasticsearchNodeOpenFiles(mb.config.Metrics.ElasticsearchNodeOpenFiles),
		metricElasticsearchNodeOperationsCompleted:                      newMetricElasticsearchNodeOperationsCompleted(mb.config.Metrics.ElasticsearchNodeOperationsCompleted),
		metricElasticsearchNodeOperationsCurrent:                        newMetricElasticsearchNodeOperationsCurrent(mb.config.Metrics.ElasticsearchNodeOperationsCurrent),
		metricElasticsearchNodeOperationsGetCompleted:                   newMetricElasticsearchNodeOperationsGetCompleted(mb.config.Metrics.ElasticsearchNodeOperationsGetCompleted),
		metricElasticsearchNodeOperationsGetTime:                        newMetricElasticsearchNodeOperationsGetTime(mb.config.Metrics.ElasticsearchNodeOperationsGetTime),
		metricElasticsearchNodeOperationsTime:                           newMetricElasticsearchNodeOperationsTime(mb.config.Metrics.ElasticsearchNodeOperationsTime),
		metricElasticsearchNodePipelineIngestDocumentsCurrent:           newMetricElasticsearchNodePipelineIngestDocumentsCurrent(mb.config.Metrics.ElasticsearchNodePipelineIngestDocumentsCurrent),
		metricElasticsearchNodePipelineIngestDocumentsPreprocessed:      newMetricElasticsearchNodePipelineIngestDocumentsPreprocessed(mb.config.Metrics.ElasticsearchNodePipelineIngestDocumentsPreprocessed),
		metricElasticsearchNodePipelineIngestOperationsFailed:           newMetricElasticsearchNodePipelineIngestOperationsFailed(mb.config.Metrics.ElasticsearchNodePipelineIngestOperationsFailed),
		metricElasticsearchNodeScriptCacheEvictions:                     newMetricElasticsearchNodeScriptCacheEvictions(mb.config.Metrics.ElasticsearchNodeScriptCacheEvictions),
		metricElasticsearchNodeScriptCompilationLimitTriggered:          newMetricElasticsearchNodeScriptCompilationLimitTriggered(mb.config.Metrics.ElasticsearchNodeScriptCompilationLimitTriggered),
		metricElasticsearchNodeScriptCompilations:                       newMetricElasticsearchNodeScriptCompilations(mb.config.Metrics.ElasticsearchNodeScriptCompilations),
		metricElasticsearchNodeSegmentsMemory:                           newMetricElasticsearchNodeSegmentsMemory(mb.config.Metrics.ElasticsearchNodeSegmentsMemory),
		metricElasticsearchNodeShardsDataSetSize:                        newMetricElasticsearchNodeShardsDataSetSize(mb.config.Metrics.ElasticsearchNodeShardsDataSetSize),
		metricElasticsearchNodeShardsReservedSize:                       newMetricElasticsearchNodeShardsReservedSize(mb.config.Metrics.ElasticsearchNodeShardsReservedSize),
		metricElasticsearchNodeShardsSize:                               newMetricElasticsearchNodeShardsSize(mb.config.Metrics.ElasticsearchNodeShardsSize),
		metricElasticsearchNodeThreadPoolTasksFinished:                  newMetricElasticsearchNodeThreadPoolTasksFinished(mb.config.Metrics.ElasticsearchNodeThreadPoolTasksFinished),
		metricElasticsearchNodeThreadPoolTasksQueued:                    newMetricElasticsearchNodeThreadPoolTasksQueued(mb.config.Metrics.ElasticsearchNodeThreadPoolTasksQueued),
		metricElasticsearchNodeThreadPoolThreads:                        newMetricElasticsearchNodeThreadPoolThreads(mb.config.Metrics.ElasticsearchNodeThreadPoolThreads),
		metricElasticsearchNodeTranslogOperations:                       newMetricElasticsearchNodeTranslogOperations(mb.config.Metrics.ElasticsearchNodeTranslogOperations),
		metricElasticsearchNodeTranslogSize:                             newMetricElasticsearchNodeTranslogSize(mb.config.Metrics.ElasticsearchNodeTranslogSize),
		metricElasticsearchNodeTranslogUncommittedSize:                  newMetricElasticsearchNodeTranslogUncommittedSize(mb.config.Metrics.ElasticsearchNodeTranslogUncommittedSize),
		metricElasticsearchOsCPULoadAvg15m:                              newMetricElasticsearchOsCPULoadAvg15m(mb.config.Metrics.ElasticsearchOsCPULoadAvg15m),
		metricElasticsearchOsCPULoadAvg1m:                               newMetricElasticsearchOsCPULoadAvg1m(mb.config.Metrics.ElasticsearchOsCPULoadAvg1m),
		metricElasticsearchOsCPULoadAvg5m:                               newMetricElasticsearchOsCPULoadAvg5m(mb.config.Metrics.ElasticsearchOsCPULoadAvg5m),
		metricElasticsearchOsCPUUsage:                                   newMetricElasticsearchOsCPUUsage(mb.config.Metrics.ElasticsearchOsCPUUsage),
		metricElasticsearchOsMemory:                                     newMetricElasticsearchOsMemory(mb.config.Metrics.ElasticsearchOsMemory),
		metricElasticsearchProcessCPUTime:                               newMetricElasticsearchProcessCPUTime(mb.config.Metrics.ElasticsearchProcessCPUTime),
		metricElasticsearchProcessCPUUsage:                              newMetricElasticsearchProcessCPUUsage(mb.config.Metrics.ElasticsearchProcessCPUUsage),
		metricElasticsearchProcessMemoryVirtual:                         newMetricElasticsearchProcessMemoryVirtual(mb.config.Metrics.ElasticsearchProcessMemoryVirtual),
		metricJvmClassesLoaded:                                          newMetricJvmClassesLoaded(mb.config.Metrics.JvmClassesLoaded),
		metricJvmGcCollectionsCount:                                     newMetricJvmGcCollectionsCount(mb.config.Metrics.JvmGcCollectionsCount),
		metricJvmGcCollectionsElapsed:                                   newMetricJvmGcCollectionsElapsed(mb.config.Metrics.JvmGcCollectionsElapsed),
		metricJvmMemoryHeapCommitted:                                    newMetricJvmMemoryHeapCommitted(mb.config.Metrics.JvmMemoryHeapCommitted),
		metricJvmMemoryHeapMax:                                          newMetricJvmMemoryHeapMax(mb.config.Metrics.JvmMemoryHeapMax),
		metricJvmMemoryHeapUsed:                                         newMetricJvmMemoryHeapUsed(mb.config.Metrics.JvmMemoryHeapUsed),
		metricJvmMemoryHeapUtilization:                                  newMetricJvmMemoryHeapUtilization(mb.config.Metrics.JvmMemoryHeapUtilization),
		metricJvmMemoryNonheapCommitted:                                 newMetricJvmMemoryNonheapCommitted(mb.config.Metrics.JvmMemoryNonheapCommitted),
		metricJvmMemoryNonheapUsed:                                      newMetricJvmMemoryNonheapUsed(mb.config.Metrics.JvmMemoryNonheapUsed),
		metricJvmMemoryPoolMax:                                          newMetricJvmMemoryPoolMax(mb.config.Metrics.JvmMemoryPoolMax),
		metricJvmMemoryPoolUsed:                                         newMetricJvmMemoryPoolUsed(mb.config.Metrics.JvmMemoryPoolUsed),
		metricJvmThreadsCount:                                           newMetricJvmThreadsCount(mb.config.Metrics.JvmThreadsCount),
	}
	for _, op := range options {
		op(rmb)
	}
	mb.rmbMap[hash] = rmb
	return rmb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (rmb *ResourceMetricsBuilder) updateCapacity(ms pmetric.MetricSlice) {
	if rmb.metricsCapacity < ms.Len() {
		rmb.metricsCapacity = ms.Len()
	}
}

// emit emits all the metrics accumulated by the ResourceMetricsBuilder and updates the internal state to be ready for
// recording another set of metrics. It returns true if any metrics were emitted.
func (rmb *ResourceMetricsBuilder) emit(m pmetric.Metrics) bool {
	sm := pmetric.NewScopeMetrics()
	sm.Metrics().EnsureCapacity(rmb.metricsCapacity)
	rmb.metricElasticsearchBreakerMemoryEstimated.emit(sm.Metrics())
	rmb.metricElasticsearchBreakerMemoryLimit.emit(sm.Metrics())
	rmb.metricElasticsearchBreakerTripped.emit(sm.Metrics())
	rmb.metricElasticsearchClusterDataNodes.emit(sm.Metrics())
	rmb.metricElasticsearchClusterHealth.emit(sm.Metrics())
	rmb.metricElasticsearchClusterInFlightFetch.emit(sm.Metrics())
	rmb.metricElasticsearchClusterIndicesCacheEvictions.emit(sm.Metrics())
	rmb.metricElasticsearchClusterNodes.emit(sm.Metrics())
	rmb.metricElasticsearchClusterPendingTasks.emit(sm.Metrics())
	rmb.metricElasticsearchClusterPublishedStatesDifferences.emit(sm.Metrics())
	rmb.metricElasticsearchClusterPublishedStatesFull.emit(sm.Metrics())
	rmb.metricElasticsearchClusterShards.emit(sm.Metrics())
	rmb.metricElasticsearchClusterStateQueue.emit(sm.Metrics())
	rmb.metricElasticsearchClusterStateUpdateCount.emit(sm.Metrics())
	rmb.metricElasticsearchClusterStateUpdateTime.emit(sm.Metrics())
	rmb.metricElasticsearchIndexCacheEvictions.emit(sm.Metrics())
	rmb.metricElasticsearchIndexCacheMemoryUsage.emit(sm.Metrics())
	rmb.metricElasticsearchIndexCacheSize.emit(sm.Metrics())
	rmb.metricElasticsearchIndexDocuments.emit(sm.Metrics())
	rmb.metricElasticsearchIndexOperationsCompleted.emit(sm.Metrics())
	rmb.metricElasticsearchIndexOperationsMergeDocsCount.emit(sm.Metrics())
	rmb.metricElasticsearchIndexOperationsMergeSize.emit(sm.Metrics())
	rmb.metricElasticsearchIndexOperationsTime.emit(sm.Metrics())
	rmb.metricElasticsearchIndexSegmentsCount.emit(sm.Metrics())
	rmb.metricElasticsearchIndexSegmentsMemory.emit(sm.Metrics())
	rmb.metricElasticsearchIndexSegmentsSize.emit(sm.Metrics())
	rmb.metricElasticsearchIndexShardsSize.emit(sm.Metrics())
	rmb.metricElasticsearchIndexTranslogOperations.emit(sm.Metrics())
	rmb.metricElasticsearchIndexTranslogSize.emit(sm.Metrics())
	rmb.metricElasticsearchIndexingPressureMemoryLimit.emit(sm.Metrics())
	rmb.metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections.emit(sm.Metrics())
	rmb.metricElasticsearchIndexingPressureMemoryTotalReplicaRejections.emit(sm.Metrics())
	rmb.metricElasticsearchMemoryIndexingPressure.emit(sm.Metrics())
	rmb.metricElasticsearchNodeCacheCount.emit(sm.Metrics())
	rmb.metricElasticsearchNodeCacheEvictions.emit(sm.Metrics())
	rmb.metricElasticsearchNodeCacheMemoryUsage.emit(sm.Metrics())
	rmb.metricElasticsearchNodeCacheSize.emit(sm.Metrics())
	rmb.metricElasticsearchNodeClusterConnections.emit(sm.Metrics())
	rmb.metricElasticsearchNodeClusterIo.emit(sm.Metrics())
	rmb.metricElasticsearchNodeDiskIoRead.emit(sm.Metrics())
	rmb.metricElasticsearchNodeDiskIoWrite.emit(sm.Metrics())
	rmb.metricElasticsearchNodeDocuments.emit(sm.Metrics())
	rmb.metricElasticsearchNodeFsDiskAvailable.emit(sm.Metrics())
	rmb.metricElasticsearchNodeFsDiskFree.emit(sm.Metrics())
	rmb.metricElasticsearchNodeFsDiskTotal.emit(sm.Metrics())
	rmb.metricElasticsearchNodeHTTPConnections.emit(sm.Metrics())
	rmb.metricElasticsearchNodeIngestDocuments.emit(sm.Metrics())
	rmb.metricElasticsearchNodeIngestDocumentsCurrent.emit(sm.Metrics())
	rmb.metricElasticsearchNodeIngestOperationsFailed.emit(sm.Metrics())
	rmb.metricElasticsearchNodeOpenFiles.emit(sm.Metrics())
	rmb.metricElasticsearchNodeOperationsCompleted.emit(sm.Metrics())
	rmb.metricElasticsearchNodeOperationsCurrent.emit(sm.Metrics())
	rmb.metricElasticsearchNodeOperationsGetCompleted.emit(sm.Metrics())
	rmb.metricElasticsearchNodeOperationsGetTime.emit(sm.Metrics())
	rmb.metricElasticsearchNodeOperationsTime.emit(sm.Metrics())
	rmb.metricElasticsearchNodePipelineIngestDocumentsCurrent.emit(sm.Metrics())
	rmb.metricElasticsearchNodePipelineIngestDocumentsPreprocessed.emit(sm.Metrics())
	rmb.metricElasticsearchNodePipelineIngestOperationsFailed.emit(sm.Metrics())
	rmb.metricElasticsearchNodeScriptCacheEvictions.emit(sm.Metrics())
	rmb.metricElasticsearchNodeScriptCompilationLimitTriggered.emit(sm.Metrics())
	rmb.metricElasticsearchNodeScriptCompilations.emit(sm.Metrics())
	rmb.metricElasticsearchNodeSegmentsMemory.emit(sm.Metrics())
	rmb.metricElasticsearchNodeShardsDataSetSize.emit(sm.Metrics())
	rmb.metricElasticsearchNodeShardsReservedSize.emit(sm.Metrics())
	rmb.metricElasticsearchNodeShardsSize.emit(sm.Metrics())
	rmb.metricElasticsearchNodeThreadPoolTasksFinished.emit(sm.Metrics())
	rmb.metricElasticsearchNodeThreadPoolTasksQueued.emit(sm.Metrics())
	rmb.metricElasticsearchNodeThreadPoolThreads.emit(sm.Metrics())
	rmb.metricElasticsearchNodeTranslogOperations.emit(sm.Metrics())
	rmb.metricElasticsearchNodeTranslogSize.emit(sm.Metrics())
	rmb.metricElasticsearchNodeTranslogUncommittedSize.emit(sm.Metrics())
	rmb.metricElasticsearchOsCPULoadAvg15m.emit(sm.Metrics())
	rmb.metricElasticsearchOsCPULoadAvg1m.emit(sm.Metrics())
	rmb.metricElasticsearchOsCPULoadAvg5m.emit(sm.Metrics())
	rmb.metricElasticsearchOsCPUUsage.emit(sm.Metrics())
	rmb.metricElasticsearchOsMemory.emit(sm.Metrics())
	rmb.metricElasticsearchProcessCPUTime.emit(sm.Metrics())
	rmb.metricElasticsearchProcessCPUUsage.emit(sm.Metrics())
	rmb.metricElasticsearchProcessMemoryVirtual.emit(sm.Metrics())
	rmb.metricJvmClassesLoaded.emit(sm.Metrics())
	rmb.metricJvmGcCollectionsCount.emit(sm.Metrics())
	rmb.metricJvmGcCollectionsElapsed.emit(sm.Metrics())
	rmb.metricJvmMemoryHeapCommitted.emit(sm.Metrics())
	rmb.metricJvmMemoryHeapMax.emit(sm.Metrics())
	rmb.metricJvmMemoryHeapUsed.emit(sm.Metrics())
	rmb.metricJvmMemoryHeapUtilization.emit(sm.Metrics())
	rmb.metricJvmMemoryNonheapCommitted.emit(sm.Metrics())
	rmb.metricJvmMemoryNonheapUsed.emit(sm.Metrics())
	rmb.metricJvmMemoryPoolMax.emit(sm.Metrics())
	rmb.metricJvmMemoryPoolUsed.emit(sm.Metrics())
	rmb.metricJvmThreadsCount.emit(sm.Metrics())
	if sm.Metrics().Len() == 0 {
		return false
	}
	rmb.updateCapacity(sm.Metrics())
	sm.Scope().SetName("otelcol/elasticsearchreceiver")
	sm.Scope().SetVersion(rmb.buildInfo.Version)
	rm := m.ResourceMetrics().AppendEmpty()
	rmb.resource.CopyTo(rm.Resource())
	sm.MoveTo(rm.ScopeMetrics().AppendEmpty())
	return true
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit() pmetric.Metrics {
	m := pmetric.NewMetrics()
	for _, rmb := range mb.rmbMap {
		if ok := rmb.emit(m); !ok {
			rmb.missedEmits++
		}
	}
	for k, rmb := range mb.rmbMap {
		if rmb.missedEmits >= missedEmitsToDropRMB {
			delete(mb.rmbMap, k)
		}
	}
	return m
}

// RecordElasticsearchBreakerMemoryEstimatedDataPoint adds a data point to elasticsearch.breaker.memory.estimated metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchBreakerMemoryEstimatedDataPoint(ts pcommon.Timestamp, val int64, circuitBreakerNameAttributeValue string) {
	rmb.metricElasticsearchBreakerMemoryEstimated.recordDataPoint(rmb.startTime, ts, val, circuitBreakerNameAttributeValue)
}

// RecordElasticsearchBreakerMemoryLimitDataPoint adds a data point to elasticsearch.breaker.memory.limit metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchBreakerMemoryLimitDataPoint(ts pcommon.Timestamp, val int64, circuitBreakerNameAttributeValue string) {
	rmb.metricElasticsearchBreakerMemoryLimit.recordDataPoint(rmb.startTime, ts, val, circuitBreakerNameAttributeValue)
}

// RecordElasticsearchBreakerTrippedDataPoint adds a data point to elasticsearch.breaker.tripped metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchBreakerTrippedDataPoint(ts pcommon.Timestamp, val int64, circuitBreakerNameAttributeValue string) {
	rmb.metricElasticsearchBreakerTripped.recordDataPoint(rmb.startTime, ts, val, circuitBreakerNameAttributeValue)
}

// RecordElasticsearchClusterDataNodesDataPoint adds a data point to elasticsearch.cluster.data_nodes metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterDataNodesDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchClusterDataNodes.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchClusterHealthDataPoint adds a data point to elasticsearch.cluster.health metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterHealthDataPoint(ts pcommon.Timestamp, val int64, healthStatusAttributeValue AttributeHealthStatus) {
	rmb.metricElasticsearchClusterHealth.recordDataPoint(rmb.startTime, ts, val, healthStatusAttributeValue.String())
}

// RecordElasticsearchClusterInFlightFetchDataPoint adds a data point to elasticsearch.cluster.in_flight_fetch metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterInFlightFetchDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchClusterInFlightFetch.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchClusterIndicesCacheEvictionsDataPoint adds a data point to elasticsearch.cluster.indices.cache.evictions metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterIndicesCacheEvictionsDataPoint(ts pcommon.Timestamp, val int64, cacheNameAttributeValue AttributeCacheName) {
	rmb.metricElasticsearchClusterIndicesCacheEvictions.recordDataPoint(rmb.startTime, ts, val, cacheNameAttributeValue.String())
}

// RecordElasticsearchClusterNodesDataPoint adds a data point to elasticsearch.cluster.nodes metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterNodesDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchClusterNodes.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchClusterPendingTasksDataPoint adds a data point to elasticsearch.cluster.pending_tasks metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterPendingTasksDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchClusterPendingTasks.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchClusterPublishedStatesDifferencesDataPoint adds a data point to elasticsearch.cluster.published_states.differences metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterPublishedStatesDifferencesDataPoint(ts pcommon.Timestamp, val int64, clusterPublishedDifferenceStateAttributeValue AttributeClusterPublishedDifferenceState) {
	rmb.metricElasticsearchClusterPublishedStatesDifferences.recordDataPoint(rmb.startTime, ts, val, clusterPublishedDifferenceStateAttributeValue.String())
}

// RecordElasticsearchClusterPublishedStatesFullDataPoint adds a data point to elasticsearch.cluster.published_states.full metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterPublishedStatesFullDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchClusterPublishedStatesFull.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchClusterShardsDataPoint adds a data point to elasticsearch.cluster.shards metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterShardsDataPoint(ts pcommon.Timestamp, val int64, shardStateAttributeValue AttributeShardState) {
	rmb.metricElasticsearchClusterShards.recordDataPoint(rmb.startTime, ts, val, shardStateAttributeValue.String())
}

// RecordElasticsearchClusterStateQueueDataPoint adds a data point to elasticsearch.cluster.state_queue metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterStateQueueDataPoint(ts pcommon.Timestamp, val int64, clusterStateQueueStateAttributeValue AttributeClusterStateQueueState) {
	rmb.metricElasticsearchClusterStateQueue.recordDataPoint(rmb.startTime, ts, val, clusterStateQueueStateAttributeValue.String())
}

// RecordElasticsearchClusterStateUpdateCountDataPoint adds a data point to elasticsearch.cluster.state_update.count metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterStateUpdateCountDataPoint(ts pcommon.Timestamp, val int64, clusterStateUpdateStateAttributeValue string) {
	rmb.metricElasticsearchClusterStateUpdateCount.recordDataPoint(rmb.startTime, ts, val, clusterStateUpdateStateAttributeValue)
}

// RecordElasticsearchClusterStateUpdateTimeDataPoint adds a data point to elasticsearch.cluster.state_update.time metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchClusterStateUpdateTimeDataPoint(ts pcommon.Timestamp, val int64, clusterStateUpdateStateAttributeValue string, clusterStateUpdateTypeAttributeValue AttributeClusterStateUpdateType) {
	rmb.metricElasticsearchClusterStateUpdateTime.recordDataPoint(rmb.startTime, ts, val, clusterStateUpdateStateAttributeValue, clusterStateUpdateTypeAttributeValue.String())
}

// RecordElasticsearchIndexCacheEvictionsDataPoint adds a data point to elasticsearch.index.cache.evictions metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexCacheEvictionsDataPoint(ts pcommon.Timestamp, val int64, cacheNameAttributeValue AttributeCacheName, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexCacheEvictions.recordDataPoint(rmb.startTime, ts, val, cacheNameAttributeValue.String(), indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexCacheMemoryUsageDataPoint adds a data point to elasticsearch.index.cache.memory.usage metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexCacheMemoryUsageDataPoint(ts pcommon.Timestamp, val int64, cacheNameAttributeValue AttributeCacheName, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexCacheMemoryUsage.recordDataPoint(rmb.startTime, ts, val, cacheNameAttributeValue.String(), indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexCacheSizeDataPoint adds a data point to elasticsearch.index.cache.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexCacheSizeDataPoint(ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexCacheSize.recordDataPoint(rmb.startTime, ts, val, indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexDocumentsDataPoint adds a data point to elasticsearch.index.documents metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexDocumentsDataPoint(ts pcommon.Timestamp, val int64, documentStateAttributeValue AttributeDocumentState, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexDocuments.recordDataPoint(rmb.startTime, ts, val, documentStateAttributeValue.String(), indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexOperationsCompletedDataPoint adds a data point to elasticsearch.index.operations.completed metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexOperationsCompletedDataPoint(ts pcommon.Timestamp, val int64, operationAttributeValue AttributeOperation, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexOperationsCompleted.recordDataPoint(rmb.startTime, ts, val, operationAttributeValue.String(), indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexOperationsMergeDocsCountDataPoint adds a data point to elasticsearch.index.operations.merge.docs_count metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexOperationsMergeDocsCountDataPoint(ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexOperationsMergeDocsCount.recordDataPoint(rmb.startTime, ts, val, indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexOperationsMergeSizeDataPoint adds a data point to elasticsearch.index.operations.merge.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexOperationsMergeSizeDataPoint(ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexOperationsMergeSize.recordDataPoint(rmb.startTime, ts, val, indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexOperationsTimeDataPoint adds a data point to elasticsearch.index.operations.time metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexOperationsTimeDataPoint(ts pcommon.Timestamp, val int64, operationAttributeValue AttributeOperation, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexOperationsTime.recordDataPoint(rmb.startTime, ts, val, operationAttributeValue.String(), indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexSegmentsCountDataPoint adds a data point to elasticsearch.index.segments.count metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexSegmentsCountDataPoint(ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexSegmentsCount.recordDataPoint(rmb.startTime, ts, val, indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexSegmentsMemoryDataPoint adds a data point to elasticsearch.index.segments.memory metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexSegmentsMemoryDataPoint(ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue AttributeIndexAggregationType, segmentsMemoryObjectTypeAttributeValue AttributeSegmentsMemoryObjectType) {
	rmb.metricElasticsearchIndexSegmentsMemory.recordDataPoint(rmb.startTime, ts, val, indexAggregationTypeAttributeValue.String(), segmentsMemoryObjectTypeAttributeValue.String())
}

// RecordElasticsearchIndexSegmentsSizeDataPoint adds a data point to elasticsearch.index.segments.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexSegmentsSizeDataPoint(ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexSegmentsSize.recordDataPoint(rmb.startTime, ts, val, indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexShardsSizeDataPoint adds a data point to elasticsearch.index.shards.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexShardsSizeDataPoint(ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexShardsSize.recordDataPoint(rmb.startTime, ts, val, indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexTranslogOperationsDataPoint adds a data point to elasticsearch.index.translog.operations metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexTranslogOperationsDataPoint(ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexTranslogOperations.recordDataPoint(rmb.startTime, ts, val, indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexTranslogSizeDataPoint adds a data point to elasticsearch.index.translog.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexTranslogSizeDataPoint(ts pcommon.Timestamp, val int64, indexAggregationTypeAttributeValue AttributeIndexAggregationType) {
	rmb.metricElasticsearchIndexTranslogSize.recordDataPoint(rmb.startTime, ts, val, indexAggregationTypeAttributeValue.String())
}

// RecordElasticsearchIndexingPressureMemoryLimitDataPoint adds a data point to elasticsearch.indexing_pressure.memory.limit metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexingPressureMemoryLimitDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchIndexingPressureMemoryLimit.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchIndexingPressureMemoryTotalPrimaryRejectionsDataPoint adds a data point to elasticsearch.indexing_pressure.memory.total.primary_rejections metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexingPressureMemoryTotalPrimaryRejectionsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchIndexingPressureMemoryTotalPrimaryRejections.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchIndexingPressureMemoryTotalReplicaRejectionsDataPoint adds a data point to elasticsearch.indexing_pressure.memory.total.replica_rejections metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchIndexingPressureMemoryTotalReplicaRejectionsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchIndexingPressureMemoryTotalReplicaRejections.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchMemoryIndexingPressureDataPoint adds a data point to elasticsearch.memory.indexing_pressure metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchMemoryIndexingPressureDataPoint(ts pcommon.Timestamp, val int64, indexingPressureStageAttributeValue AttributeIndexingPressureStage) {
	rmb.metricElasticsearchMemoryIndexingPressure.recordDataPoint(rmb.startTime, ts, val, indexingPressureStageAttributeValue.String())
}

// RecordElasticsearchNodeCacheCountDataPoint adds a data point to elasticsearch.node.cache.count metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeCacheCountDataPoint(ts pcommon.Timestamp, val int64, queryCacheCountTypeAttributeValue AttributeQueryCacheCountType) {
	rmb.metricElasticsearchNodeCacheCount.recordDataPoint(rmb.startTime, ts, val, queryCacheCountTypeAttributeValue.String())
}

// RecordElasticsearchNodeCacheEvictionsDataPoint adds a data point to elasticsearch.node.cache.evictions metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeCacheEvictionsDataPoint(ts pcommon.Timestamp, val int64, cacheNameAttributeValue AttributeCacheName) {
	rmb.metricElasticsearchNodeCacheEvictions.recordDataPoint(rmb.startTime, ts, val, cacheNameAttributeValue.String())
}

// RecordElasticsearchNodeCacheMemoryUsageDataPoint adds a data point to elasticsearch.node.cache.memory.usage metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeCacheMemoryUsageDataPoint(ts pcommon.Timestamp, val int64, cacheNameAttributeValue AttributeCacheName) {
	rmb.metricElasticsearchNodeCacheMemoryUsage.recordDataPoint(rmb.startTime, ts, val, cacheNameAttributeValue.String())
}

// RecordElasticsearchNodeCacheSizeDataPoint adds a data point to elasticsearch.node.cache.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeCacheSizeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeCacheSize.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeClusterConnectionsDataPoint adds a data point to elasticsearch.node.cluster.connections metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeClusterConnectionsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeClusterConnections.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeClusterIoDataPoint adds a data point to elasticsearch.node.cluster.io metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeClusterIoDataPoint(ts pcommon.Timestamp, val int64, directionAttributeValue AttributeDirection) {
	rmb.metricElasticsearchNodeClusterIo.recordDataPoint(rmb.startTime, ts, val, directionAttributeValue.String())
}

// RecordElasticsearchNodeDiskIoReadDataPoint adds a data point to elasticsearch.node.disk.io.read metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeDiskIoReadDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeDiskIoRead.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeDiskIoWriteDataPoint adds a data point to elasticsearch.node.disk.io.write metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeDiskIoWriteDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeDiskIoWrite.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeDocumentsDataPoint adds a data point to elasticsearch.node.documents metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeDocumentsDataPoint(ts pcommon.Timestamp, val int64, documentStateAttributeValue AttributeDocumentState) {
	rmb.metricElasticsearchNodeDocuments.recordDataPoint(rmb.startTime, ts, val, documentStateAttributeValue.String())
}

// RecordElasticsearchNodeFsDiskAvailableDataPoint adds a data point to elasticsearch.node.fs.disk.available metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeFsDiskAvailableDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeFsDiskAvailable.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeFsDiskFreeDataPoint adds a data point to elasticsearch.node.fs.disk.free metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeFsDiskFreeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeFsDiskFree.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeFsDiskTotalDataPoint adds a data point to elasticsearch.node.fs.disk.total metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeFsDiskTotalDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeFsDiskTotal.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeHTTPConnectionsDataPoint adds a data point to elasticsearch.node.http.connections metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeHTTPConnectionsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeHTTPConnections.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeIngestDocumentsDataPoint adds a data point to elasticsearch.node.ingest.documents metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeIngestDocumentsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeIngestDocuments.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeIngestDocumentsCurrentDataPoint adds a data point to elasticsearch.node.ingest.documents.current metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeIngestDocumentsCurrentDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeIngestDocumentsCurrent.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeIngestOperationsFailedDataPoint adds a data point to elasticsearch.node.ingest.operations.failed metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeIngestOperationsFailedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeIngestOperationsFailed.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeOpenFilesDataPoint adds a data point to elasticsearch.node.open_files metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeOpenFilesDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeOpenFiles.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeOperationsCompletedDataPoint adds a data point to elasticsearch.node.operations.completed metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeOperationsCompletedDataPoint(ts pcommon.Timestamp, val int64, operationAttributeValue AttributeOperation) {
	rmb.metricElasticsearchNodeOperationsCompleted.recordDataPoint(rmb.startTime, ts, val, operationAttributeValue.String())
}

// RecordElasticsearchNodeOperationsCurrentDataPoint adds a data point to elasticsearch.node.operations.current metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeOperationsCurrentDataPoint(ts pcommon.Timestamp, val int64, operationAttributeValue AttributeOperation) {
	rmb.metricElasticsearchNodeOperationsCurrent.recordDataPoint(rmb.startTime, ts, val, operationAttributeValue.String())
}

// RecordElasticsearchNodeOperationsGetCompletedDataPoint adds a data point to elasticsearch.node.operations.get.completed metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeOperationsGetCompletedDataPoint(ts pcommon.Timestamp, val int64, getResultAttributeValue AttributeGetResult) {
	rmb.metricElasticsearchNodeOperationsGetCompleted.recordDataPoint(rmb.startTime, ts, val, getResultAttributeValue.String())
}

// RecordElasticsearchNodeOperationsGetTimeDataPoint adds a data point to elasticsearch.node.operations.get.time metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeOperationsGetTimeDataPoint(ts pcommon.Timestamp, val int64, getResultAttributeValue AttributeGetResult) {
	rmb.metricElasticsearchNodeOperationsGetTime.recordDataPoint(rmb.startTime, ts, val, getResultAttributeValue.String())
}

// RecordElasticsearchNodeOperationsTimeDataPoint adds a data point to elasticsearch.node.operations.time metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeOperationsTimeDataPoint(ts pcommon.Timestamp, val int64, operationAttributeValue AttributeOperation) {
	rmb.metricElasticsearchNodeOperationsTime.recordDataPoint(rmb.startTime, ts, val, operationAttributeValue.String())
}

// RecordElasticsearchNodePipelineIngestDocumentsCurrentDataPoint adds a data point to elasticsearch.node.pipeline.ingest.documents.current metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodePipelineIngestDocumentsCurrentDataPoint(ts pcommon.Timestamp, val int64, ingestPipelineNameAttributeValue string) {
	rmb.metricElasticsearchNodePipelineIngestDocumentsCurrent.recordDataPoint(rmb.startTime, ts, val, ingestPipelineNameAttributeValue)
}

// RecordElasticsearchNodePipelineIngestDocumentsPreprocessedDataPoint adds a data point to elasticsearch.node.pipeline.ingest.documents.preprocessed metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodePipelineIngestDocumentsPreprocessedDataPoint(ts pcommon.Timestamp, val int64, ingestPipelineNameAttributeValue string) {
	rmb.metricElasticsearchNodePipelineIngestDocumentsPreprocessed.recordDataPoint(rmb.startTime, ts, val, ingestPipelineNameAttributeValue)
}

// RecordElasticsearchNodePipelineIngestOperationsFailedDataPoint adds a data point to elasticsearch.node.pipeline.ingest.operations.failed metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodePipelineIngestOperationsFailedDataPoint(ts pcommon.Timestamp, val int64, ingestPipelineNameAttributeValue string) {
	rmb.metricElasticsearchNodePipelineIngestOperationsFailed.recordDataPoint(rmb.startTime, ts, val, ingestPipelineNameAttributeValue)
}

// RecordElasticsearchNodeScriptCacheEvictionsDataPoint adds a data point to elasticsearch.node.script.cache_evictions metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeScriptCacheEvictionsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeScriptCacheEvictions.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeScriptCompilationLimitTriggeredDataPoint adds a data point to elasticsearch.node.script.compilation_limit_triggered metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeScriptCompilationLimitTriggeredDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeScriptCompilationLimitTriggered.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeScriptCompilationsDataPoint adds a data point to elasticsearch.node.script.compilations metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeScriptCompilationsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeScriptCompilations.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeSegmentsMemoryDataPoint adds a data point to elasticsearch.node.segments.memory metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeSegmentsMemoryDataPoint(ts pcommon.Timestamp, val int64, segmentsMemoryObjectTypeAttributeValue AttributeSegmentsMemoryObjectType) {
	rmb.metricElasticsearchNodeSegmentsMemory.recordDataPoint(rmb.startTime, ts, val, segmentsMemoryObjectTypeAttributeValue.String())
}

// RecordElasticsearchNodeShardsDataSetSizeDataPoint adds a data point to elasticsearch.node.shards.data_set.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeShardsDataSetSizeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeShardsDataSetSize.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeShardsReservedSizeDataPoint adds a data point to elasticsearch.node.shards.reserved.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeShardsReservedSizeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeShardsReservedSize.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeShardsSizeDataPoint adds a data point to elasticsearch.node.shards.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeShardsSizeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeShardsSize.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeThreadPoolTasksFinishedDataPoint adds a data point to elasticsearch.node.thread_pool.tasks.finished metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeThreadPoolTasksFinishedDataPoint(ts pcommon.Timestamp, val int64, threadPoolNameAttributeValue string, taskStateAttributeValue AttributeTaskState) {
	rmb.metricElasticsearchNodeThreadPoolTasksFinished.recordDataPoint(rmb.startTime, ts, val, threadPoolNameAttributeValue, taskStateAttributeValue.String())
}

// RecordElasticsearchNodeThreadPoolTasksQueuedDataPoint adds a data point to elasticsearch.node.thread_pool.tasks.queued metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeThreadPoolTasksQueuedDataPoint(ts pcommon.Timestamp, val int64, threadPoolNameAttributeValue string) {
	rmb.metricElasticsearchNodeThreadPoolTasksQueued.recordDataPoint(rmb.startTime, ts, val, threadPoolNameAttributeValue)
}

// RecordElasticsearchNodeThreadPoolThreadsDataPoint adds a data point to elasticsearch.node.thread_pool.threads metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeThreadPoolThreadsDataPoint(ts pcommon.Timestamp, val int64, threadPoolNameAttributeValue string, threadStateAttributeValue AttributeThreadState) {
	rmb.metricElasticsearchNodeThreadPoolThreads.recordDataPoint(rmb.startTime, ts, val, threadPoolNameAttributeValue, threadStateAttributeValue.String())
}

// RecordElasticsearchNodeTranslogOperationsDataPoint adds a data point to elasticsearch.node.translog.operations metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeTranslogOperationsDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeTranslogOperations.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeTranslogSizeDataPoint adds a data point to elasticsearch.node.translog.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeTranslogSizeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeTranslogSize.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchNodeTranslogUncommittedSizeDataPoint adds a data point to elasticsearch.node.translog.uncommitted.size metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchNodeTranslogUncommittedSizeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchNodeTranslogUncommittedSize.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchOsCPULoadAvg15mDataPoint adds a data point to elasticsearch.os.cpu.load_avg.15m metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchOsCPULoadAvg15mDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricElasticsearchOsCPULoadAvg15m.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchOsCPULoadAvg1mDataPoint adds a data point to elasticsearch.os.cpu.load_avg.1m metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchOsCPULoadAvg1mDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricElasticsearchOsCPULoadAvg1m.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchOsCPULoadAvg5mDataPoint adds a data point to elasticsearch.os.cpu.load_avg.5m metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchOsCPULoadAvg5mDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricElasticsearchOsCPULoadAvg5m.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchOsCPUUsageDataPoint adds a data point to elasticsearch.os.cpu.usage metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchOsCPUUsageDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchOsCPUUsage.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchOsMemoryDataPoint adds a data point to elasticsearch.os.memory metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchOsMemoryDataPoint(ts pcommon.Timestamp, val int64, memoryStateAttributeValue AttributeMemoryState) {
	rmb.metricElasticsearchOsMemory.recordDataPoint(rmb.startTime, ts, val, memoryStateAttributeValue.String())
}

// RecordElasticsearchProcessCPUTimeDataPoint adds a data point to elasticsearch.process.cpu.time metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchProcessCPUTimeDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchProcessCPUTime.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchProcessCPUUsageDataPoint adds a data point to elasticsearch.process.cpu.usage metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchProcessCPUUsageDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricElasticsearchProcessCPUUsage.recordDataPoint(rmb.startTime, ts, val)
}

// RecordElasticsearchProcessMemoryVirtualDataPoint adds a data point to elasticsearch.process.memory.virtual metric.
func (rmb *ResourceMetricsBuilder) RecordElasticsearchProcessMemoryVirtualDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricElasticsearchProcessMemoryVirtual.recordDataPoint(rmb.startTime, ts, val)
}

// RecordJvmClassesLoadedDataPoint adds a data point to jvm.classes.loaded metric.
func (rmb *ResourceMetricsBuilder) RecordJvmClassesLoadedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricJvmClassesLoaded.recordDataPoint(rmb.startTime, ts, val)
}

// RecordJvmGcCollectionsCountDataPoint adds a data point to jvm.gc.collections.count metric.
func (rmb *ResourceMetricsBuilder) RecordJvmGcCollectionsCountDataPoint(ts pcommon.Timestamp, val int64, collectorNameAttributeValue string) {
	rmb.metricJvmGcCollectionsCount.recordDataPoint(rmb.startTime, ts, val, collectorNameAttributeValue)
}

// RecordJvmGcCollectionsElapsedDataPoint adds a data point to jvm.gc.collections.elapsed metric.
func (rmb *ResourceMetricsBuilder) RecordJvmGcCollectionsElapsedDataPoint(ts pcommon.Timestamp, val int64, collectorNameAttributeValue string) {
	rmb.metricJvmGcCollectionsElapsed.recordDataPoint(rmb.startTime, ts, val, collectorNameAttributeValue)
}

// RecordJvmMemoryHeapCommittedDataPoint adds a data point to jvm.memory.heap.committed metric.
func (rmb *ResourceMetricsBuilder) RecordJvmMemoryHeapCommittedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricJvmMemoryHeapCommitted.recordDataPoint(rmb.startTime, ts, val)
}

// RecordJvmMemoryHeapMaxDataPoint adds a data point to jvm.memory.heap.max metric.
func (rmb *ResourceMetricsBuilder) RecordJvmMemoryHeapMaxDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricJvmMemoryHeapMax.recordDataPoint(rmb.startTime, ts, val)
}

// RecordJvmMemoryHeapUsedDataPoint adds a data point to jvm.memory.heap.used metric.
func (rmb *ResourceMetricsBuilder) RecordJvmMemoryHeapUsedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricJvmMemoryHeapUsed.recordDataPoint(rmb.startTime, ts, val)
}

// RecordJvmMemoryHeapUtilizationDataPoint adds a data point to jvm.memory.heap.utilization metric.
func (rmb *ResourceMetricsBuilder) RecordJvmMemoryHeapUtilizationDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricJvmMemoryHeapUtilization.recordDataPoint(rmb.startTime, ts, val)
}

// RecordJvmMemoryNonheapCommittedDataPoint adds a data point to jvm.memory.nonheap.committed metric.
func (rmb *ResourceMetricsBuilder) RecordJvmMemoryNonheapCommittedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricJvmMemoryNonheapCommitted.recordDataPoint(rmb.startTime, ts, val)
}

// RecordJvmMemoryNonheapUsedDataPoint adds a data point to jvm.memory.nonheap.used metric.
func (rmb *ResourceMetricsBuilder) RecordJvmMemoryNonheapUsedDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricJvmMemoryNonheapUsed.recordDataPoint(rmb.startTime, ts, val)
}

// RecordJvmMemoryPoolMaxDataPoint adds a data point to jvm.memory.pool.max metric.
func (rmb *ResourceMetricsBuilder) RecordJvmMemoryPoolMaxDataPoint(ts pcommon.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	rmb.metricJvmMemoryPoolMax.recordDataPoint(rmb.startTime, ts, val, memoryPoolNameAttributeValue)
}

// RecordJvmMemoryPoolUsedDataPoint adds a data point to jvm.memory.pool.used metric.
func (rmb *ResourceMetricsBuilder) RecordJvmMemoryPoolUsedDataPoint(ts pcommon.Timestamp, val int64, memoryPoolNameAttributeValue string) {
	rmb.metricJvmMemoryPoolUsed.recordDataPoint(rmb.startTime, ts, val, memoryPoolNameAttributeValue)
}

// RecordJvmThreadsCountDataPoint adds a data point to jvm.threads.count metric.
func (rmb *ResourceMetricsBuilder) RecordJvmThreadsCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricJvmThreadsCount.recordDataPoint(rmb.startTime, ts, val)
}

// Reset resets the ResourceMetricsBuilder to its initial state. It should be used when external metrics source is
// restarted, and the ResourceMetricsBuilder should update its startTime and reset it's internal state accordingly.
func (rmb *ResourceMetricsBuilder) Reset(options ...resourceMetricsBuilderOption) {
	rmb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(rmb)
	}
}
