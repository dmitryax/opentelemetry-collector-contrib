// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"

	"github.com/open-telemetry/opentelemetry-collector-contrib/pkg/pdatautil"
)

// AttributePageOperations specifies the a value page.operations attribute.
type AttributePageOperations int

const (
	_ AttributePageOperations = iota
	AttributePageOperationsRead
	AttributePageOperationsWrite
)

// String returns the string representation of the AttributePageOperations.
func (av AttributePageOperations) String() string {
	switch av {
	case AttributePageOperationsRead:
		return "read"
	case AttributePageOperationsWrite:
		return "write"
	}
	return ""
}

// MapAttributePageOperations is a helper map of string to AttributePageOperations attribute value.
var MapAttributePageOperations = map[string]AttributePageOperations{
	"read":  AttributePageOperationsRead,
	"write": AttributePageOperationsWrite,
}

type metricSqlserverBatchRequestRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.batch.request.rate metric with initial data.
func (m *metricSqlserverBatchRequestRate) init() {
	m.data.SetName("sqlserver.batch.request.rate")
	m.data.SetDescription("Number of batch requests received by SQL Server.")
	m.data.SetUnit("{requests}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBatchRequestRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBatchRequestRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBatchRequestRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBatchRequestRate(cfg MetricConfig) metricSqlserverBatchRequestRate {
	m := metricSqlserverBatchRequestRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBatchSQLCompilationRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.batch.sql_compilation.rate metric with initial data.
func (m *metricSqlserverBatchSQLCompilationRate) init() {
	m.data.SetName("sqlserver.batch.sql_compilation.rate")
	m.data.SetDescription("Number of SQL compilations needed.")
	m.data.SetUnit("{compilations}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBatchSQLCompilationRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBatchSQLCompilationRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBatchSQLCompilationRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBatchSQLCompilationRate(cfg MetricConfig) metricSqlserverBatchSQLCompilationRate {
	m := metricSqlserverBatchSQLCompilationRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverBatchSQLRecompilationRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.batch.sql_recompilation.rate metric with initial data.
func (m *metricSqlserverBatchSQLRecompilationRate) init() {
	m.data.SetName("sqlserver.batch.sql_recompilation.rate")
	m.data.SetDescription("Number of SQL recompilations needed.")
	m.data.SetUnit("{compilations}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverBatchSQLRecompilationRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverBatchSQLRecompilationRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverBatchSQLRecompilationRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverBatchSQLRecompilationRate(cfg MetricConfig) metricSqlserverBatchSQLRecompilationRate {
	m := metricSqlserverBatchSQLRecompilationRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockWaitRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.wait.rate metric with initial data.
func (m *metricSqlserverLockWaitRate) init() {
	m.data.SetName("sqlserver.lock.wait.rate")
	m.data.SetDescription("Number of lock requests resulting in a wait.")
	m.data.SetUnit("{requests}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockWaitRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockWaitRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockWaitRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockWaitRate(cfg MetricConfig) metricSqlserverLockWaitRate {
	m := metricSqlserverLockWaitRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverLockWaitTimeAvg struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.lock.wait_time.avg metric with initial data.
func (m *metricSqlserverLockWaitTimeAvg) init() {
	m.data.SetName("sqlserver.lock.wait_time.avg")
	m.data.SetDescription("Average wait time for all lock requests that had to wait.")
	m.data.SetUnit("ms")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverLockWaitTimeAvg) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverLockWaitTimeAvg) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverLockWaitTimeAvg) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverLockWaitTimeAvg(cfg MetricConfig) metricSqlserverLockWaitTimeAvg {
	m := metricSqlserverLockWaitTimeAvg{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPageBufferCacheHitRatio struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.page.buffer_cache.hit_ratio metric with initial data.
func (m *metricSqlserverPageBufferCacheHitRatio) init() {
	m.data.SetName("sqlserver.page.buffer_cache.hit_ratio")
	m.data.SetDescription("Pages found in the buffer pool without having to read from disk.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPageBufferCacheHitRatio) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPageBufferCacheHitRatio) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPageBufferCacheHitRatio) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPageBufferCacheHitRatio(cfg MetricConfig) metricSqlserverPageBufferCacheHitRatio {
	m := metricSqlserverPageBufferCacheHitRatio{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPageCheckpointFlushRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.page.checkpoint.flush.rate metric with initial data.
func (m *metricSqlserverPageCheckpointFlushRate) init() {
	m.data.SetName("sqlserver.page.checkpoint.flush.rate")
	m.data.SetDescription("Number of pages flushed by operations requiring dirty pages to be flushed.")
	m.data.SetUnit("{pages}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPageCheckpointFlushRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPageCheckpointFlushRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPageCheckpointFlushRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPageCheckpointFlushRate(cfg MetricConfig) metricSqlserverPageCheckpointFlushRate {
	m := metricSqlserverPageCheckpointFlushRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPageLazyWriteRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.page.lazy_write.rate metric with initial data.
func (m *metricSqlserverPageLazyWriteRate) init() {
	m.data.SetName("sqlserver.page.lazy_write.rate")
	m.data.SetDescription("Number of lazy writes moving dirty pages to disk.")
	m.data.SetUnit("{writes}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPageLazyWriteRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPageLazyWriteRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPageLazyWriteRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPageLazyWriteRate(cfg MetricConfig) metricSqlserverPageLazyWriteRate {
	m := metricSqlserverPageLazyWriteRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPageLifeExpectancy struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.page.life_expectancy metric with initial data.
func (m *metricSqlserverPageLifeExpectancy) init() {
	m.data.SetName("sqlserver.page.life_expectancy")
	m.data.SetDescription("Time a page will stay in the buffer pool.")
	m.data.SetUnit("s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPageLifeExpectancy) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPageLifeExpectancy) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPageLifeExpectancy) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPageLifeExpectancy(cfg MetricConfig) metricSqlserverPageLifeExpectancy {
	m := metricSqlserverPageLifeExpectancy{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPageOperationRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.page.operation.rate metric with initial data.
func (m *metricSqlserverPageOperationRate) init() {
	m.data.SetName("sqlserver.page.operation.rate")
	m.data.SetDescription("Number of physical database page operations issued.")
	m.data.SetUnit("{operations}/s")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSqlserverPageOperationRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64, pageOperationsAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
	dp.Attributes().PutStr("type", pageOperationsAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPageOperationRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPageOperationRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPageOperationRate(cfg MetricConfig) metricSqlserverPageOperationRate {
	m := metricSqlserverPageOperationRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverPageSplitRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.page.split.rate metric with initial data.
func (m *metricSqlserverPageSplitRate) init() {
	m.data.SetName("sqlserver.page.split.rate")
	m.data.SetDescription("Number of pages split as a result of overflowing index pages.")
	m.data.SetUnit("{pages}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverPageSplitRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverPageSplitRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverPageSplitRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverPageSplitRate(cfg MetricConfig) metricSqlserverPageSplitRate {
	m := metricSqlserverPageSplitRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTransactionRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.transaction.rate metric with initial data.
func (m *metricSqlserverTransactionRate) init() {
	m.data.SetName("sqlserver.transaction.rate")
	m.data.SetDescription("Number of transactions started for the database (not including XTP-only transactions).")
	m.data.SetUnit("{transactions}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTransactionRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTransactionRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTransactionRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTransactionRate(cfg MetricConfig) metricSqlserverTransactionRate {
	m := metricSqlserverTransactionRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTransactionWriteRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.transaction.write.rate metric with initial data.
func (m *metricSqlserverTransactionWriteRate) init() {
	m.data.SetName("sqlserver.transaction.write.rate")
	m.data.SetDescription("Number of transactions that wrote to the database and committed.")
	m.data.SetUnit("{transactions}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTransactionWriteRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTransactionWriteRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTransactionWriteRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTransactionWriteRate(cfg MetricConfig) metricSqlserverTransactionWriteRate {
	m := metricSqlserverTransactionWriteRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTransactionLogFlushDataRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.transaction_log.flush.data.rate metric with initial data.
func (m *metricSqlserverTransactionLogFlushDataRate) init() {
	m.data.SetName("sqlserver.transaction_log.flush.data.rate")
	m.data.SetDescription("Total number of log bytes flushed.")
	m.data.SetUnit("By/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTransactionLogFlushDataRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTransactionLogFlushDataRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTransactionLogFlushDataRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTransactionLogFlushDataRate(cfg MetricConfig) metricSqlserverTransactionLogFlushDataRate {
	m := metricSqlserverTransactionLogFlushDataRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTransactionLogFlushRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.transaction_log.flush.rate metric with initial data.
func (m *metricSqlserverTransactionLogFlushRate) init() {
	m.data.SetName("sqlserver.transaction_log.flush.rate")
	m.data.SetDescription("Number of log flushes.")
	m.data.SetUnit("{flushes}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTransactionLogFlushRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTransactionLogFlushRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTransactionLogFlushRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTransactionLogFlushRate(cfg MetricConfig) metricSqlserverTransactionLogFlushRate {
	m := metricSqlserverTransactionLogFlushRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTransactionLogFlushWaitRate struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.transaction_log.flush.wait.rate metric with initial data.
func (m *metricSqlserverTransactionLogFlushWaitRate) init() {
	m.data.SetName("sqlserver.transaction_log.flush.wait.rate")
	m.data.SetDescription("Number of commits waiting for a transaction log flush.")
	m.data.SetUnit("{commits}/s")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTransactionLogFlushWaitRate) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val float64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetDoubleValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTransactionLogFlushWaitRate) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTransactionLogFlushWaitRate) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTransactionLogFlushWaitRate(cfg MetricConfig) metricSqlserverTransactionLogFlushWaitRate {
	m := metricSqlserverTransactionLogFlushWaitRate{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTransactionLogGrowthCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.transaction_log.growth.count metric with initial data.
func (m *metricSqlserverTransactionLogGrowthCount) init() {
	m.data.SetName("sqlserver.transaction_log.growth.count")
	m.data.SetDescription("Total number of transaction log expansions for a database.")
	m.data.SetUnit("{growths}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSqlserverTransactionLogGrowthCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTransactionLogGrowthCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTransactionLogGrowthCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTransactionLogGrowthCount(cfg MetricConfig) metricSqlserverTransactionLogGrowthCount {
	m := metricSqlserverTransactionLogGrowthCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTransactionLogShrinkCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.transaction_log.shrink.count metric with initial data.
func (m *metricSqlserverTransactionLogShrinkCount) init() {
	m.data.SetName("sqlserver.transaction_log.shrink.count")
	m.data.SetDescription("Total number of transaction log shrinks for a database.")
	m.data.SetUnit("{shrinks}")
	m.data.SetEmptySum()
	m.data.Sum().SetIsMonotonic(true)
	m.data.Sum().SetAggregationTemporality(pmetric.AggregationTemporalityCumulative)
}

func (m *metricSqlserverTransactionLogShrinkCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Sum().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTransactionLogShrinkCount) updateCapacity() {
	if m.data.Sum().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Sum().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTransactionLogShrinkCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Sum().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTransactionLogShrinkCount(cfg MetricConfig) metricSqlserverTransactionLogShrinkCount {
	m := metricSqlserverTransactionLogShrinkCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverTransactionLogUsage struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.transaction_log.usage metric with initial data.
func (m *metricSqlserverTransactionLogUsage) init() {
	m.data.SetName("sqlserver.transaction_log.usage")
	m.data.SetDescription("Percent of transaction log space used.")
	m.data.SetUnit("%")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverTransactionLogUsage) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverTransactionLogUsage) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverTransactionLogUsage) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverTransactionLogUsage(cfg MetricConfig) metricSqlserverTransactionLogUsage {
	m := metricSqlserverTransactionLogUsage{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSqlserverUserConnectionCount struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills sqlserver.user.connection.count metric with initial data.
func (m *metricSqlserverUserConnectionCount) init() {
	m.data.SetName("sqlserver.user.connection.count")
	m.data.SetDescription("Number of users connected to the SQL Server.")
	m.data.SetUnit("{connections}")
	m.data.SetEmptyGauge()
}

func (m *metricSqlserverUserConnectionCount) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSqlserverUserConnectionCount) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSqlserverUserConnectionCount) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSqlserverUserConnectionCount(cfg MetricConfig) metricSqlserverUserConnectionCount {
	m := metricSqlserverUserConnectionCount{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// missedEmitsToDropRMB is number of missed emits after which resource builder will be dropped from MetricsBuilder.rmbMap.
// Potentially, this value can be made configurable through a MetricsBuilder option.
const missedEmitsToDropRMB = 5

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config    MetricsBuilderConfig                 // config of the metrics builder.
	buildInfo component.BuildInfo                  // contains version information
	startTime pcommon.Timestamp                    // start time that will be applied to all recorded data points.
	rmbMap    map[[16]byte]*ResourceMetricsBuilder // map of resource builders by resource hash.
}

type ResourceMetricsBuilder struct {
	buildInfo                                  component.BuildInfo
	startTime                                  pcommon.Timestamp // start time that will be applied to all recorded data points.
	metricsCapacity                            int               // maximum observed number of metrics per resource.
	resource                                   pcommon.Resource
	missedEmits                                int
	metricSqlserverBatchRequestRate            metricSqlserverBatchRequestRate
	metricSqlserverBatchSQLCompilationRate     metricSqlserverBatchSQLCompilationRate
	metricSqlserverBatchSQLRecompilationRate   metricSqlserverBatchSQLRecompilationRate
	metricSqlserverLockWaitRate                metricSqlserverLockWaitRate
	metricSqlserverLockWaitTimeAvg             metricSqlserverLockWaitTimeAvg
	metricSqlserverPageBufferCacheHitRatio     metricSqlserverPageBufferCacheHitRatio
	metricSqlserverPageCheckpointFlushRate     metricSqlserverPageCheckpointFlushRate
	metricSqlserverPageLazyWriteRate           metricSqlserverPageLazyWriteRate
	metricSqlserverPageLifeExpectancy          metricSqlserverPageLifeExpectancy
	metricSqlserverPageOperationRate           metricSqlserverPageOperationRate
	metricSqlserverPageSplitRate               metricSqlserverPageSplitRate
	metricSqlserverTransactionRate             metricSqlserverTransactionRate
	metricSqlserverTransactionWriteRate        metricSqlserverTransactionWriteRate
	metricSqlserverTransactionLogFlushDataRate metricSqlserverTransactionLogFlushDataRate
	metricSqlserverTransactionLogFlushRate     metricSqlserverTransactionLogFlushRate
	metricSqlserverTransactionLogFlushWaitRate metricSqlserverTransactionLogFlushWaitRate
	metricSqlserverTransactionLogGrowthCount   metricSqlserverTransactionLogGrowthCount
	metricSqlserverTransactionLogShrinkCount   metricSqlserverTransactionLogShrinkCount
	metricSqlserverTransactionLogUsage         metricSqlserverTransactionLogUsage
	metricSqlserverUserConnectionCount         metricSqlserverUserConnectionCount
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:    mbc,
		startTime: pcommon.NewTimestampFromTime(time.Now()),
		buildInfo: settings.BuildInfo,
		rmbMap:    make(map[[16]byte]*ResourceMetricsBuilder),
	}
	for _, opt := range options {
		opt(mb)
	}
	return mb
}

// resourceMetricsBuilderOption applies changes to provided resource metrics.
type resourceMetricsBuilderOption func(*ResourceMetricsBuilder)

// WithStartTimeOverride sets start time for all the resource metrics data points.
func WithStartTimeOverride(start pcommon.Timestamp) resourceMetricsBuilderOption {
	return func(rmb *ResourceMetricsBuilder) {
		rmb.startTime = start
	}
}

// ResourceMetricsBuilder returns a ResourceMetricsBuilder that can be used to record metrics for a specific resource.
// It requires Resource to be provided which should be built with ResourceBuilder.
func (mb *MetricsBuilder) ResourceMetricsBuilder(res pcommon.Resource, options ...resourceMetricsBuilderOption) *ResourceMetricsBuilder {
	hash := pdatautil.MapHash(res.Attributes())
	if rmb, ok := mb.rmbMap[hash]; ok {
		return rmb
	}
	rmb := &ResourceMetricsBuilder{
		startTime:                                  mb.startTime,
		buildInfo:                                  mb.buildInfo,
		resource:                                   res,
		metricSqlserverBatchRequestRate:            newMetricSqlserverBatchRequestRate(mb.config.Metrics.SqlserverBatchRequestRate),
		metricSqlserverBatchSQLCompilationRate:     newMetricSqlserverBatchSQLCompilationRate(mb.config.Metrics.SqlserverBatchSQLCompilationRate),
		metricSqlserverBatchSQLRecompilationRate:   newMetricSqlserverBatchSQLRecompilationRate(mb.config.Metrics.SqlserverBatchSQLRecompilationRate),
		metricSqlserverLockWaitRate:                newMetricSqlserverLockWaitRate(mb.config.Metrics.SqlserverLockWaitRate),
		metricSqlserverLockWaitTimeAvg:             newMetricSqlserverLockWaitTimeAvg(mb.config.Metrics.SqlserverLockWaitTimeAvg),
		metricSqlserverPageBufferCacheHitRatio:     newMetricSqlserverPageBufferCacheHitRatio(mb.config.Metrics.SqlserverPageBufferCacheHitRatio),
		metricSqlserverPageCheckpointFlushRate:     newMetricSqlserverPageCheckpointFlushRate(mb.config.Metrics.SqlserverPageCheckpointFlushRate),
		metricSqlserverPageLazyWriteRate:           newMetricSqlserverPageLazyWriteRate(mb.config.Metrics.SqlserverPageLazyWriteRate),
		metricSqlserverPageLifeExpectancy:          newMetricSqlserverPageLifeExpectancy(mb.config.Metrics.SqlserverPageLifeExpectancy),
		metricSqlserverPageOperationRate:           newMetricSqlserverPageOperationRate(mb.config.Metrics.SqlserverPageOperationRate),
		metricSqlserverPageSplitRate:               newMetricSqlserverPageSplitRate(mb.config.Metrics.SqlserverPageSplitRate),
		metricSqlserverTransactionRate:             newMetricSqlserverTransactionRate(mb.config.Metrics.SqlserverTransactionRate),
		metricSqlserverTransactionWriteRate:        newMetricSqlserverTransactionWriteRate(mb.config.Metrics.SqlserverTransactionWriteRate),
		metricSqlserverTransactionLogFlushDataRate: newMetricSqlserverTransactionLogFlushDataRate(mb.config.Metrics.SqlserverTransactionLogFlushDataRate),
		metricSqlserverTransactionLogFlushRate:     newMetricSqlserverTransactionLogFlushRate(mb.config.Metrics.SqlserverTransactionLogFlushRate),
		metricSqlserverTransactionLogFlushWaitRate: newMetricSqlserverTransactionLogFlushWaitRate(mb.config.Metrics.SqlserverTransactionLogFlushWaitRate),
		metricSqlserverTransactionLogGrowthCount:   newMetricSqlserverTransactionLogGrowthCount(mb.config.Metrics.SqlserverTransactionLogGrowthCount),
		metricSqlserverTransactionLogShrinkCount:   newMetricSqlserverTransactionLogShrinkCount(mb.config.Metrics.SqlserverTransactionLogShrinkCount),
		metricSqlserverTransactionLogUsage:         newMetricSqlserverTransactionLogUsage(mb.config.Metrics.SqlserverTransactionLogUsage),
		metricSqlserverUserConnectionCount:         newMetricSqlserverUserConnectionCount(mb.config.Metrics.SqlserverUserConnectionCount),
	}
	for _, op := range options {
		op(rmb)
	}
	mb.rmbMap[hash] = rmb
	return rmb
}

// NewResourceBuilder returns a new resource builder that should be used to build a resource associated with for the emitted metrics.
func (mb *MetricsBuilder) NewResourceBuilder() *ResourceBuilder {
	return NewResourceBuilder(mb.config.ResourceAttributes)
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (rmb *ResourceMetricsBuilder) updateCapacity(ms pmetric.MetricSlice) {
	if rmb.metricsCapacity < ms.Len() {
		rmb.metricsCapacity = ms.Len()
	}
}

// emit emits all the metrics accumulated by the ResourceMetricsBuilder and updates the internal state to be ready for
// recording another set of metrics. It returns true if any metrics were emitted.
func (rmb *ResourceMetricsBuilder) emit(m pmetric.Metrics) bool {
	sm := pmetric.NewScopeMetrics()
	sm.Metrics().EnsureCapacity(rmb.metricsCapacity)
	rmb.metricSqlserverBatchRequestRate.emit(sm.Metrics())
	rmb.metricSqlserverBatchSQLCompilationRate.emit(sm.Metrics())
	rmb.metricSqlserverBatchSQLRecompilationRate.emit(sm.Metrics())
	rmb.metricSqlserverLockWaitRate.emit(sm.Metrics())
	rmb.metricSqlserverLockWaitTimeAvg.emit(sm.Metrics())
	rmb.metricSqlserverPageBufferCacheHitRatio.emit(sm.Metrics())
	rmb.metricSqlserverPageCheckpointFlushRate.emit(sm.Metrics())
	rmb.metricSqlserverPageLazyWriteRate.emit(sm.Metrics())
	rmb.metricSqlserverPageLifeExpectancy.emit(sm.Metrics())
	rmb.metricSqlserverPageOperationRate.emit(sm.Metrics())
	rmb.metricSqlserverPageSplitRate.emit(sm.Metrics())
	rmb.metricSqlserverTransactionRate.emit(sm.Metrics())
	rmb.metricSqlserverTransactionWriteRate.emit(sm.Metrics())
	rmb.metricSqlserverTransactionLogFlushDataRate.emit(sm.Metrics())
	rmb.metricSqlserverTransactionLogFlushRate.emit(sm.Metrics())
	rmb.metricSqlserverTransactionLogFlushWaitRate.emit(sm.Metrics())
	rmb.metricSqlserverTransactionLogGrowthCount.emit(sm.Metrics())
	rmb.metricSqlserverTransactionLogShrinkCount.emit(sm.Metrics())
	rmb.metricSqlserverTransactionLogUsage.emit(sm.Metrics())
	rmb.metricSqlserverUserConnectionCount.emit(sm.Metrics())
	if sm.Metrics().Len() == 0 {
		return false
	}
	rmb.updateCapacity(sm.Metrics())
	sm.Scope().SetName("otelcol/sqlserverreceiver")
	sm.Scope().SetVersion(rmb.buildInfo.Version)
	rm := m.ResourceMetrics().AppendEmpty()
	rmb.resource.CopyTo(rm.Resource())
	sm.MoveTo(rm.ScopeMetrics().AppendEmpty())
	return true
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit() pmetric.Metrics {
	m := pmetric.NewMetrics()
	for _, rmb := range mb.rmbMap {
		if ok := rmb.emit(m); !ok {
			rmb.missedEmits++
		}
	}
	for k, rmb := range mb.rmbMap {
		if rmb.missedEmits >= missedEmitsToDropRMB {
			delete(mb.rmbMap, k)
		}
	}
	return m
}

// RecordSqlserverBatchRequestRateDataPoint adds a data point to sqlserver.batch.request.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverBatchRequestRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverBatchRequestRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverBatchSQLCompilationRateDataPoint adds a data point to sqlserver.batch.sql_compilation.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverBatchSQLCompilationRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverBatchSQLCompilationRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverBatchSQLRecompilationRateDataPoint adds a data point to sqlserver.batch.sql_recompilation.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverBatchSQLRecompilationRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverBatchSQLRecompilationRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverLockWaitRateDataPoint adds a data point to sqlserver.lock.wait.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverLockWaitRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverLockWaitRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverLockWaitTimeAvgDataPoint adds a data point to sqlserver.lock.wait_time.avg metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverLockWaitTimeAvgDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverLockWaitTimeAvg.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverPageBufferCacheHitRatioDataPoint adds a data point to sqlserver.page.buffer_cache.hit_ratio metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverPageBufferCacheHitRatioDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverPageBufferCacheHitRatio.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverPageCheckpointFlushRateDataPoint adds a data point to sqlserver.page.checkpoint.flush.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverPageCheckpointFlushRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverPageCheckpointFlushRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverPageLazyWriteRateDataPoint adds a data point to sqlserver.page.lazy_write.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverPageLazyWriteRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverPageLazyWriteRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverPageLifeExpectancyDataPoint adds a data point to sqlserver.page.life_expectancy metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverPageLifeExpectancyDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricSqlserverPageLifeExpectancy.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverPageOperationRateDataPoint adds a data point to sqlserver.page.operation.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverPageOperationRateDataPoint(ts pcommon.Timestamp, val float64, pageOperationsAttributeValue AttributePageOperations) {
	rmb.metricSqlserverPageOperationRate.recordDataPoint(rmb.startTime, ts, val, pageOperationsAttributeValue.String())
}

// RecordSqlserverPageSplitRateDataPoint adds a data point to sqlserver.page.split.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverPageSplitRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverPageSplitRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverTransactionRateDataPoint adds a data point to sqlserver.transaction.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverTransactionRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverTransactionRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverTransactionWriteRateDataPoint adds a data point to sqlserver.transaction.write.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverTransactionWriteRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverTransactionWriteRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverTransactionLogFlushDataRateDataPoint adds a data point to sqlserver.transaction_log.flush.data.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverTransactionLogFlushDataRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverTransactionLogFlushDataRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverTransactionLogFlushRateDataPoint adds a data point to sqlserver.transaction_log.flush.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverTransactionLogFlushRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverTransactionLogFlushRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverTransactionLogFlushWaitRateDataPoint adds a data point to sqlserver.transaction_log.flush.wait.rate metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverTransactionLogFlushWaitRateDataPoint(ts pcommon.Timestamp, val float64) {
	rmb.metricSqlserverTransactionLogFlushWaitRate.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverTransactionLogGrowthCountDataPoint adds a data point to sqlserver.transaction_log.growth.count metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverTransactionLogGrowthCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricSqlserverTransactionLogGrowthCount.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverTransactionLogShrinkCountDataPoint adds a data point to sqlserver.transaction_log.shrink.count metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverTransactionLogShrinkCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricSqlserverTransactionLogShrinkCount.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverTransactionLogUsageDataPoint adds a data point to sqlserver.transaction_log.usage metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverTransactionLogUsageDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricSqlserverTransactionLogUsage.recordDataPoint(rmb.startTime, ts, val)
}

// RecordSqlserverUserConnectionCountDataPoint adds a data point to sqlserver.user.connection.count metric.
func (rmb *ResourceMetricsBuilder) RecordSqlserverUserConnectionCountDataPoint(ts pcommon.Timestamp, val int64) {
	rmb.metricSqlserverUserConnectionCount.recordDataPoint(rmb.startTime, ts, val)
}

// Reset resets the ResourceMetricsBuilder to its initial state. It should be used when external metrics source is
// restarted, and the ResourceMetricsBuilder should update its startTime and reset it's internal state accordingly.
func (rmb *ResourceMetricsBuilder) Reset(options ...resourceMetricsBuilderOption) {
	rmb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(rmb)
	}
}
